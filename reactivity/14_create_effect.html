<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Responding to Changes with create_effect</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started/leptos_dx.html"><strong aria-hidden="true">2.1.</strong> Leptos DX</a></li><li class="chapter-item expanded "><a href="../getting_started/community_crates.html"><strong aria-hidden="true">2.2.</strong> The Leptos Community and leptos-* Crates</a></li></ol></li><li class="chapter-item expanded "><a href="../view/index.html"><strong aria-hidden="true">3.</strong> Part 1: Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="../view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="../view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="../view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../view/04b_iteration.html"><strong aria-hidden="true">3.5.</strong> Iterating over More Complex Data</a></li><li class="chapter-item expanded "><a href="../view/05_forms.html"><strong aria-hidden="true">3.6.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="../view/06_control_flow.html"><strong aria-hidden="true">3.7.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../view/07_errors.html"><strong aria-hidden="true">3.8.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../view/08_parent_child.html"><strong aria-hidden="true">3.9.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="../view/09_component_children.html"><strong aria-hidden="true">3.10.</strong> Passing Children to Components</a></li><li class="chapter-item expanded "><a href="../view/builder.html"><strong aria-hidden="true">3.11.</strong> No Macros: The View Builder Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="../reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="../reactivity/14_create_effect.html" class="active"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="../reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="../async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="../async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="../async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="../15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="../router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="../router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="../router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="../router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="../router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="../metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="../csr_wrapping_up.html"><strong aria-hidden="true">12.</strong> Client-Side Rendering: Wrapping Up</a></li><li class="chapter-item expanded "><a href="../ssr/index.html"><strong aria-hidden="true">13.</strong> Part 2: Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ssr/21_cargo_leptos.html"><strong aria-hidden="true">13.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="../ssr/22_life_cycle.html"><strong aria-hidden="true">13.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="../ssr/23_ssr_modes.html"><strong aria-hidden="true">13.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="../ssr/24_hydration_bugs.html"><strong aria-hidden="true">13.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="../server/index.html"><strong aria-hidden="true">14.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/25_server_functions.html"><strong aria-hidden="true">14.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../server/26_extractors.html"><strong aria-hidden="true">14.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="../server/27_response.html"><strong aria-hidden="true">14.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="../progressive_enhancement/index.html"><strong aria-hidden="true">15.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../progressive_enhancement/action_form.html"><strong aria-hidden="true">15.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="../deployment/index.html"><strong aria-hidden="true">16.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../deployment/csr.html"><strong aria-hidden="true">16.1.</strong> Deploying CSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/ssr.html"><strong aria-hidden="true">16.2.</strong> Deploying SSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/binary_size.html"><strong aria-hidden="true">16.3.</strong> Optimizing WASM Binary Size</a></li></ol></li><li class="chapter-item expanded "><a href="../islands.html"><strong aria-hidden="true">17.</strong> Guide: Islands</a></li><li class="chapter-item expanded "><a href="../appendix_reactive_graph.html"><strong aria-hidden="true">18.</strong> Appendix: How Does the Reactive System Work?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="responding-to-changes-with-create_effect"><a class="header" href="#responding-to-changes-with-create_effect">Responding to Changes with <code>create_effect</code></a></h1>
<p>We’ve made it this far without having mentioned half of the reactive system: effects.</p>
<p>Reactivity works in two halves: updating individual reactive values (“signals”) notifies the pieces of code that depend on them (“effects”) that they need to run again. These two halves of the reactive system are inter-dependent. Without effects, signals can change within the reactive system but never be observed in a way that interacts with the outside world. Without signals, effects run once but never again, as there’s no observable value to subscribe to. Effects are quite literally “side effects” of the reactive system: they exist to synchronize the reactive system with the non-reactive world outside it.</p>
<p>Hidden behind the whole reactive DOM renderer that we’ve seen so far is a function called <code>create_effect</code>.</p>
<p><a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_effect.html"><code>create_effect</code></a> takes a function as its argument. It immediately runs the function. If you access any reactive signal inside that function, it registers the fact that the effect depends on that signal with the reactive runtime. Whenever one of the signals that the effect depends on changes, the effect runs again.</p>
<pre><code class="language-rust">let (a, set_a) = create_signal(0);
let (b, set_b) = create_signal(0);

create_effect(move |_| {
  // immediately prints &quot;Value: 0&quot; and subscribes to `a`
  log::debug!(&quot;Value: {}&quot;, a());
});</code></pre>
<p>The effect function is called with an argument containing whatever value it returned the last time it ran. On the initial run, this is <code>None</code>.</p>
<p>By default, effects <strong>do not run on the server</strong>. This means you can call browser-specific APIs within the effect function without causing issues. If you need an effect to run on the server, use <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_isomorphic_effect.html"><code>create_isomorphic_effect</code></a>.</p>
<h2 id="autotracking-and-dynamic-dependencies"><a class="header" href="#autotracking-and-dynamic-dependencies">Autotracking and Dynamic Dependencies</a></h2>
<p>If you’re familiar with a framework like React, you might notice one key difference. React and similar frameworks typically require you to pass a “dependency array,” an explicit set of variables that determine when the effect should rerun.</p>
<p>Because Leptos comes from the tradition of synchronous reactive programming, we don’t need this explicit dependency list. Instead, we automatically track dependencies depending on which signals are accessed within the effect.</p>
<p>This has two effects (no pun intended). Dependencies are:</p>
<ol>
<li><strong>Automatic</strong>: You don’t need to maintain a dependency list, or worry about what should or shouldn’t be included. The framework simply tracks which signals might cause the effect to rerun, and handles it for you.</li>
<li><strong>Dynamic</strong>: The dependency list is cleared and updated every time the effect runs. If your effect contains a conditional (for example), only signals that are used in the current branch are tracked. This means that effects rerun the absolute minimum number of times.</li>
</ol>
<blockquote>
<p>If this sounds like magic, and if you want a deep dive into how automatic dependency tracking works, <a href="https://www.youtube.com/watch?v=GWB3vTWeLd4">check out this video</a>. (Apologies for the low volume!)</p>
</blockquote>
<h2 id="effects-as-zero-cost-ish-abstraction"><a class="header" href="#effects-as-zero-cost-ish-abstraction">Effects as Zero-Cost-ish Abstraction</a></h2>
<p>While they’re not a “zero-cost abstraction” in the most technical sense—they require some additional memory use, exist at runtime, etc.—at a higher level, from the perspective of whatever expensive API calls or other work you’re doing within them, effects are a zero-cost abstraction. They rerun the absolute minimum number of times necessary, given how you’ve described them.</p>
<p>Imagine that I’m creating some kind of chat software, and I want people to be able to display their full name, or just their first name, and to notify the server whenever their name changes:</p>
<pre><code class="language-rust">let (first, set_first) = create_signal(String::new());
let (last, set_last) = create_signal(String::new());
let (use_last, set_use_last) = create_signal(true);

// this will add the name to the log
// any time one of the source signals changes
create_effect(move |_| {
    log(
        if use_last() {
            format!(&quot;{} {}&quot;, first(), last())
        } else {
            first()
        },
    )
});</code></pre>
<p>If <code>use_last</code> is <code>true</code>, effect should rerun whenever <code>first</code>, <code>last</code>, or <code>use_last</code> changes. But if I toggle <code>use_last</code> to <code>false</code>, a change in <code>last</code> will never cause the full name to change. In fact, <code>last</code> will be removed from the dependency list until <code>use_last</code> toggles again. This saves us from sending multiple unnecessary requests to the API if I change <code>last</code> multiple times while <code>use_last</code> is still <code>false</code>.</p>
<h2 id="to-create_effect-or-not-to-create_effect"><a class="header" href="#to-create_effect-or-not-to-create_effect">To <code>create_effect</code>, or not to <code>create_effect</code>?</a></h2>
<p>Effects are intended to run <em>side-effects</em> of the system, not to synchronize state <em>within</em> the system. In other words: don’t write to signals within effects.</p>
<p>If you need to define a signal that depends on the value of other signals, use a derived signal or <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_memo.html"><code>create_memo</code></a>.</p>
<p>If you need to synchronize some reactive value with the non-reactive world outside—like a web API, the console, the filesystem, or the DOM—create an effect.</p>
<blockquote>
<p>If you’re curious for more information about when you should and shouldn’t use <code>create_effect</code>, <a href="https://www.youtube.com/watch?v=aQOFJQ2JkvQ">check out this video</a> for a more in-depth consideration!</p>
</blockquote>
<h2 id="effects-and-rendering"><a class="header" href="#effects-and-rendering">Effects and Rendering</a></h2>
<p>We’ve managed to get this far without mentioning effects because they’re built into the Leptos DOM renderer. We’ve seen that you can create a signal and pass it into the <code>view</code> macro, and it will update the relevant DOM node whenever the signal changes:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);

view! {
    &lt;p&gt;{count}&lt;/p&gt;
}</code></pre>
<p>This works because the framework essentially creates an effect wrapping this update. You can imagine Leptos translating this view into something like this:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);

// create a DOM element
let p = create_element(&quot;p&quot;);

// create an effect to reactively update the text
create_effect(move |prev_value| {
    // first, access the signal’s value and convert it to a string
    let text = count().to_string();

    // if this is different from the previous value, update the node
    if prev_value != Some(text) {
        p.set_text_content(&amp;text);
    }

    // return this value so we can memoize the next update
    text
});</code></pre>
<p>Every time <code>count</code> is updated, this effect wil rerun. This is what allows reactive, fine-grained updates to the DOM.</p>
<h2 id="explicit-cancelable-tracking-with-watch"><a class="header" href="#explicit-cancelable-tracking-with-watch">Explicit, Cancelable Tracking with <code>watch</code></a></h2>
<p>In addition to <code>create_effect</code>, Leptos provides a <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.watch.html"><code>watch</code></a> function, which can be used for two main purposes:</p>
<ol>
<li>Separating tracking and responding to changes by explicitly passing in a set of values to track.</li>
<li>Canceling tracking by calling a stop function.</li>
</ol>
<p>Like <code>create_resource</code>, <code>watch</code> takes a first argument, which is reactively tracked, and a second, which is not. Whenever a reactive value in its <code>deps</code> argument is changed, the <code>callback</code> is run. <code>watch</code> returns a function that can be called to stop tracking the dependencies.</p>
<pre><code class="language-rust">let (num, set_num) = create_signal(0);

let stop = watch(
    move || num.get(),
    move |num, prev_num, _| {
        log::debug!(&quot;Number: {}; Prev: {:?}&quot;, num, prev_num);
    },
    false,
);

set_num.set(1); // &gt; &quot;Number: 1; Prev: Some(0)&quot;

stop(); // stop watching

set_num.set(2); // (nothing happens)</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/14-effect-0-5-d6hkch?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/14-effect-0-5-d6hkch?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::html::Input;
use leptos::*;

#[derive(Copy, Clone)]
struct LogContext(RwSignal&lt;Vec&lt;String&gt;&gt;);

#[component]
fn App() -&gt; impl IntoView {
    // Just making a visible log here
    // You can ignore this...
    let log = create_rw_signal::&lt;Vec&lt;String&gt;&gt;(vec![]);
    let logged = move || log().join(&quot;\n&quot;);

    // the newtype pattern isn't *necessary* here but is a good practice
    // it avoids confusion with other possible future `RwSignal&lt;Vec&lt;String&gt;&gt;` contexts
    // and makes it easier to refer to it
    provide_context(LogContext(log));

    view! {
        &lt;CreateAnEffect/&gt;
        &lt;pre&gt;{logged}&lt;/pre&gt;
    }
}

#[component]
fn CreateAnEffect() -&gt; impl IntoView {
    let (first, set_first) = create_signal(String::new());
    let (last, set_last) = create_signal(String::new());
    let (use_last, set_use_last) = create_signal(true);

    // this will add the name to the log
    // any time one of the source signals changes
    create_effect(move |_| {
        log(if use_last() {
            with!(|first, last| format!(&quot;{first} {last}&quot;))
        } else {
            first()
        })
    });

    view! {
        &lt;h1&gt;
            &lt;code&gt;&quot;create_effect&quot;&lt;/code&gt;
            &quot; Version&quot;
        &lt;/h1&gt;
        &lt;form&gt;
            &lt;label&gt;
                &quot;First Name&quot;
                &lt;input
                    type=&quot;text&quot;
                    name=&quot;first&quot;
                    prop:value=first
                    on:change=move |ev| set_first(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Last Name&quot;
                &lt;input
                    type=&quot;text&quot;
                    name=&quot;last&quot;
                    prop:value=last
                    on:change=move |ev| set_last(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot;
                &lt;input
                    type=&quot;checkbox&quot;
                    name=&quot;use_last&quot;
                    prop:checked=use_last
                    on:change=move |ev| set_use_last(event_target_checked(&amp;ev))
                /&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn ManualVersion() -&gt; impl IntoView {
    let first = create_node_ref::&lt;Input&gt;();
    let last = create_node_ref::&lt;Input&gt;();
    let use_last = create_node_ref::&lt;Input&gt;();

    let mut prev_name = String::new();
    let on_change = move |_| {
        log(&quot;      listener&quot;);
        let first = first.get().unwrap();
        let last = last.get().unwrap();
        let use_last = use_last.get().unwrap();
        let this_one = if use_last.checked() {
            format!(&quot;{} {}&quot;, first.value(), last.value())
        } else {
            first.value()
        };

        if this_one != prev_name {
            log(&amp;this_one);
            prev_name = this_one;
        }
    };

    view! {
        &lt;h1&gt;&quot;Manual Version&quot;&lt;/h1&gt;
        &lt;form on:change=on_change&gt;
            &lt;label&gt;&quot;First Name&quot; &lt;input type=&quot;text&quot; name=&quot;first&quot; node_ref=first/&gt;&lt;/label&gt;
            &lt;label&gt;&quot;Last Name&quot; &lt;input type=&quot;text&quot; name=&quot;last&quot; node_ref=last/&gt;&lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot; &lt;input type=&quot;checkbox&quot; name=&quot;use_last&quot; checked node_ref=use_last/&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn EffectVsDerivedSignal() -&gt; impl IntoView {
    let (my_value, set_my_value) = create_signal(String::new());
    // Don't do this.
    /*let (my_optional_value, set_optional_my_value) = create_signal(Option::&lt;String&gt;::None);

    create_effect(move |_| {
        if !my_value.get().is_empty() {
            set_optional_my_value(Some(my_value.get()));
        } else {
            set_optional_my_value(None);
        }
    });*/

    // Do this
    let my_optional_value =
        move || (!my_value.with(String::is_empty)).then(|| Some(my_value.get()));

    view! {
        &lt;input prop:value=my_value on:input=move |ev| set_my_value(event_target_value(&amp;ev))/&gt;

        &lt;p&gt;
            &lt;code&gt;&quot;my_optional_value&quot;&lt;/code&gt;
            &quot; is &quot;
            &lt;code&gt;
                &lt;Show when=move || my_optional_value().is_some() fallback=|| view! { &quot;None&quot; }&gt;
                    &quot;Some(\&quot;&quot;
                    {my_optional_value().unwrap()}
                    &quot;\&quot;)&quot;
                &lt;/Show&gt;
            &lt;/code&gt;
        &lt;/p&gt;
    }
}

#[component]
pub fn Show&lt;F, W, IV&gt;(
    /// The components Show wraps
    children: Box&lt;dyn Fn() -&gt; Fragment&gt;,
    /// A closure that returns a bool that determines whether this thing runs
    when: W,
    /// A closure that returns what gets rendered if the when statement is false
    fallback: F,
) -&gt; impl IntoView
where
    W: Fn() -&gt; bool + 'static,
    F: Fn() -&gt; IV + 'static,
    IV: IntoView,
{
    let memoized_when = create_memo(move |_| when());

    move || match memoized_when.get() {
        true =&gt; children().into_view(),
        false =&gt; fallback().into_view(),
    }
}

fn log(msg: impl std::fmt::Display) {
    let log = use_context::&lt;LogContext&gt;().unwrap().0;
    log.update(|log| log.push(msg.to_string()));
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reactivity/working_with_signals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reactivity/interlude_functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reactivity/working_with_signals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reactivity/interlude_functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
