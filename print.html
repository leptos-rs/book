<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/leptos_dx.html"><strong aria-hidden="true">2.1.</strong> Leptos DX</a></li><li class="chapter-item expanded "><a href="getting_started/community_crates.html"><strong aria-hidden="true">2.2.</strong> The Leptos Community and leptos-* Crates</a></li></ol></li><li class="chapter-item expanded "><a href="view/index.html"><strong aria-hidden="true">3.</strong> Part 1: Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="view/04b_iteration.html"><strong aria-hidden="true">3.5.</strong> Iterating over More Complex Data</a></li><li class="chapter-item expanded "><a href="view/05_forms.html"><strong aria-hidden="true">3.6.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="view/06_control_flow.html"><strong aria-hidden="true">3.7.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="view/07_errors.html"><strong aria-hidden="true">3.8.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="view/08_parent_child.html"><strong aria-hidden="true">3.9.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="view/09_component_children.html"><strong aria-hidden="true">3.10.</strong> Passing Children to Components</a></li><li class="chapter-item expanded "><a href="view/builder.html"><strong aria-hidden="true">3.11.</strong> No Macros: The View Builder Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="reactivity/14_create_effect.html"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="csr_wrapping_up.html"><strong aria-hidden="true">12.</strong> Client-Side Rendering: Wrapping Up</a></li><li class="chapter-item expanded "><a href="ssr/index.html"><strong aria-hidden="true">13.</strong> Part 2: Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ssr/21_cargo_leptos.html"><strong aria-hidden="true">13.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="ssr/22_life_cycle.html"><strong aria-hidden="true">13.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="ssr/23_ssr_modes.html"><strong aria-hidden="true">13.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="ssr/24_hydration_bugs.html"><strong aria-hidden="true">13.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="server/index.html"><strong aria-hidden="true">14.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server/25_server_functions.html"><strong aria-hidden="true">14.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="server/26_extractors.html"><strong aria-hidden="true">14.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="server/27_response.html"><strong aria-hidden="true">14.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="progressive_enhancement/index.html"><strong aria-hidden="true">15.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="progressive_enhancement/action_form.html"><strong aria-hidden="true">15.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="deployment/index.html"><strong aria-hidden="true">16.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deployment/csr.html"><strong aria-hidden="true">16.1.</strong> Deploying CSR Apps</a></li><li class="chapter-item expanded "><a href="deployment/ssr.html"><strong aria-hidden="true">16.2.</strong> Deploying SSR Apps</a></li><li class="chapter-item expanded "><a href="deployment/binary_size.html"><strong aria-hidden="true">16.3.</strong> Optimizing WASM Binary Size</a></li></ol></li><li class="chapter-item expanded "><a href="islands.html"><strong aria-hidden="true">17.</strong> Guide: Islands</a></li><li class="chapter-item expanded "><a href="appendix_reactive_graph.html"><strong aria-hidden="true">18.</strong> Appendix: How Does the Reactive System Work?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is intended as an introduction to the <a href="https://github.com/leptos-rs/leptos">Leptos</a> Web framework.
It will walk through the fundamental concepts you need to build applications,
beginning with a simple application rendered in the browser, and building toward a
full-stack application with server-side rendering and hydration.</p>
<p>The guide doesn’t assume you know anything about fine-grained reactivity or the
details of modern Web frameworks. It does assume you are familiar with the Rust
programming language, HTML, CSS, and the DOM and basic Web APIs.</p>
<p>Leptos is most similar to frameworks like <a href="https://www.solidjs.com">Solid</a> (JavaScript)
and <a href="https://sycamore-rs.netlify.app/">Sycamore</a> (Rust). There are some similarities
to other frameworks like React (JavaScript), Svelte (JavaScript), Yew (Rust), and
Dioxus (Rust), so knowledge of one of those frameworks may also make it easier to
understand Leptos.</p>
<p>You can find more detailed docs for each part of the API at <a href="https://docs.rs/leptos/latest/leptos/">Docs.rs</a>.</p>
<blockquote>
<p>The source code for the book is available <a href="https://github.com/leptos-rs/book">here</a>. PRs for typos or clarification are always welcome.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>There are two basic paths to getting started with Leptos:</p>
<ol>
<li>
<p><strong>Client-side rendering (CSR) with <a href="https://trunkrs.dev/">Trunk</a></strong> - a great option if you just want to make a snappy website with Leptos, or work with a pre-existing server or API.
In CSR mode, Trunk compiles your Leptos app to WebAssembly (WASM) and runs it in the browser like a typical Javascript single-page app (SPA). The advantages of Leptos CSR include faster build times and a quicker iterative development cycle, as well as a simpler mental model and more options for deploying your app. CSR apps do come with some disadvantages: initial load times for your end users are slower compared to a server-side rendering approach, and the usual SEO challenges that come along with using a JS single-page app model apply to Leptos CSR apps as well. Also note that, under the hood, an auto-generated snippet of JS is used to load the Leptos WASM bundle, so JS <em>must</em> be enabled on the client device for your CSR app to display properly. As with all software engineering, there are trade-offs here you'll need to consider.</p>
</li>
<li>
<p><strong>Full-stack, server-side rendering (SSR) with <a href="https://github.com/leptos-rs/cargo-leptos"><code>cargo-leptos</code></a></strong> - SSR is a great option for building CRUD-style websites and custom web apps if you want Rust powering both your frontend and backend.
With the Leptos SSR option, your app is rendered to HTML on the server and sent down to the browser; then, WebAssembly is used to instrument the HTML so your app becomes interactive - this process is called 'hydration'. On the server side, Leptos SSR apps integrate closely with your choice of either <a href="https://docs.rs/leptos_actix/latest/leptos_actix/index.html">Actix-web</a> or <a href="https://docs.rs/leptos_axum/latest/leptos_axum/index.html">Axum</a> server libraries, so you can leverage those communities' crates to help build out your Leptos server.
The advantages of taking the SSR route with Leptos include helping you get the best initial load times and optimal SEO scores for your web app. SSR apps can also dramatically simplify working across the server/client boundary via a Leptos feature called &quot;server functions&quot;, which lets you transparently call functions on the server from your client code (more on this feature later). Full-stack SSR isn't all rainbows and butterflies, though - disadvantages include a slower developer iteration loop (because you need to recompile both the server and client when making Rust code changes), as well as some added complexity that comes along with hydration.</p>
</li>
</ol>
<p>By the end of the book, you should have a good idea of which trade-offs to make and which route to take - CSR or SSR - depending on your project's requirements.</p>
<p>In Part 1 of this book, we'll start with client-side rendering Leptos sites and building reactive UI's using <code>Trunk</code> to serve our JS and WASM bundle to the browser.</p>
<p>We’ll introduce <code>cargo-leptos</code> in Part 2 of this book, which is all about working with the full power of Leptos in its full-stack, SSR mode.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="getting_started/index.html#admonition-note"></a></p>
</div>
<div>
<p>If you're coming from the Javascript world and terms like client-side rendering (CSR) and server-side rendering (SSR) are unfamiliar to you, the easiest way to understand the difference is by analogy:</p>
<p>Leptos' CSR mode is similar to working with React (or a 'signals'-based framework like SolidJS), and focuses on producing a client-side UI which you can use with any tech stack on the server.</p>
<p>Using Leptos' SSR mode is similar to working with a full-stack framework like Next.js in the React world (or Solid's &quot;SolidStart&quot; framework) - SSR helps you build sites and apps that are rendered on the server then sent down to the client. SSR can help to improve your site's loading performance and accessibility as well as make it easier for one person to work on <em>both</em> client- and server-side without needing to context-switch between different languages for frontend and backend.</p>
<p>The Leptos framework can be used either in CSR mode to just make a UI (like React), or you can use Leptos in full-stack SSR mode (like Next.js) so that you can build both your UI and your server with one language: Rust.</p>
</div>
</div>
<h2 id="hello-world-getting-set-up-for-leptos-csr-development"><a class="header" href="#hello-world-getting-set-up-for-leptos-csr-development">Hello World! Getting Set up for Leptos CSR Development</a></h2>
<p>First up, make sure Rust is installed and up-to-date (<a href="https://www.rust-lang.org/tools/install">see here if you need instructions</a>).</p>
<p>If you don’t have it installed already, you can install the &quot;Trunk&quot; tool for running Leptos CSR sites by running the following on the command-line:</p>
<pre><code class="language-bash">cargo install trunk
</code></pre>
<p>And then create a basic Rust project</p>
<pre><code class="language-bash">cargo init leptos-tutorial
</code></pre>
<p><code>cd</code> into your new <code>leptos-tutorial</code> project and add <code>leptos</code> as a dependency</p>
<pre><code class="language-bash">cargo add leptos --features=csr,nightly
</code></pre>
<p>Or you can leave off <code>nightly</code> if you're using stable Rust</p>
<pre><code class="language-bash">cargo add leptos --features=csr
</code></pre>
<blockquote>
<p>Using <code>nightly</code> Rust, and the <code>nightly</code> feature in Leptos enables the function-call syntax for signal getters and setters that is used in most of this book.</p>
<p>To use nightly Rust, you can either opt into nightly for all your Rust projects by running</p>
<pre><code class="language-bash">rustup toolchain install nightly
rustup default nightly
</code></pre>
<p>or only for this project</p>
<pre><code class="language-bash">rustup toolchain install nightly
cd &lt;into your project&gt;
rustup override set nightly
</code></pre>
<p><a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">See here for more details.</a></p>
<p>If you’d rather use stable Rust with Leptos, you can do that too. In the guide and examples, you’ll just use the <a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html#impl-SignalGet%3CT%3E-for-ReadSignal%3CT%3E"><code>ReadSignal::get()</code></a> and <a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html#impl-SignalGet%3CT%3E-for-ReadSignal%3CT%3E"><code>WriteSignal::set()</code></a> methods instead of calling signal getters and setters as functions.</p>
</blockquote>
<p>Make sure you've added the <code>wasm32-unknown-unknown</code> target so that Rust can compile your code to WebAssembly to run in the browser.</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<p>Create a simple <code>index.html</code> in the root of the <code>leptos-tutorial</code> directory</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>And add a simple “Hello, world!” to your <code>main.rs</code></p>
<pre><code class="language-rust">use leptos::*;

fn main() {
    mount_to_body(|| view! { &lt;p&gt;&quot;Hello, world!&quot;&lt;/p&gt; })
}</code></pre>
<p>Your directory structure should now look something like this</p>
<pre><code>leptos_tutorial
├── src
│   └── main.rs
├── Cargo.toml
├── index.html
</code></pre>
<p>Now run <code>trunk serve --open</code> from the root of the <code>leptos-tutorial</code> directory.
Trunk should automatically compile your app and open it in your default browser.
If you make edits to <code>main.rs</code>, Trunk will recompile your source code and
live-reload the page.</p>
<p>Welcome to the world of UI development with Rust and WebAssembly (WASM), powered by Leptos and Trunk!</p>
<hr />
<p>Now before we get started building your first real UI's with Leptos, there are a couple of things you might want to know to help make your experience with Leptos just a little bit easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-developer-experience-improvements"><a class="header" href="#leptos-developer-experience-improvements">Leptos Developer Experience Improvements</a></h1>
<p>There are a couple of things you can do to improve your experience of developing websites and apps with Leptos. You may want to take a few minutes and set up your environment to optimize your development experience, especially if you want to code along with the examples in this book.</p>
<h2 id="1-editor-autocompletion-inside-component-and-server"><a class="header" href="#1-editor-autocompletion-inside-component-and-server">1) Editor Autocompletion inside <code>#[component]</code> and <code>#[server]</code></a></h2>
<p>Because of the nature of macros (they can expand from anything to anything, but only if the input is exactly correct at that instant) it can be hard for rust-analyzer to do proper autocompletion and other support.</p>
<p>If you run into issues using these macros in your editor, you can explicitly tell rust-analyzer to ignore certain proc macros. For the <code>#[server]</code> macro especially, which annotates function bodies but doesn't actually transform anything inside the body of your function, this can be really helpful.</p>
<p>Starting in Leptos version 0.5.3, rust-analyzer support was added for the <code>#[component]</code> macro, but if you run into issues, you may want to add <code>#[component]</code> to the macro ignore list as well (see below).
Note that this means that rust-analyzer doesn't know about your component props, which may generate its own set of errors or warnings in the IDE.</p>
<p>VSCode <code>settings.json</code>:</p>
<pre><code class="language-json">&quot;rust-analyzer.procMacro.ignored&quot;: {
	&quot;leptos_macro&quot;: [
        // optional:
		// &quot;component&quot;,
		&quot;server&quot;
	],
}
</code></pre>
<p>neovim with lspconfig:</p>
<pre><code class="language-lua">require('lspconfig').rust_analyzer.setup {
  -- Other Configs ...
  settings = {
    [&quot;rust-analyzer&quot;] = {
      -- Other Settings ...
      procMacro = {
        ignored = {
            leptos_macro = {
                -- optional: --
                -- &quot;component&quot;,
                &quot;server&quot;,
            },
        },
      },
    },
  }
}
</code></pre>
<p>Helix, in <code>.helix/languages.toml</code>:</p>
<pre><code class="language-toml">[[language]]
name = &quot;rust&quot;

[language-server.rust-analyzer]
config = { procMacro = { ignored =
    { leptos_macro =
        [
          # Optional:
          # &quot;component&quot;,
          &quot;server&quot;
        ] } } }
</code></pre>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="getting_started/leptos_dx.html#admonition-info"></a></p>
</div>
<div>
<p>The Jetbrains <code>intellij-rust</code> plugin (RustRover as well) currently does not support dynamic config for macro exclusion.
However, the project currently maintains a hardcoded list of excluded macros.
As soon as <a href="https://github.com/intellij-rust/intellij-rust/pull/10873">this open PR</a> is merged, the <code>component</code> and
<code>server</code> macro will be excluded automatically without additional configuration needed.</p>
<p>Update (2023/10/02):
The <code>intellij-rust</code> plugin got deprecated in favor of RustRover at the same time the PR was opened, but an official
support request was made to integrate the contents of this PR.</p>
</div>
</div>
<h2 id="2-set-up-leptosfmt-with-rust-analyzer-optional"><a class="header" href="#2-set-up-leptosfmt-with-rust-analyzer-optional">2) Set up <code>leptosfmt</code> With Rust Analyzer (optional)</a></h2>
<p>&quot;leptosfmt&quot; is a formatter for the Leptos <code>view!</code> macro (inside of which you'll typically write your UI code). Because the view! macro enables an 'RSX' (like JSX) style of writing your UI's, cargo-fmt has a harder time auto-formatting your code that's inside the view! macro. leptosfmt is a crate that solves your formattting issues and keeps your RSX-style UI code looking nice and tidy!</p>
<p>leptosfmt can be installed and used via the commandline or from within your code editor:</p>
<p>First, install the tool with <code>cargo install leptosfmt</code>.</p>
<p>If you just want to use the default options from the command line, just run <code>leptosfmt ./**/*.rs</code> from the root of your project to format all the rust files using leptosfmt.</p>
<p>If you wish to set up your editor to work with leptosfmt, or if you wish to customize your leptosfmt experience, please see the instructions available on the <a href="https://github.com/bram209/leptosfmt">leptosfmt github repo's README.md page</a>.</p>
<p>Just note that it's recommended to set up your editor with <code>leptosfmt</code> on a per-workspace basis for best results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-leptos-community-and-leptos--crates"><a class="header" href="#the-leptos-community-and-leptos--crates">The Leptos Community and <code>leptos-*</code> Crates</a></h1>
<h2 id="the-community"><a class="header" href="#the-community">The Community</a></h2>
<p>One final note before we get to building with Leptos: if you haven't already, feel free to join the growing community on the Leptos <a href="https://discord.gg/YdRAhS7eQB">Discord</a> and on <a href="https://github.com/leptos-rs/leptos">Github</a>. Our Discord channel in particular is very active and friendly - we'd love to have you there!</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="getting_started/community_crates.html#admonition-note"></a></p>
</div>
<div>
<p>If you find a chapter or an explanation that isn't clear while you're working your way through the Leptos book, just mention it in the &quot;docs-and-education&quot; channel or ask a question in &quot;help&quot; so we can clear things up and update the book for others.</p>
</div>
</div>
<p>As you get further along in your Leptos journey and find that you have questions about &quot;how to do 'x' with Leptos&quot;, then search the Discord &quot;help&quot; channel to see if a similar question has been asked before, or feel free to post your own question - the community is quite helpful and very responsive.</p>
<p>The &quot;<a href="https://github.com/leptos-rs/leptos/discussions">Discussions</a>&quot; on Github are also a great place for asking questions and keeping up with Leptos announcements.</p>
<p>And of course, if you run into any bugs while developing with Leptos or would like to make a feature request (or contribute a bug fix / new feature), open up an issue on the <a href="https://github.com/leptos-rs/leptos/issues">Github issue tracker</a>.</p>
<h2 id="leptos--crates"><a class="header" href="#leptos--crates">Leptos-* Crates</a></h2>
<p>The community has built a growing number of Leptos-related crates that will help you get productive with Leptos projects more quickly - check out the list of crates built on top of Leptos and contributed by the community on the <a href="https://github.com/leptos-rs/awesome-leptos">Awesome Leptos</a> repo on Github.</p>
<p>If you want to find the newest, up-and-coming Leptos-related crates, check out the &quot;Tools and Libraries&quot; section of the Leptos Discord. In that section, there are channels for the Leptos <code>view!</code> macro formatter (in the &quot;leptosfmt&quot; channel); there's a channel for the utility library &quot;leptos-use&quot;; another channel for the UI component libary &quot;leptonic&quot;;  and a &quot;libraries&quot; channel where new <code>leptos-*</code> crates are discussed before making their way into the growing list of crates and resources available on <a href="https://github.com/leptos-rs/awesome-leptos">Awesome Leptos</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-1-building-user-interfaces"><a class="header" href="#part-1-building-user-interfaces">Part 1: Building User Interfaces</a></h1>
<p>In the first part of the book, we're going to look at building user interfaces on the client-side using Leptos. Under the hood, Leptos and Trunk are bundling up a snippet of Javascript which will load up the Leptos UI, which has been compiled to WebAssembly to drive the interactivity in your CSR (client-side rendered) website.</p>
<p>Part 1 will introduce you to the basic tools you need to build a reactive user interface powered by Leptos and Rust. By the end of Part 1, you should be able to
build a snappy synchronous website that's rendered in the browser and which you can deploy on any static-site hosting service, like Github Pages or Vercel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-component"><a class="header" href="#a-basic-component">A Basic Component</a></h1>
<p>That “Hello, world!” was a <em>very</em> simple example. Let’s move on to something a
little more like an ordinary app.</p>
<p>First, let’s edit the <code>main</code> function so that, instead of rendering the whole
app, it just renders an <code>&lt;App/&gt;</code> component. Components are the basic unit of
composition and design in most web frameworks, and Leptos is no exception.
Conceptually, they are similar to HTML elements: they represent a section of the
DOM, with self-contained, defined behavior. Unlike HTML elements, they are in
<code>PascalCase</code>, so most Leptos applications will start with something like an
<code>&lt;App/&gt;</code> component.</p>
<pre><code class="language-rust">fn main() {
    leptos::mount_to_body(|| view! { &lt;App/&gt; })
}</code></pre>
<p>Now let’s define our <code>&lt;App/&gt;</code> component itself. Because it’s relatively simple,
I’ll give you the whole thing up front, then walk through it line by line.</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;button
            on:click=move |_| {
                set_count(3);
            }
        &gt;
            &quot;Click me: &quot;
            {move || count.get()}
        &lt;/button&gt;
    }
}</code></pre>
<h2 id="the-component-signature"><a class="header" href="#the-component-signature">The Component Signature</a></h2>
<pre><code class="language-rust">#[component]</code></pre>
<p>Like all component definitions, this begins with the <a href="https://docs.rs/leptos/latest/leptos/attr.component.html"><code>#[component]</code></a> macro. <code>#[component]</code> annotates a function so it can be
used as a component in your Leptos application. We’ll see some of the other features of
this macro in a couple chapters.</p>
<pre><code class="language-rust">fn App() -&gt; impl IntoView</code></pre>
<p>Every component is a function with the following characteristics</p>
<ol>
<li>It takes zero or more arguments of any type.</li>
<li>It returns <code>impl IntoView</code>, which is an opaque type that includes
anything you could return from a Leptos <code>view</code>.</li>
</ol>
<blockquote>
<p>Component function arguments are gathered together into a single props struct which is built by the <code>view</code> macro as needed.</p>
</blockquote>
<h2 id="the-component-body"><a class="header" href="#the-component-body">The Component Body</a></h2>
<p>The body of the component function is a set-up function that runs once, not a
render function that reruns multiple times. You’ll typically use it to create a
few reactive variables, define any side effects that run in response to those values
changing, and describe the user interface.</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);</code></pre>
<p><a href="https://docs.rs/leptos/latest/leptos/fn.create_signal.html"><code>create_signal</code></a>
creates a signal, the basic unit of reactive change and state management in Leptos.
This returns a <code>(getter, setter)</code> tuple. To access the current value, you’ll
use <code>count.get()</code> (or, on <code>nightly</code> Rust, the shorthand <code>count()</code>). To set the
current value, you’ll call <code>set_count.set(...)</code> (or <code>set_count(...)</code>).</p>
<blockquote>
<p><code>.get()</code> clones the value and <code>.set()</code> overwrites it. In many cases, it’s more efficient to use <code>.with()</code> or <code>.update()</code>; check out the docs for <a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html"><code>ReadSignal</code></a> and <a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html"><code>WriteSignal</code></a> if you’d like to learn more about those trade-offs at this point.</p>
</blockquote>
<h2 id="the-view"><a class="header" href="#the-view">The View</a></h2>
<p>Leptos defines user interfaces using a JSX-like format via the <a href="https://docs.rs/leptos/latest/leptos/macro.view.html"><code>view</code></a> macro.</p>
<pre><code class="language-rust">view! {
    &lt;button
        // define an event listener with on:
        on:click=move |_| {
            // on stable, this is set_count.set(3);
            set_count(3);
        }
    &gt;
        // text nodes are wrapped in quotation marks
        &quot;Click me: &quot;
        // blocks can include Rust code
        {move || count.get()}
    &lt;/button&gt;
}</code></pre>
<p>This should mostly be easy to understand: it looks like HTML, with a special
<code>on:click</code> to define a <code>click</code> event listener, a text node that’s formatted like
a Rust string, and then...</p>
<pre><code class="language-rust">{move || count.get()}</code></pre>
<p>whatever that is.</p>
<p>People sometimes joke that they use more closures in their first Leptos application
than they’ve ever used in their lives. And fair enough. Basically, passing a function
into the view tells the framework: “Hey, this is something that might change.”</p>
<p>When we click the button and call <code>set_count</code>, the <code>count</code> signal is updated. This
<code>move || count.get()</code> closure, whose value depends on the value of <code>count</code>, reruns,
and the framework makes a targeted update to that one specific text node, touching
nothing else in your application. This is what allows for extremely efficient updates
to the DOM.</p>
<p>Now, if you have Clippy on—or if you have a particularly sharp eye—you might notice
that this closure is redundant, at least if you’re in <code>nightly</code> Rust. If you’re using
Leptos with <code>nightly</code> Rust, signals are already functions, so the closure is unnecessary.
As a result, you can write a simpler view:</p>
<pre><code class="language-rust">view! {
    &lt;button /* ... */&gt;
        &quot;Click me: &quot;
        // identical to {move || count.get()}
        {count}
    &lt;/button&gt;
}</code></pre>
<p>Remember—and this is <em>very important</em>—only functions are reactive. This means that
<code>{count}</code> and <code>{count()}</code> do very different things in your view. <code>{count}</code> passes
in a function, telling the framework to update the view every time <code>count</code> changes.
<code>{count()}</code> accesses the value of <code>count</code> once, and passes an <code>i32</code> into the view,
rendering it once, unreactively. You can see the difference in the CodeSandbox below!</p>
<p>Let’s make one final change. <code>set_count(3)</code> is a pretty useless thing for a click handler to do. Let’s replace “set this value to 3” with “increment this value by 1”:</p>
<pre><code class="language-rust">move |_| {
    set_count.update(|n| *n += 1);
}</code></pre>
<p>You can see here that while <code>set_count</code> just sets the value, <code>set_count.update()</code> gives us a mutable reference and mutates the value in place. Either one will trigger a reactive update in our UI.</p>
<blockquote>
<p>Throughout this tutorial, we’ll use CodeSandbox to show interactive examples. To
show the browser in the sandbox, you may need to click <code>Add DevTools &gt; Other Previews &gt; 8080.</code> Hover over any of the variables to show Rust-Analyzer details
and docs for what’s going on. Feel free to fork the examples to play with them yourself!</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/1-basic-component-3d74p3?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/1-basic-component-3d74p3?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

// The #[component] macro marks a function as a reusable component
// Components are the building blocks of your user interface
// They define a reusable unit of behavior
#[component]
fn App() -&gt; impl IntoView {
    // here we create a reactive signal
    // and get a (getter, setter) pair
    // signals are the basic unit of change in the framework
    // we'll talk more about them later
    let (count, set_count) = create_signal(0);

    // the `view` macro is how we define the user interface
    // it uses an HTML-like format that can accept certain Rust values
    view! {
        &lt;button
            // on:click will run whenever the `click` event fires
            // every event handler is defined as `on:{eventname}`

            // we're able to move `set_count` into the closure
            // because signals are Copy and 'static
            on:click=move |_| {
                set_count.update(|n| *n += 1);
            }
        &gt;
            // text nodes in RSX should be wrapped in quotes,
            // like a normal Rust string
            &quot;Click me&quot;
        &lt;/button&gt;
        &lt;p&gt;
            &lt;strong&gt;&quot;Reactive: &quot;&lt;/strong&gt;
            // you can insert Rust expressions as values in the DOM
            // by wrapping them in curly braces
            // if you pass in a function, it will reactively update
            {move || count.get()}
        &lt;/p&gt;
        &lt;p&gt;
            &lt;strong&gt;&quot;Reactive shorthand: &quot;&lt;/strong&gt;
            // signals are functions, so we can remove the wrapping closure
            {count}
        &lt;/p&gt;
        &lt;p&gt;
            &lt;strong&gt;&quot;Not reactive: &quot;&lt;/strong&gt;
            // NOTE: if you write {count()}, this will *not* be reactive
            // it simply gets the value of count once
            {count()}
        &lt;/p&gt;
    }
}

// This `main` function is the entry point into the app
// It just mounts our component to the &lt;body&gt;
// Because we defined it as `fn App`, we can now use it in a
// template as &lt;App/&gt;
fn main() {
    leptos::mount_to_body(|| view! { &lt;App/&gt; })
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-dynamic-classes-styles-and-attributes"><a class="header" href="#view-dynamic-classes-styles-and-attributes"><code>view</code>: Dynamic Classes, Styles and Attributes</a></h1>
<p>So far we’ve seen how to use the <code>view</code> macro to create event listeners and to
create dynamic text by passing a function (such as a signal) into the view.</p>
<p>But of course there are other things you might want to update in your user interface.
In this section, we’ll look at how to update classes, styles and attributes dynamically,
and we’ll introduce the concept of a <strong>derived signal</strong>.</p>
<p>Let’s start with a simple component that should be familiar: click a button to
increment a counter.</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;button
            on:click=move |_| {
                set_count.update(|n| *n += 1);
            }
        &gt;
            &quot;Click me: &quot;
            {move || count()}
        &lt;/button&gt;
    }
}</code></pre>
<p>So far, this is just the example from the last chapter.</p>
<h2 id="dynamic-classes"><a class="header" href="#dynamic-classes">Dynamic Classes</a></h2>
<p>Now let’s say I’d like to update the list of CSS classes on this element dynamically.
For example, let’s say I want to add the class <code>red</code> when the count is odd. I can
do this using the <code>class:</code> syntax.</p>
<pre><code class="language-rust">class:red=move || count() % 2 == 1</code></pre>
<p><code>class:</code> attributes take</p>
<ol>
<li>the class name, following the colon (<code>red</code>)</li>
<li>a value, which can be a <code>bool</code> or a function that returns a <code>bool</code></li>
</ol>
<p>When the value is <code>true</code>, the class is added. When the value is <code>false</code>, the class
is removed. And if the value is a function that accesses a signal, the class will
reactively update when the signal changes.</p>
<p>Now every time I click the button, the text should toggle between red and black as
the number switches between even and odd.</p>
<pre><code class="language-rust">&lt;button
    on:click=move |_| {
        set_count.update(|n| *n += 1);
    }
    // the class: syntax reactively updates a single class
    // here, we'll set the `red` class when `count` is odd
    class:red=move || count() % 2 == 1
&gt;
    &quot;Click me&quot;
&lt;/button&gt;</code></pre>
<blockquote>
<p>If you’re following along, make sure you go into your <code>index.html</code> and add something like this:</p>
<pre><code class="language-html">&lt;style&gt;
  .red {
    color: red;
  }
&lt;/style&gt;
</code></pre>
</blockquote>
<p>Some CSS class names can’t be directly parsed by the <code>view</code> macro, especially if they include a mix of dashes and numbers or other characters. In that case, you can use a tuple syntax: <code>class=(&quot;name&quot;, value)</code> still directly updates a single class.</p>
<pre><code class="language-rust">class=(&quot;button-20&quot;, move || count() % 2 == 1)</code></pre>
<h2 id="dynamic-styles"><a class="header" href="#dynamic-styles">Dynamic Styles</a></h2>
<p>Individual CSS properties can be directly updated with a similar <code>style:</code> syntax.</p>
<pre><code class="language-rust">    let (x, set_x) = create_signal(0);
        view! {
            &lt;button
                on:click={move |_| {
                    set_x.update(|n| *n += 10);
                }}
                // set the `style` attribute
                style=&quot;position: absolute&quot;
                // and toggle individual CSS properties with `style:`
                style:left=move || format!(&quot;{}px&quot;, x() + 100)
                style:background-color=move || format!(&quot;rgb({}, {}, 100)&quot;, x(), 100)
                style:max-width=&quot;400px&quot;
                // Set a CSS variable for stylesheet use
                style=(&quot;--columns&quot;, x)
            &gt;
                &quot;Click to Move&quot;
            &lt;/button&gt;
    }</code></pre>
<h2 id="dynamic-attributes"><a class="header" href="#dynamic-attributes">Dynamic Attributes</a></h2>
<p>The same applies to plain attributes. Passing a plain string or primitive value to
an attribute gives it a static value. Passing a function (including a signal) to
an attribute causes it to update its value reactively. Let’s add another element
to our view:</p>
<pre><code class="language-rust">&lt;progress
    max=&quot;50&quot;
    // signals are functions, so `value=count` and `value=move || count.get()`
    // are interchangeable.
    value=count
/&gt;</code></pre>
<p>Now every time we set the count, not only will the <code>class</code> of the <code>&lt;button&gt;</code> be
toggled, but the <code>value</code> of the <code>&lt;progress&gt;</code> bar will increase, which means that
our progress bar will move forward.</p>
<h2 id="derived-signals"><a class="header" href="#derived-signals">Derived Signals</a></h2>
<p>Let’s go one layer deeper, just for fun.</p>
<p>You already know that we create reactive interfaces just by passing functions into
the <code>view</code>. This means that we can easily change our progress bar. For example,
suppose we want it to move twice as fast:</p>
<pre><code class="language-rust">&lt;progress
    max=&quot;50&quot;
    value=move || count() * 2
/&gt;</code></pre>
<p>But imagine we want to reuse that calculation in more than one place. You can do this
using a <strong>derived signal</strong>: a closure that accesses a signal.</p>
<pre><code class="language-rust">let double_count = move || count() * 2;

/* insert the rest of the view */
&lt;progress
    max=&quot;50&quot;
    // we use it once here
    value=double_count
/&gt;
&lt;p&gt;
    &quot;Double Count: &quot;
    // and again here
    {double_count}
&lt;/p&gt;</code></pre>
<p>Derived signals let you create reactive computed values that can be used in multiple
places in your application with minimal overhead.</p>
<p>Note: Using a derived signal like this means that the calculation runs once per
signal change (when <code>count()</code> changes) and once per place we access <code>double_count</code>;
in other words, twice. This is a very cheap calculation, so that’s fine.
We’ll look at memos in a later chapter, which were designed to solve this problem
for expensive calculations.</p>
<blockquote>
<h4 id="advanced-topic-injecting-raw-html"><a class="header" href="#advanced-topic-injecting-raw-html">Advanced Topic: Injecting Raw HTML</a></h4>
<p>The <code>view</code> macro provides support for an additional attribute, <code>inner_html</code>, which
can be used to directly set the HTML contents of any element, wiping out any other
children you’ve given it. Note that this does <em>not</em> escape the HTML you provide. You
should make sure that it only contains trusted input or that any HTML entities are
escaped, to prevent cross-site scripting (XSS) attacks.</p>
<pre><code class="language-rust">let html = &quot;&lt;p&gt;This HTML will be injected.&lt;/p&gt;&quot;;
view! {
  &lt;div inner_html=html/&gt;
}</code></pre>
<p><a href="https://docs.rs/leptos/latest/leptos/macro.view.html">Click here for the full <code>view</code> macros docs</a>.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/2-dynamic-attributes-0-5-lwdrpm?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/2-dynamic-attributes-0-5-lwdrpm?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    // a &quot;derived signal&quot; is a function that accesses other signals
    // we can use this to create reactive values that depend on the
    // values of one or more other signals
    let double_count = move || count() * 2;

    view! {
        &lt;button
            on:click=move |_| {
                set_count.update(|n| *n += 1);
            }

            // the class: syntax reactively updates a single class
            // here, we'll set the `red` class when `count` is odd
            class:red=move || count() % 2 == 1
        &gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        // NOTE: self-closing tags like &lt;br&gt; need an explicit /
        &lt;br/&gt;

        // We'll update this progress bar every time `count` changes
        &lt;progress
            // static attributes work as in HTML
            max=&quot;50&quot;

            // passing a function to an attribute
            // reactively sets that attribute
            // signals are functions, so this &lt;=&gt; `move || count.get()`
            value=count
        &gt;&lt;/progress&gt;
        &lt;br/&gt;

        // This progress bar will use `double_count`
        // so it should move twice as fast!
        &lt;progress
            max=&quot;50&quot;
            // derived signals are functions, so they can also
            // reactive update the DOM
            value=double_count
        &gt;&lt;/progress&gt;
        &lt;p&gt;&quot;Count: &quot; {count}&lt;/p&gt;
        &lt;p&gt;&quot;Double Count: &quot; {double_count}&lt;/p&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-and-props"><a class="header" href="#components-and-props">Components and Props</a></h1>
<p>So far, we’ve been building our whole application in a single component. This
is fine for really tiny examples, but in any real application you’ll need to
break the user interface out into multiple components, so you can break your
interface down into smaller, reusable, composable chunks.</p>
<p>Let’s take our progress bar example. Imagine that you want two progress bars
instead of one: one that advances one tick per click, one that advances two ticks
per click.</p>
<p>You <em>could</em> do this by just creating two <code>&lt;progress&gt;</code> elements:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
let double_count = move || count() * 2;

view! {
    &lt;progress
        max=&quot;50&quot;
        value=count
    /&gt;
    &lt;progress
        max=&quot;50&quot;
        value=double_count
    /&gt;
}</code></pre>
<p>But of course, this doesn’t scale very well. If you want to add a third progress
bar, you need to add this code another time. And if you want to edit anything
about it, you need to edit it in triplicate.</p>
<p>Instead, let’s create a <code>&lt;ProgressBar/&gt;</code> component.</p>
<pre><code class="language-rust">#[component]
fn ProgressBar() -&gt; impl IntoView {
    view! {
        &lt;progress
            max=&quot;50&quot;
            // hmm... where will we get this from?
            value=progress
        /&gt;
    }
}</code></pre>
<p>There’s just one problem: <code>progress</code> is not defined. Where should it come from?
When we were defining everything manually, we just used the local variable names.
Now we need some way to pass an argument into the component.</p>
<h2 id="component-props"><a class="header" href="#component-props">Component Props</a></h2>
<p>We do this using component properties, or “props.” If you’ve used another frontend
framework, this is probably a familiar idea. Basically, properties are to components
as attributes are to HTML elements: they let you pass additional information into
the component.</p>
<p>In Leptos, you define props by giving additional arguments to the component function.</p>
<pre><code class="language-rust">#[component]
fn ProgressBar(
    progress: ReadSignal&lt;i32&gt;
) -&gt; impl IntoView {
    view! {
        &lt;progress
            max=&quot;50&quot;
            // now this works
            value=progress
        /&gt;
    }
}</code></pre>
<p>Now we can use our component in the main <code>&lt;App/&gt;</code> component’s view.</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);
    view! {
        &lt;button on:click=move |_| { set_count.update(|n| *n += 1); }&gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        // now we use our component!
        &lt;ProgressBar progress=count/&gt;
    }
}</code></pre>
<p>Using a component in the view looks a lot like using an HTML element. You’ll
notice that you can easily tell the difference between an element and a component
because components always have <code>PascalCase</code> names. You pass the <code>progress</code> prop
in as if it were an HTML element attribute. Simple.</p>
<h3 id="reactive-and-static-props"><a class="header" href="#reactive-and-static-props">Reactive and Static Props</a></h3>
<p>You’ll notice that throughout this example, <code>progress</code> takes a reactive
<code>ReadSignal&lt;i32&gt;</code>, and not a plain <code>i32</code>. This is <strong>very important</strong>.</p>
<p>Component props have no special meaning attached to them. A component is simply
a function that runs once to set up the user interface. The only way to tell the
interface to respond to changing is to pass it a signal type. So if you have a
component property that will change over time, like our <code>progress</code>, it should
be a signal.</p>
<h3 id="optional-props"><a class="header" href="#optional-props"><code>optional</code> Props</a></h3>
<p>Right now the <code>max</code> setting is hard-coded. Let’s take that as a prop too. But
let’s add a catch: let’s make this prop optional by annotating the particular
argument to the component function with <code>#[prop(optional)]</code>.</p>
<pre><code class="language-rust">#[component]
fn ProgressBar(
    // mark this prop optional
    // you can specify it or not when you use &lt;ProgressBar/&gt;
    #[prop(optional)]
    max: u16,
    progress: ReadSignal&lt;i32&gt;
) -&gt; impl IntoView {
    view! {
        &lt;progress
            max=max
            value=progress
        /&gt;
    }
}</code></pre>
<p>Now, we can use <code>&lt;ProgressBar max=50 value=count/&gt;</code>, or we can omit <code>max</code>
to use the default value (i.e., <code>&lt;ProgressBar value=count/&gt;</code>). The default value
on an <code>optional</code> is its <code>Default::default()</code> value, which for a <code>u16</code> is going to
be <code>0</code>. In the case of a progress bar, a max value of <code>0</code> is not very useful.</p>
<p>So let’s give it a particular default value instead.</p>
<h3 id="default-props"><a class="header" href="#default-props"><code>default</code> props</a></h3>
<p>You can specify a default value other than <code>Default::default()</code> pretty simply
with <code>#[prop(default = ...)</code>.</p>
<pre><code class="language-rust">#[component]
fn ProgressBar(
    #[prop(default = 100)]
    max: u16,
    progress: ReadSignal&lt;i32&gt;
) -&gt; impl IntoView {
    view! {
        &lt;progress
            max=max
            value=progress
        /&gt;
    }
}</code></pre>
<h3 id="generic-props"><a class="header" href="#generic-props">Generic Props</a></h3>
<p>This is great. But we began with two counters, one driven by <code>count</code>, and one by
the derived signal <code>double_count</code>. Let’s recreate that by using <code>double_count</code>
as the <code>progress</code> prop on another <code>&lt;ProgressBar/&gt;</code>.</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);
    let double_count = move || count() * 2;

    view! {
        &lt;button on:click=move |_| { set_count.update(|n| *n += 1); }&gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        &lt;ProgressBar progress=count/&gt;
        // add a second progress bar
        &lt;ProgressBar progress=double_count/&gt;
    }
}</code></pre>
<p>Hm... this won’t compile. It should be pretty easy to understand why: we’ve declared
that the <code>progress</code> prop takes <code>ReadSignal&lt;i32&gt;</code>, and <code>double_count</code> is not
<code>ReadSignal&lt;i32&gt;</code>. As rust-analyzer will tell you, its type is <code>|| -&gt; i32</code>, i.e.,
it’s a closure that returns an <code>i32</code>.</p>
<p>There are a couple ways to handle this. One would be to say: “Well, I know that
a <code>ReadSignal</code> is a function, and I know that a closure is a function; maybe I
could just take any function?” If you’re savvy, you may know that both these
implement the trait <code>Fn() -&gt; i32</code>. So you could use a generic component:</p>
<pre><code class="language-rust">#[component]
fn ProgressBar&lt;F&gt;(
    #[prop(default = 100)]
    max: u16,
    progress: F
) -&gt; impl IntoView
where
    F: Fn() -&gt; i32 + 'static,
{
    view! {
        &lt;progress
            max=max
            value=progress
        /&gt;
    }
}</code></pre>
<p>This is a perfectly reasonable way to write this component: <code>progress</code> now takes
any value that implements this <code>Fn()</code> trait.</p>
<p>This generic can also be specified inline:</p>
<pre><code class="language-rust">#[component]
fn ProgressBar&lt;F: Fn() -&gt; i32 + 'static&gt;(
    #[prop(default = 100)] max: u16,
    progress: F,
) -&gt; impl IntoView {
    view! {
        &lt;progress
            max=max
            value=progress
        /&gt;
    }
}</code></pre>
<blockquote>
<p>Note that generic component props <em>can’t</em> be specified with an <code>impl</code> yet (<code>progress: impl Fn() -&gt; i32 + 'static,</code>), in part because they’re actually used to generate a <code>struct ProgressBarProps</code>, and struct fields cannot be <code>impl</code> types. The <code>#[component]</code> macro may be further improved in the future to allow inline <code>impl</code> generic props.</p>
</blockquote>
<h3 id="into-props"><a class="header" href="#into-props"><code>into</code> Props</a></h3>
<p>There’s one more way we could implement this, and it would be to use <code>#[prop(into)]</code>.
This attribute automatically calls <code>.into()</code> on the values you pass as props,
which allows you to easily pass props with different values.</p>
<p>In this case, it’s helpful to know about the
<a href="https://docs.rs/leptos/latest/leptos/struct.Signal.html"><code>Signal</code></a> type. <code>Signal</code>
is an enumerated type that represents any kind of readable reactive signal. It can
be useful when defining APIs for components you’ll want to reuse while passing
different sorts of signals. The <a href="https://docs.rs/leptos/latest/leptos/enum.MaybeSignal.html"><code>MaybeSignal</code></a> type is useful when you want to be able to take either a static or
reactive value.</p>
<pre><code class="language-rust">#[component]
fn ProgressBar(
    #[prop(default = 100)]
    max: u16,
    #[prop(into)]
    progress: Signal&lt;i32&gt;
) -&gt; impl IntoView
{
    view! {
        &lt;progress
            max=max
            value=progress
        /&gt;
    }
}

#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);
    let double_count = move || count() * 2;

    view! {
        &lt;button on:click=move |_| { set_count.update(|n| *n += 1); }&gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        // .into() converts `ReadSignal` to `Signal`
        &lt;ProgressBar progress=count/&gt;
        // use `Signal::derive()` to wrap a derived signal
        &lt;ProgressBar progress=Signal::derive(double_count)/&gt;
    }
}</code></pre>
<h3 id="optional-generic-props"><a class="header" href="#optional-generic-props">Optional Generic Props</a></h3>
<p>Note that you can’t specify optional generic props for a component. Let’s see what would happen if you try:</p>
<pre><code class="language-rust compile_fail">#[component]
fn ProgressBar&lt;F: Fn() -&gt; i32 + 'static&gt;(
    #[prop(optional)] progress: Option&lt;F&gt;,
) -&gt; impl IntoView {
    progress.map(|progress| {
        view! {
            &lt;progress
                max=100
                value=progress
            /&gt;
        }
    })
}

#[component]
pub fn App() -&gt; impl IntoView {
    view! {
        &lt;ProgressBar/&gt;
    }
}</code></pre>
<p>Rust helpfully gives the error</p>
<pre><code>xx |         &lt;ProgressBar/&gt;
   |          ^^^^^^^^^^^ cannot infer type of the type parameter `F` declared on the function `ProgressBar`
   |
help: consider specifying the generic argument
   |
xx |         &lt;ProgressBar::&lt;F&gt;/&gt;
   |                     +++++
</code></pre>
<p>There are just two problems:</p>
<ol>
<li>Leptos’s view macro doesn’t support specifying a generic on a component with this turbofish syntax.</li>
<li>Even if you could, specifying the correct type here is not possible; closures and functions in general are unnameable types. The compiler can display them with a shorthand, but you can’t specify them.</li>
</ol>
<p>However, you can get around this by providing a concrete type using <code>Box&lt;dyn _&gt;</code> or <code>&amp;dyn _</code>:</p>
<pre><code class="language-rust">#[component]
fn ProgressBar(
    #[prop(optional)] progress: Option&lt;Box&lt;dyn Fn() -&gt; i32&gt;&gt;,
) -&gt; impl IntoView {
    progress.map(|progress| {
        view! {
            &lt;progress
                max=100
                value=progress
            /&gt;
        }
    })
}

#[component]
pub fn App() -&gt; impl IntoView {
    view! {
        &lt;ProgressBar/&gt;
    }
}</code></pre>
<p>Because the Rust compiler now knows the concrete type of the prop, and therefore its size in memory even in the <code>None</code> case, this compiles fine.</p>
<blockquote>
<p>In this particular case, <code>&amp;dyn Fn() -&gt; i32</code> will cause lifetime issues, but in other cases, it may be a possibility.</p>
</blockquote>
<h2 id="documenting-components"><a class="header" href="#documenting-components">Documenting Components</a></h2>
<p>This is one of the least essential but most important sections of this book.
It’s not strictly necessary to document your components and their props. It may
be very important, depending on the size of your team and your app. But it’s very
easy, and bears immediate fruit.</p>
<p>To document a component and its props, you can simply add doc comments on the
component function, and each one of the props:</p>
<pre><code class="language-rust">/// Shows progress toward a goal.
#[component]
fn ProgressBar(
    /// The maximum value of the progress bar.
    #[prop(default = 100)]
    max: u16,
    /// How much progress should be displayed.
    #[prop(into)]
    progress: Signal&lt;i32&gt;,
) -&gt; impl IntoView {
    /* ... */
}</code></pre>
<p>That’s all you need to do. These behave like ordinary Rust doc comments, except
that you can document individual component props, which can’t be done with Rust
function arguments.</p>
<p>This will automatically generate documentation for your component, its <code>Props</code>
type, and each of the fields used to add props. It can be a little hard to
understand how powerful this is until you hover over the component name or props
and see the power of the <code>#[component]</code> macro combined with rust-analyzer here.</p>
<blockquote>
<h4 id="advanced-topic-componenttransparent"><a class="header" href="#advanced-topic-componenttransparent">Advanced Topic: <code>#[component(transparent)]</code></a></h4>
<p>All Leptos components return <code>-&gt; impl IntoView</code>. Some, though, need to return
some data directly without any additional wrapping. These can be marked with
<code>#[component(transparent)]</code>, in which case they return exactly the value they
return, without the rendering system transforming them in any way.</p>
<p>This is mostly used in two situations:</p>
<ol>
<li>Creating wrappers around <code>&lt;Suspense/&gt;</code> or <code>&lt;Transition/&gt;</code>, which return a
transparent suspense structure to integrate with SSR and hydration properly.</li>
<li>Refactoring <code>&lt;Route/&gt;</code> definitions for <code>leptos_router</code> out into separate
components, because <code>&lt;Route/&gt;</code> is a transparent component that returns a
<code>RouteDefinition</code> struct rather than a view.</li>
</ol>
<p>In general, you should not need to use transparent components unless you are
creating custom wrapping components that fall into one of these two categories.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/3-components-0-5-5vvl69?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/3-components-0-5-5vvl69?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

// Composing different components together is how we build
// user interfaces. Here, we'll define a resuable &lt;ProgressBar/&gt;.
// You'll see how doc comments can be used to document components
// and their properties.

/// Shows progress toward a goal.
#[component]
fn ProgressBar(
    // Marks this as an optional prop. It will default to the default
    // value of its type, i.e., 0.
    #[prop(default = 100)]
    /// The maximum value of the progress bar.
    max: u16,
    // Will run `.into()` on the value passed into the prop.
    #[prop(into)]
    // `Signal&lt;T&gt;` is a wrapper for several reactive types.
    // It can be helpful in component APIs like this, where we
    // might want to take any kind of reactive value
    /// How much progress should be displayed.
    progress: Signal&lt;i32&gt;,
) -&gt; impl IntoView {
    view! {
        &lt;progress
            max={max}
            value=progress
        /&gt;
        &lt;br/&gt;
    }
}

#[component]
fn App() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    let double_count = move || count() * 2;

    view! {
        &lt;button
            on:click=move |_| {
                set_count.update(|n| *n += 1);
            }
        &gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        &lt;br/&gt;
        // If you have this open in CodeSandbox or an editor with
        // rust-analyzer support, try hovering over `ProgressBar`,
        // `max`, or `progress` to see the docs we defined above
        &lt;ProgressBar max=50 progress=count/&gt;
        // Let's use the default max value on this one
        // the default is 100, so it should move half as fast
        &lt;ProgressBar progress=count/&gt;
        // Signal::derive creates a Signal wrapper from our derived signal
        // using double_count means it should move twice as fast
        &lt;ProgressBar max=50 progress=Signal::derive(double_count)/&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration"><a class="header" href="#iteration">Iteration</a></h1>
<p>Whether you’re listing todos, displaying a table, or showing product images,
iterating over a list of items is a common task in web applications. Reconciling
the differences between changing sets of items can also be one of the trickiest
tasks for a framework to handle well.</p>
<p>Leptos supports two different patterns for iterating over items:</p>
<ol>
<li>For static views: <code>Vec&lt;_&gt;</code></li>
<li>For dynamic lists: <code>&lt;For/&gt;</code></li>
</ol>
<h2 id="static-views-with-vec_"><a class="header" href="#static-views-with-vec_">Static Views with <code>Vec&lt;_&gt;</code></a></h2>
<p>Sometimes you need to show an item repeatedly, but the list you’re drawing from
does not often change. In this case, it’s important to know that you can insert
any <code>Vec&lt;IV&gt; where IV: IntoView</code> into your view. In other words, if you can render
<code>T</code>, you can render <code>Vec&lt;T&gt;</code>.</p>
<pre><code class="language-rust">let values = vec![0, 1, 2];
view! {
    // this will just render &quot;012&quot;
    &lt;p&gt;{values.clone()}&lt;/p&gt;
    // or we can wrap them in &lt;li&gt;
    &lt;ul&gt;
        {values.into_iter()
            .map(|n| view! { &lt;li&gt;{n}&lt;/li&gt;})
            .collect::&lt;Vec&lt;_&gt;&gt;()}
    &lt;/ul&gt;
}</code></pre>
<p>Leptos also provides a <code>.collect_view()</code> helper function that allows you to collect any iterator of <code>T: IntoView</code> into <code>Vec&lt;View&gt;</code>.</p>
<pre><code class="language-rust">let values = vec![0, 1, 2];
view! {
    // this will just render &quot;012&quot;
    &lt;p&gt;{values.clone()}&lt;/p&gt;
    // or we can wrap them in &lt;li&gt;
    &lt;ul&gt;
        {values.into_iter()
            .map(|n| view! { &lt;li&gt;{n}&lt;/li&gt;})
            .collect_view()}
    &lt;/ul&gt;
}</code></pre>
<p>The fact that the <em>list</em> is static doesn’t mean the interface needs to be static.
You can render dynamic items as part of a static list.</p>
<pre><code class="language-rust">// create a list of 5 signals
let length = 5;
let counters = (1..=length).map(|idx| create_signal(idx));

// each item manages a reactive view
// but the list itself will never change
let counter_buttons = counters
    .map(|(count, set_count)| {
        view! {
            &lt;li&gt;
                &lt;button
                    on:click=move |_| set_count.update(|n| *n += 1)
                &gt;
                    {count}
                &lt;/button&gt;
            &lt;/li&gt;
        }
    })
    .collect_view();

view! {
    &lt;ul&gt;{counter_buttons}&lt;/ul&gt;
}</code></pre>
<p>You <em>can</em> render a <code>Fn() -&gt; Vec&lt;_&gt;</code> reactively as well. But note that every time
it changes, this will rerender every item in the list. This is quite inefficient!
Fortunately, there’s a better way.</p>
<h2 id="dynamic-rendering-with-the-for-component"><a class="header" href="#dynamic-rendering-with-the-for-component">Dynamic Rendering with the <code>&lt;For/&gt;</code> Component</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/fn.For.html"><code>&lt;For/&gt;</code></a> component is a
keyed dynamic list. It takes three props:</p>
<ul>
<li><code>each</code>: a function (such as a signal) that returns the items <code>T</code> to be iterated over</li>
<li><code>key</code>: a key function that takes <code>&amp;T</code> and returns a stable, unique key or ID</li>
<li><code>children</code>: renders each <code>T</code> into a view</li>
</ul>
<p><code>key</code> is, well, the key. You can add, remove, and move items within the list. As
long as each item’s key is stable over time, the framework does not need to rerender
any of the items, unless they are new additions, and it can very efficiently add,
remove, and move items as they change. This allows for extremely efficient updates
to the list as it changes, with minimal additional work.</p>
<p>Creating a good <code>key</code> can be a little tricky. You generally do <em>not</em> want to use
an index for this purpose, as it is not stable—if you remove or move items, their
indices change.</p>
<p>But it’s a great idea to do something like generating a unique ID for each row as
it is generated, and using that as an ID for the key function.</p>
<p>Check out the <code>&lt;DynamicList/&gt;</code> component below for an example.</p>
<p><a href="https://codesandbox.io/p/sandbox/4-iteration-0-5-pwdn2y?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/4-iteration-0-5-pwdn2y?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

// Iteration is a very common task in most applications.
// So how do you take a list of data and render it in the DOM?
// This example will show you the two ways:
// 1) for mostly-static lists, using Rust iterators
// 2) for lists that grow, shrink, or move items, using &lt;For/&gt;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;h1&gt;&quot;Iteration&quot;&lt;/h1&gt;
        &lt;h2&gt;&quot;Static List&quot;&lt;/h2&gt;
        &lt;p&gt;&quot;Use this pattern if the list itself is static.&quot;&lt;/p&gt;
        &lt;StaticList length=5/&gt;
        &lt;h2&gt;&quot;Dynamic List&quot;&lt;/h2&gt;
        &lt;p&gt;&quot;Use this pattern if the rows in your list will change.&quot;&lt;/p&gt;
        &lt;DynamicList initial_length=5/&gt;
    }
}

/// A list of counters, without the ability
/// to add or remove any.
#[component]
fn StaticList(
    /// How many counters to include in this list.
    length: usize,
) -&gt; impl IntoView {
    // create counter signals that start at incrementing numbers
    let counters = (1..=length).map(|idx| create_signal(idx));

    // when you have a list that doesn't change, you can
    // manipulate it using ordinary Rust iterators
    // and collect it into a Vec&lt;_&gt; to insert it into the DOM
    let counter_buttons = counters
        .map(|(count, set_count)| {
            view! {
                &lt;li&gt;
                    &lt;button
                        on:click=move |_| set_count.update(|n| *n += 1)
                    &gt;
                        {count}
                    &lt;/button&gt;
                &lt;/li&gt;
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Note that if `counter_buttons` were a reactive list
    // and its value changed, this would be very inefficient:
    // it would rerender every row every time the list changed.
    view! {
        &lt;ul&gt;{counter_buttons}&lt;/ul&gt;
    }
}

/// A list of counters that allows you to add or
/// remove counters.
#[component]
fn DynamicList(
    /// The number of counters to begin with.
    initial_length: usize,
) -&gt; impl IntoView {
    // This dynamic list will use the &lt;For/&gt; component.
    // &lt;For/&gt; is a keyed list. This means that each row
    // has a defined key. If the key does not change, the row
    // will not be re-rendered. When the list changes, only
    // the minimum number of changes will be made to the DOM.

    // `next_counter_id` will let us generate unique IDs
    // we do this by simply incrementing the ID by one
    // each time we create a counter
    let mut next_counter_id = initial_length;

    // we generate an initial list as in &lt;StaticList/&gt;
    // but this time we include the ID along with the signal
    let initial_counters = (0..initial_length)
        .map(|id| (id, create_signal(id + 1)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // now we store that initial list in a signal
    // this way, we'll be able to modify the list over time,
    // adding and removing counters, and it will change reactively
    let (counters, set_counters) = create_signal(initial_counters);

    let add_counter = move |_| {
        // create a signal for the new counter
        let sig = create_signal(next_counter_id + 1);
        // add this counter to the list of counters
        set_counters.update(move |counters| {
            // since `.update()` gives us `&amp;mut T`
            // we can just use normal Vec methods like `push`
            counters.push((next_counter_id, sig))
        });
        // increment the ID so it's always unique
        next_counter_id += 1;
    };

    view! {
        &lt;div&gt;
            &lt;button on:click=add_counter&gt;
                &quot;Add Counter&quot;
            &lt;/button&gt;
            &lt;ul&gt;
                // The &lt;For/&gt; component is central here
                // This allows for efficient, key list rendering
                &lt;For
                    // `each` takes any function that returns an iterator
                    // this should usually be a signal or derived signal
                    // if it's not reactive, just render a Vec&lt;_&gt; instead of &lt;For/&gt;
                    each=counters
                    // the key should be unique and stable for each row
                    // using an index is usually a bad idea, unless your list
                    // can only grow, because moving items around inside the list
                    // means their indices will change and they will all rerender
                    key=|counter| counter.0
                    // `children` receives each item from your `each` iterator
                    // and returns a view
                    children=move |(id, (count, set_count))| {
                        view! {
                            &lt;li&gt;
                                &lt;button
                                    on:click=move |_| set_count.update(|n| *n += 1)
                                &gt;
                                    {count}
                                &lt;/button&gt;
                                &lt;button
                                    on:click=move |_| {
                                        set_counters.update(|counters| {
                                            counters.retain(|(counter_id, _)| counter_id != &amp;id)
                                        });
                                    }
                                &gt;
                                    &quot;Remove&quot;
                                &lt;/button&gt;
                            &lt;/li&gt;
                        }
                    }
                /&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterating-over-more-complex-data-with-for"><a class="header" href="#iterating-over-more-complex-data-with-for">Iterating over More Complex Data with <code>&lt;For/&gt;</code></a></h1>
<p>This chapter goes into iteration over nested data structures in a bit
more depth. It belongs here with the other chapter on iteration, but feel
free to skip it and come back if you’d like to stick with simpler subjects
for now.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>I just said that the framework does not rerender any of the items in one of the
rows, unless the key has changed. This probably makes sense at first, but it can
easily trip you up.</p>
<p>Let’s consider an example in which each of the items in our row is some data structure.
Imagine, for example, that the items come from some JSON array of keys and values:</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
struct DatabaseEntry {
    key: String,
    value: i32,
}</code></pre>
<p>Let’s define a simple component that will iterate over the rows and display each one:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
	// start with a set of three rows
    let (data, set_data) = create_signal(vec![
        DatabaseEntry {
            key: &quot;foo&quot;.to_string(),
            value: 10,
        },
        DatabaseEntry {
            key: &quot;bar&quot;.to_string(),
            value: 20,
        },
        DatabaseEntry {
            key: &quot;baz&quot;.to_string(),
            value: 15,
        },
    ]);
    view! {
		// when we click, update each row,
		// doubling its value
        &lt;button on:click=move |_| {
            set_data.update(|data| {
                for row in data {
                    row.value *= 2;
                }
            });
			// log the new value of the signal
            logging::log!(&quot;{:?}&quot;, data.get());
        }&gt;
            &quot;Update Values&quot;
        &lt;/button&gt;
		// iterate over the rows and display each value
        &lt;For
            each=data
            key=|state| state.key.clone()
            let:child
        &gt;
            &lt;p&gt;{child.value}&lt;/p&gt;
        &lt;/For&gt;
    }
}</code></pre>
<blockquote>
<p>Note the <code>let:child</code> syntax here. In the previous chapter we introduced <code>&lt;For/&gt;</code>
with a <code>children</code> prop. We can actually create this value directly in the children
of the <code>&lt;For/&gt;</code> component, without breaking out of the <code>view</code> macro: the <code>let:child</code>
combined with <code>&lt;p&gt;{child.value}&lt;/p&gt;</code> above is the equivalent of</p>
<pre><code class="language-rust">children=|child| view! { &lt;p&gt;{child.value}&lt;/p&gt; }</code></pre>
</blockquote>
<p>When you click the <code>Update Values</code> button... nothing happens. Or rather:
the signal is updated, the new value is logged, but the <code>{child.value}</code>
for each row doesn’t update.</p>
<p>Let’s see: is that because we forgot to add a closure to make it reactive?
Let’s try <code>{move || child.value}</code>.</p>
<p>...Nope. Still nothing.</p>
<p>Here’s the problem: as I said, each row is only rerendered when the key changes.
We’ve updated the value for each row, but not the key for any of the rows, so
nothing has rerendered. And if you look at the type of <code>child.value</code>, it’s a plain
<code>i32</code>, not a reactive <code>ReadSignal&lt;i32&gt;</code> or something. This means that even if we
wrap a closure around it, the value in this row will never update.</p>
<p>We have three possible solutions:</p>
<ol>
<li>change the <code>key</code> so that it always updates when the data structure changes</li>
<li>change the <code>value</code> so that it’s reactive</li>
<li>take a reactive slice of the data structure instead of using each row directly</li>
</ol>
<h2 id="option-1-change-the-key"><a class="header" href="#option-1-change-the-key">Option 1: Change the Key</a></h2>
<p>Each row is only rerendered when the key changes. Our rows above didn’t rerender,
because the key didn’t change. So: why not just force the key to change?</p>
<pre><code class="language-rust">&lt;For
	each=data
	key=|state| (state.key.clone(), state.value)
	let:child
&gt;
	&lt;p&gt;{child.value}&lt;/p&gt;
&lt;/For&gt;</code></pre>
<p>Now we include both the key and the value in the <code>key</code>. This means that whenever the
value of a row changes, <code>&lt;For/&gt;</code> will treat it as if it’s an entirely new row, and
replace the previous one.</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>This is very easy. We can make it even easier by deriving <code>PartialEq</code>, <code>Eq</code>, and <code>Hash</code>
on <code>DatabaseEntry</code>, in which case we could just <code>key=|state| state.clone()</code>.</p>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p><strong>This is the least efficient of the three options.</strong> Every time the value of a row
changes, it throws out the previous <code>&lt;p&gt;</code> element and replaces it with an entirely new
one. Rather than making a fine-grained update to the text node, in other words, it really
does rerender the entire row on every change, and this is expensive in proportion to how
complex the UI of the row is.</p>
<p>You’ll notice we also end up cloning the whole data structure so that <code>&lt;For/&gt;</code> can hold
onto a copy of the key. For more complex structures, this can become a bad idea fast!</p>
<h2 id="option-2-nested-signals"><a class="header" href="#option-2-nested-signals">Option 2: Nested Signals</a></h2>
<p>If we do want that fine-grained reactivity for the value, one option is to wrap the <code>value</code>
of each row in a signal.</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
struct DatabaseEntry {
    key: String,
    value: RwSignal&lt;i32&gt;,
}</code></pre>
<p><code>RwSignal&lt;_&gt;</code> is a “read-write signal,” which combines the getter and setter in one object.
I’m using it here because it’s a little easier to store in a struct than separate getters
and setters.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
	// start with a set of three rows
    let (data, set_data) = create_signal(vec![
        DatabaseEntry {
            key: &quot;foo&quot;.to_string(),
            value: create_rw_signal(10),
        },
        DatabaseEntry {
            key: &quot;bar&quot;.to_string(),
            value: create_rw_signal(20),
        },
        DatabaseEntry {
            key: &quot;baz&quot;.to_string(),
            value: create_rw_signal(15),
        },
    ]);
    view! {
		// when we click, update each row,
		// doubling its value
        &lt;button on:click=move |_| {
            data.with(|data| {
                for row in data {
                    row.value.update(|value| *value *= 2);
                }
            });
			// log the new value of the signal
            logging::log!(&quot;{:?}&quot;, data.get());
        }&gt;
            &quot;Update Values&quot;
        &lt;/button&gt;
		// iterate over the rows and display each value
        &lt;For
            each=data
            key=|state| state.key.clone()
            let:child
        &gt;
            &lt;p&gt;{child.value}&lt;/p&gt;
        &lt;/For&gt;
    }
}</code></pre>
<p>This version works! And if you look in the DOM inspector in your browser, you’ll
see that unlike in the previous version, in this version only the individual text
nodes are updated. Passing the signal directly into <code>{child.value}</code> works, as
signals do keep their reactivity if you pass them into the view.</p>
<p>Note that I changed the <code>set_data.update()</code> to a <code>data.with()</code>. <code>.with()</code> is the
non-cloning way of accessing a signal’s value. In this case, we are only updating
the internal values, not updating the list of values: because signals maintain their
own state, we don’t actually need to update the <code>data</code> signal at all, so the immutable
<code>.with()</code> is fine here.</p>
<blockquote>
<p>In fact, this version doesn’t update <code>data</code>, so the <code>&lt;For/&gt;</code> is essentially a static
list as in the last chapter, and this could just be a plain iterator. But the <code>&lt;For/&gt;</code>
is useful if we want to add or remove rows in the future.</p>
</blockquote>
<h3 id="pros-1"><a class="header" href="#pros-1">Pros</a></h3>
<p>This is the most efficient option, and fits directly with the rest of the mental model
of the framework: values that change over time are wrapped in signals so the interface
can respond to them.</p>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons</a></h3>
<p>Nested reactivity can be cumbersome if you’re receiving data from an API or another
data source you don’t control, and you don’t want to create a different struct wrapping
each field in a signal.</p>
<h2 id="option-3-memoized-slices"><a class="header" href="#option-3-memoized-slices">Option 3: Memoized Slices</a></h2>
<p>Leptos provides a primitive called <a href="https://docs.rs/leptos/latest/leptos/fn.create_memo.html"><code>create_memo</code></a>,
which creates a derived computation that only triggers a reactive update when its value
has changed.</p>
<p>This allows you to create reactive values for subfields of a larger data structure,
without needing to wrap the fields of that structure in signals.</p>
<p>Most of the application can remain the same as the initial (broken) version, but the <code>&lt;For/&gt;</code>
will be updated to this:</p>
<pre><code class="language-rust">&lt;For
    each=move || data().into_iter().enumerate()
    key=|(_, state)| state.key.clone()
    children=move |(index, _)| {
        let value = create_memo(move |_| {
            data.with(|data| data.get(index).map(|d| d.value).unwrap_or(0))
        });
        view! {
            &lt;p&gt;{value}&lt;/p&gt;
        }
    }
/&gt;</code></pre>
<p>You’ll notice a few differences here:</p>
<ul>
<li>we convert the <code>data</code> signal into an enumerated iterator</li>
<li>we use the <code>children</code> prop explicitly, to make it easier to run some non-<code>view</code> code</li>
<li>we define a <code>value</code> memo and use that in the view. This <code>value</code> field doesn’t actually
use the <code>child</code> being passed into each row. Instead, it uses the index and reaches back
into the original <code>data</code> to get the value.</li>
</ul>
<p>Every time <code>data</code> changes, now, each memo will be recalculated. If its value has changed,
it will update its text node, without rerendering the whole row.</p>
<h3 id="pros-2"><a class="header" href="#pros-2">Pros</a></h3>
<p>We get the same fine-grained reactivity of the signal-wrapped version, without needing to
wrap the data in signals.</p>
<h3 id="cons-2"><a class="header" href="#cons-2">Cons</a></h3>
<p>It’s a bit more complex to set up this memo-per-row inside the <code>&lt;For/&gt;</code> loop rather than
using nested signals. For example, you’ll notice that we have to guard against the possibility
that the <code>data[index]</code> would panic by using <code>data.get(index)</code>, because this memo may be 
triggered to re-run once just after the row is removed. (This is because the memo for each row
and the whole <code>&lt;For/&gt;</code> both depend on the same <code>data</code> signal, and the order of execution for
multiple reactive values that depend on the same signal isn’t guaranteed.)</p>
<p>Note also that while memos memoize their reactive changes, the same
calculation does need to re-run to check the value every time, so nested reactive signals
will still be more efficient for pinpoint updates here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forms-and-inputs"><a class="header" href="#forms-and-inputs">Forms and Inputs</a></h1>
<p>Forms and form inputs are an important part of interactive apps. There are two
basic patterns for interacting with inputs in Leptos, which you may recognize
if you’re familiar with React, SolidJS, or a similar framework: using <strong>controlled</strong>
or <strong>uncontrolled</strong> inputs.</p>
<h2 id="controlled-inputs"><a class="header" href="#controlled-inputs">Controlled Inputs</a></h2>
<p>In a &quot;controlled input,&quot; the framework controls the state of the input
element. On every <code>input</code> event, it updates a local signal that holds the current
state, which in turn updates the <code>value</code> prop of the input.</p>
<p>There are two important things to remember:</p>
<ol>
<li>The <code>input</code> event fires on (almost) every change to the element, while the
<code>change</code> event fires (more or less) when you unfocus the input. You probably
want <code>on:input</code>, but we give you the freedom to choose.</li>
<li>The <code>value</code> <em>attribute</em> only sets the initial value of the input, i.e., it
only updates the input up to the point that you begin typing. The <code>value</code>
<em>property</em> continues updating the input after that. You usually want to set
<code>prop:value</code> for this reason. (The same is true for <code>checked</code> and <code>prop:checked</code>
on an <code>&lt;input type=&quot;checkbox&quot;&gt;</code>.)</li>
</ol>
<pre><code class="language-rust">let (name, set_name) = create_signal(&quot;Controlled&quot;.to_string());

view! {
    &lt;input type=&quot;text&quot;
        on:input=move |ev| {
            // event_target_value is a Leptos helper function
            // it functions the same way as event.target.value
            // in JavaScript, but smooths out some of the typecasting
            // necessary to make this work in Rust
            set_name(event_target_value(&amp;ev));
        }

        // the `prop:` syntax lets you update a DOM property,
        // rather than an attribute.
        prop:value=name
    /&gt;
    &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
}</code></pre>
<blockquote>
<h4 id="why-do-you-need-propvalue"><a class="header" href="#why-do-you-need-propvalue">Why do you need <code>prop:value</code>?</a></h4>
<p>Web browsers are the most ubiquitous and stable platform for rendering graphical user interfaces in existence. They have also maintained an incredible backwards compatibility over their three decades of existence. Inevitably, this means there are some quirks.</p>
<p>One odd quirk is that there is a distinction between HTML attributes and DOM element properties, i.e., between something called an “attribute” which is parsed from HTML and can be set on a DOM element with <code>.setAttribute()</code>, and something called a “property” which is a field of the JavaScript class representation of that parsed HTML element.</p>
<p>In the case of an <code>&lt;input value=...&gt;</code>, setting the <code>value</code> <em>attribute</em> is defined as setting the initial value for the input, and setting <code>value</code> <em>property</em> sets its current value. It maybe easiest to understand this by opening <code>about:blank</code> and running the following JavaScript in the browser console, line by line:</p>
<pre><code class="language-js">// create an input and append it to the DOM
const el = document.createElement(&quot;input&quot;);
document.body.appendChild(el);

el.setAttribute(&quot;value&quot;, &quot;test&quot;); // updates the input
el.setAttribute(&quot;value&quot;, &quot;another test&quot;); // updates the input again

// now go and type into the input: delete some characters, etc.

el.setAttribute(&quot;value&quot;, &quot;one more time?&quot;);
// nothing should have changed. setting the &quot;initial value&quot; does nothing now

// however...
el.value = &quot;But this works&quot;;
</code></pre>
<p>Many other frontend frameworks conflate attributes and properties, or create a special case for inputs that sets the value correctly. Maybe Leptos should do this too; but for now, I prefer giving users the maximum amount of control over whether they’re setting an attribute or a property, and doing my best to educate people about the actual underlying browser behavior rather than obscuring it.</p>
</blockquote>
<h2 id="uncontrolled-inputs"><a class="header" href="#uncontrolled-inputs">Uncontrolled Inputs</a></h2>
<p>In an &quot;uncontrolled input,&quot; the browser controls the state of the input element.
Rather than continuously updating a signal to hold its value, we use a
<a href="https://docs.rs/leptos/latest/leptos/struct.NodeRef.html"><code>NodeRef</code></a> to access
the input once when we want to get its value.</p>
<p>In this example, we only notify the framework when the <code>&lt;form&gt;</code> fires a <code>submit</code>
event.</p>
<pre><code class="language-rust">let (name, set_name) = create_signal(&quot;Uncontrolled&quot;.to_string());

let input_element: NodeRef&lt;Input&gt; = create_node_ref();</code></pre>
<p><code>NodeRef</code> is a kind of reactive smart pointer: we can use it to access the
underlying DOM node. Its value will be set when the element is rendered.</p>
<pre><code class="language-rust">let on_submit = move |ev: SubmitEvent| {
    // stop the page from reloading!
    ev.prevent_default();

    // here, we'll extract the value from the input
    let value = input_element()
        // event handlers can only fire after the view
        // is mounted to the DOM, so the `NodeRef` will be `Some`
        .expect(&quot;&lt;input&gt; to exist&quot;)
        // `NodeRef` implements `Deref` for the DOM element type
        // this means we can call`HtmlInputElement::value()`
        // to get the current value of the input
        .value();
    set_name(value);
};</code></pre>
<p>Our <code>on_submit</code> handler will access the input’s value and use it to call <code>set_name</code>.
To access the DOM node stored in the <code>NodeRef</code>, we can simply call it as a function
(or using <code>.get()</code>). This will return <code>Option&lt;web_sys::HtmlInputElement&gt;</code>, but we
know it will already have been filled when we rendered the view, so it’s safe to
unwrap here.</p>
<p>We can then call <code>.value()</code> to get the value out of the input, because <code>NodeRef</code>
gives us access to a correctly-typed HTML element.</p>
<pre><code class="language-rust">view! {
    &lt;form on:submit=on_submit&gt;
        &lt;input type=&quot;text&quot;
            value=name
            node_ref=input_element
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
    &lt;/form&gt;
    &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
}</code></pre>
<p>The view should be pretty self-explanatory by now. Note two things:</p>
<ol>
<li>Unlike in the controlled input example, we use <code>value</code> (not <code>prop:value</code>).
This is because we’re just setting the initial value of the input, and letting
the browser control its state. (We could use <code>prop:value</code> instead.)</li>
<li>We use <code>node_ref</code> to fill the <code>NodeRef</code>. (Older examples sometimes use <code>_ref</code>.
They are the same thing, but <code>node_ref</code> has better rust-analyzer support.)</li>
</ol>
<h2 id="special-cases-textarea-and-select"><a class="header" href="#special-cases-textarea-and-select">Special Cases: <code>&lt;textarea&gt;</code> and <code>&lt;select&gt;</code></a></h2>
<p>Two form elements tend to cause some confusion, in different ways.</p>
<h3 id="textarea"><a class="header" href="#textarea"><code>&lt;textarea&gt;</code></a></h3>
<p>Unlike <code>&lt;input&gt;</code>, the <code>&lt;textarea&gt;</code> element does not support a <code>value</code> attribute.
Instead, it receives its value as a plain text node in its HTML children,</p>
<p>In the current version of Leptos (in fact in Leptos 0.1-0.5), creating a dynamic child
inserts a comment marker node. This can cause incorrect <code>&lt;textarea&gt;</code> rendering (and issues
during hydration) if you try to use it to show dynamic content.</p>
<p>Instead, you can pass a non-reactive initial value as a child, and use <code>prop:value</code> to
set its current value. (<code>&lt;textarea&gt;</code> doesn’t support the <code>value</code> attribut, but <em>does</em>
support the <code>value</code> property...)</p>
<pre><code class="language-rust">view! {
    &lt;textarea
        prop:value=move || some_value.get()
        on:input=/* etc */
    &gt;
        /* untracked, plain-text initial value */
        {untrack(move || some_value.get())}
    &lt;/textarea&gt;
}</code></pre>
<h3 id="select"><a class="header" href="#select"><code>&lt;select&gt;</code></a></h3>
<p>The <code>&lt;select&gt;</code> element also does not have a <code>value</code> attribute, <em>or</em> a <code>value</code> property.
Instead, its value is determined by the <code>selected</code> attribute of its <code>&lt;option&gt;</code>
fields. Some frameworks obscure this with a <code>value</code> field on <code>&lt;select&gt;</code>; if you try this
in Leptos (or vanilla JavaScript) it won’t work.</p>
<p>Instead, use the <code>selected</code> field:</p>
<pre><code class="language-rust">view! {
    &lt;select&gt;
        &lt;option selected=move || count.get() == 0&gt;&quot;0&quot;&lt;/option&gt;
        &lt;option selected=move || count.get() == 1&gt;&quot;1&quot;&lt;/option&gt;
        &lt;option selected=move || count.get() == 2&gt;&quot;2&quot;&lt;/option&gt;
    &lt;/select&gt;
}</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/5-forms-0-5-rf2t7c?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/5-forms-0-5-rf2t7c?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::{ev::SubmitEvent, *};

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;h2&gt;&quot;Controlled Component&quot;&lt;/h2&gt;
        &lt;ControlledComponent/&gt;
        &lt;h2&gt;&quot;Uncontrolled Component&quot;&lt;/h2&gt;
        &lt;UncontrolledComponent/&gt;
    }
}

#[component]
fn ControlledComponent() -&gt; impl IntoView {
    // create a signal to hold the value
    let (name, set_name) = create_signal(&quot;Controlled&quot;.to_string());

    view! {
        &lt;input type=&quot;text&quot;
            // fire an event whenever the input changes
            on:input=move |ev| {
                // event_target_value is a Leptos helper function
                // it functions the same way as event.target.value
                // in JavaScript, but smooths out some of the typecasting
                // necessary to make this work in Rust
                set_name(event_target_value(&amp;ev));
            }

            // the `prop:` syntax lets you update a DOM property,
            // rather than an attribute.
            //
            // IMPORTANT: the `value` *attribute* only sets the
            // initial value, until you have made a change.
            // The `value` *property* sets the current value.
            // This is a quirk of the DOM; I didn't invent it.
            // Other frameworks gloss this over; I think it's
            // more important to give you access to the browser
            // as it really works.
            //
            // tl;dr: use prop:value for form inputs
            prop:value=name
        /&gt;
        &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
    }
}

#[component]
fn UncontrolledComponent() -&gt; impl IntoView {
    // import the type for &lt;input&gt;
    use leptos::html::Input;

    let (name, set_name) = create_signal(&quot;Uncontrolled&quot;.to_string());

    // we'll use a NodeRef to store a reference to the input element
    // this will be filled when the element is created
    let input_element: NodeRef&lt;Input&gt; = create_node_ref();

    // fires when the form `submit` event happens
    // this will store the value of the &lt;input&gt; in our signal
    let on_submit = move |ev: SubmitEvent| {
        // stop the page from reloading!
        ev.prevent_default();

        // here, we'll extract the value from the input
        let value = input_element()
            // event handlers can only fire after the view
            // is mounted to the DOM, so the `NodeRef` will be `Some`
            .expect(&quot;&lt;input&gt; to exist&quot;)
            // `NodeRef` implements `Deref` for the DOM element type
            // this means we can call`HtmlInputElement::value()`
            // to get the current value of the input
            .value();
        set_name(value);
    };

    view! {
        &lt;form on:submit=on_submit&gt;
            &lt;input type=&quot;text&quot;
                // here, we use the `value` *attribute* to set only
                // the initial value, letting the browser maintain
                // the state after that
                value=name

                // store a reference to this input in `input_element`
                node_ref=input_element
            /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
        &lt;/form&gt;
        &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
    }
}

// This `main` function is the entry point into the app
// It just mounts our component to the &lt;body&gt;
// Because we defined it as `fn App`, we can now use it in a
// template as &lt;App/&gt;
fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>In most applications, you sometimes need to make a decision: Should I render this
part of the view, or not? Should I render <code>&lt;ButtonA/&gt;</code> or <code>&lt;WidgetB/&gt;</code>? This is
<strong>control flow</strong>.</p>
<h2 id="a-few-tips"><a class="header" href="#a-few-tips">A Few Tips</a></h2>
<p>When thinking about how to do this with Leptos, it’s important to remember a few
things:</p>
<ol>
<li>Rust is an expression-oriented language: control-flow expressions like
<code>if x() { y } else { z }</code> and <code>match x() { ... }</code> return their values. This
makes them very useful for declarative user interfaces.</li>
<li>For any <code>T</code> that implements <code>IntoView</code>—in other words, for any type that Leptos
knows how to render—<code>Option&lt;T&gt;</code> and <code>Result&lt;T, impl Error&gt;</code> <em>also</em> implement
<code>IntoView</code>. And just as <code>Fn() -&gt; T</code> renders a reactive <code>T</code>, <code>Fn() -&gt; Option&lt;T&gt;</code>
and <code>Fn() -&gt; Result&lt;T, impl Error&gt;</code> are reactive.</li>
<li>Rust has lots of handy helpers like <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map">Option::map</a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then">Option::and_then</a>,
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or">Option::ok_or</a>,
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map">Result::map</a>,
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.ok">Result::ok</a>, and
<a href="https://doc.rust-lang.org/std/primitive.bool.html#method.then">bool::then</a> that
allow you to convert, in a declarative way, between a few different standard types,
all of which can be rendered. Spending time in the <code>Option</code> and <code>Result</code> docs in particular
is one of the best ways to level up your Rust game.</li>
<li>And always remember: to be reactive, values must be functions. You’ll see me constantly
wrap things in a <code>move ||</code> closure, below. This is to ensure that they actually rerun
when the signal they depend on changes, keeping the UI reactive.</li>
</ol>
<h2 id="so-what"><a class="header" href="#so-what">So What?</a></h2>
<p>To connect the dots a little: this means that you can actually implement most of
your control flow with native Rust code, without any control-flow components or
special knowledge.</p>
<p>For example, let’s start with a simple signal and derived signal:</p>
<pre><code class="language-rust">let (value, set_value) = create_signal(0);
let is_odd = move || value() &amp; 1 == 1;</code></pre>
<blockquote>
<p>If you don’t recognize what’s going on with <code>is_odd</code>, don’t worry about it
too much. It’s just a simple way to test whether an integer is odd by doing a
bitwise <code>AND</code> with <code>1</code>.</p>
</blockquote>
<p>We can use these signals and ordinary Rust to build most control flow.</p>
<h3 id="if-statements"><a class="header" href="#if-statements"><code>if</code> statements</a></h3>
<p>Let’s say I want to render some text if the number is odd, and some other text
if it’s even. Well, how about this?</p>
<pre><code class="language-rust">view! {
    &lt;p&gt;
    {move || if is_odd() {
        &quot;Odd&quot;
    } else {
        &quot;Even&quot;
    }}
    &lt;/p&gt;
}</code></pre>
<p>An <code>if</code> expression returns its value, and a <code>&amp;str</code> implements <code>IntoView</code>, so a
<code>Fn() -&gt; &amp;str</code> implements <code>IntoView</code>, so this... just works!</p>
<h3 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h3>
<p>Let’s say we want to render some text if it’s odd, and nothing if it’s even.</p>
<pre><code class="language-rust">let message = move || {
    if is_odd() {
        Some(&quot;Ding ding ding!&quot;)
    } else {
        None
    }
};

view! {
    &lt;p&gt;{message}&lt;/p&gt;
}</code></pre>
<p>This works fine. We can make it a little shorter if we’d like, using <code>bool::then()</code>.</p>
<pre><code class="language-rust">let message = move || is_odd().then(|| &quot;Ding ding ding!&quot;);
view! {
    &lt;p&gt;{message}&lt;/p&gt;
}</code></pre>
<p>You could even inline this if you’d like, although personally I sometimes like the
better <code>cargo fmt</code> and <code>rust-analyzer</code> support I get by pulling things out of the <code>view</code>.</p>
<h3 id="match-statements"><a class="header" href="#match-statements"><code>match</code> statements</a></h3>
<p>We’re still just writing ordinary Rust code, right? So you have all the power of Rust’s
pattern matching at your disposal.</p>
<pre><code class="language-rust">let message = move || {
    match value() {
        0 =&gt; &quot;Zero&quot;,
        1 =&gt; &quot;One&quot;,
        n if is_odd() =&gt; &quot;Odd&quot;,
        _ =&gt; &quot;Even&quot;
    }
};
view! {
    &lt;p&gt;{message}&lt;/p&gt;
}</code></pre>
<p>And why not? YOLO, right?</p>
<h2 id="preventing-over-rendering"><a class="header" href="#preventing-over-rendering">Preventing Over-Rendering</a></h2>
<p>Not so YOLO.</p>
<p>Everything we’ve just done is basically fine. But there’s one thing you should remember
and try to be careful with. Each one of the control-flow functions we’ve created so far
is basically a derived signal: it will rerun every time the value changes. In the examples
above, where the value switches from even to odd on every change, this is fine.</p>
<p>But consider the following example:</p>
<pre><code class="language-rust">let (value, set_value) = create_signal(0);

let message = move || if value() &gt; 5 {
    &quot;Big&quot;
} else {
    &quot;Small&quot;
};

view! {
    &lt;p&gt;{message}&lt;/p&gt;
}</code></pre>
<p>This <em>works</em>, for sure. But if you added a log, you might be surprised</p>
<pre><code class="language-rust">let message = move || if value() &gt; 5 {
    logging::log!(&quot;{}: rendering Big&quot;, value());
    &quot;Big&quot;
} else {
    logging::log!(&quot;{}: rendering Small&quot;, value());
    &quot;Small&quot;
};</code></pre>
<p>As a user clicks a button, you’d see something like this:</p>
<pre><code>1: rendering Small
2: rendering Small
3: rendering Small
4: rendering Small
5: rendering Small
6: rendering Big
7: rendering Big
8: rendering Big
... ad infinitum
</code></pre>
<p>Every time <code>value</code> changes, it reruns the <code>if</code> statement. This makes sense, with
how reactivity works. But it has a downside. For a simple text node, rerunning
the <code>if</code> statement and rerendering isn’t a big deal. But imagine it were
like this:</p>
<pre><code class="language-rust">let message = move || if value() &gt; 5 {
    &lt;Big/&gt;
} else {
    &lt;Small/&gt;
};</code></pre>
<p>This rerenders <code>&lt;Small/&gt;</code> five times, then <code>&lt;Big/&gt;</code> infinitely. If they’re
loading resources, creating signals, or even just creating DOM nodes, this is
unnecessary work.</p>
<h3 id="show"><a class="header" href="#show"><code>&lt;Show/&gt;</code></a></h3>
<p>The <a href="https://docs.rs/leptos/latest/leptos/fn.Show.html"><code>&lt;Show/&gt;</code></a> component is
the answer. You pass it a <code>when</code> condition function, a <code>fallback</code> to be shown if
the <code>when</code> function returns <code>false</code>, and children to be rendered if <code>when</code> is <code>true</code>.</p>
<pre><code class="language-rust">let (value, set_value) = create_signal(0);

view! {
  &lt;Show
    when=move || { value() &gt; 5 }
    fallback=|| view! { &lt;Small/&gt; }
  &gt;
    &lt;Big/&gt;
  &lt;/Show&gt;
}</code></pre>
<p><code>&lt;Show/&gt;</code> memoizes the <code>when</code> condition, so it only renders its <code>&lt;Small/&gt;</code> once,
continuing to show the same component until <code>value</code> is greater than five;
then it renders <code>&lt;Big/&gt;</code> once, continuing to show it indefinitely or until <code>value</code>
goes below five and then renders <code>&lt;Small/&gt;</code> again.</p>
<p>This is a helpful tool to avoid rerendering when using dynamic <code>if</code> expressions.
As always, there's some overhead: for a very simple node (like updating a single
text node, or updating a class or attribute), a <code>move || if ...</code> will be more
efficient. But if it’s at all expensive to render either branch, reach for
<code>&lt;Show/&gt;</code>.</p>
<h2 id="note-type-conversions"><a class="header" href="#note-type-conversions">Note: Type Conversions</a></h2>
<p>There‘s one final thing it’s important to say in this section.</p>
<p>The <code>view</code> macro doesn’t return the most-generic wrapping type
<a href="https://docs.rs/leptos/latest/leptos/enum.View.html"><code>View</code></a>.
Instead, it returns things with types like <code>Fragment</code> or <code>HtmlElement&lt;Input&gt;</code>. This
can be a little annoying if you’re returning different HTML elements from
different branches of a conditional:</p>
<pre><code class="language-rust compile_error">view! {
    &lt;main&gt;
        {move || match is_odd() {
            true if value() == 1 =&gt; {
                // returns HtmlElement&lt;Pre&gt;
                view! { &lt;pre&gt;&quot;One&quot;&lt;/pre&gt; }
            },
            false if value() == 2 =&gt; {
                // returns HtmlElement&lt;P&gt;
                view! { &lt;p&gt;&quot;Two&quot;&lt;/p&gt; }
            }
            // returns HtmlElement&lt;Textarea&gt;
            _ =&gt; view! { &lt;textarea&gt;{value()}&lt;/textarea&gt; }
        }}
    &lt;/main&gt;
}</code></pre>
<p>This strong typing is actually very powerful, because
<a href="https://docs.rs/leptos/0.1.3/leptos/struct.HtmlElement.html"><code>HtmlElement</code></a> is,
among other things, a smart pointer: each <code>HtmlElement&lt;T&gt;</code> type implements
<code>Deref</code> for the appropriate underlying <code>web_sys</code> type. In other words, in the browser
your <code>view</code> returns real DOM elements, and you can access native DOM methods on
them.</p>
<p>But it can be a little annoying in conditional logic like this, because you can’t
return different types from different branches of a condition in Rust. There are two ways
to get yourself out of this situation:</p>
<ol>
<li>If you have multiple <code>HtmlElement</code> types, convert them to <code>HtmlElement&lt;AnyElement&gt;</code>
with <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.into_any"><code>.into_any()</code></a></li>
<li>If you have a variety of view types that are not all <code>HtmlElement</code>, convert them to
<code>View</code>s with <a href="https://docs.rs/leptos/latest/leptos/trait.IntoView.html#tymethod.into_view"><code>.into_view()</code></a>.</li>
</ol>
<p>Here’s the same example, with the conversion added:</p>
<pre><code class="language-rust compile_error">view! {
    &lt;main&gt;
        {move || match is_odd() {
            true if value() == 1 =&gt; {
                // returns HtmlElement&lt;Pre&gt;
                view! { &lt;pre&gt;&quot;One&quot;&lt;/pre&gt; }.into_any()
            },
            false if value() == 2 =&gt; {
                // returns HtmlElement&lt;P&gt;
                view! { &lt;p&gt;&quot;Two&quot;&lt;/p&gt; }.into_any()
            }
            // returns HtmlElement&lt;Textarea&gt;
            _ =&gt; view! { &lt;textarea&gt;{value()}&lt;/textarea&gt; }.into_any()
        }}
    &lt;/main&gt;
}</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/6-control-flow-0-5-4yn7qz?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/6-control-flow-0-5-4yn7qz?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

#[component]
fn App() -&gt; impl IntoView {
    let (value, set_value) = create_signal(0);
    let is_odd = move || value() &amp; 1 == 1;
    let odd_text = move || if is_odd() { Some(&quot;How odd!&quot;) } else { None };

    view! {
        &lt;h1&gt;&quot;Control Flow&quot;&lt;/h1&gt;

        // Simple UI to update and show a value
        &lt;button on:click=move |_| set_value.update(|n| *n += 1)&gt;
            &quot;+1&quot;
        &lt;/button&gt;
        &lt;p&gt;&quot;Value is: &quot; {value}&lt;/p&gt;

        &lt;hr/&gt;

        &lt;h2&gt;&lt;code&gt;&quot;Option&lt;T&gt;&quot;&lt;/code&gt;&lt;/h2&gt;
        // For any `T` that implements `IntoView`,
        // so does `Option&lt;T&gt;`

        &lt;p&gt;{odd_text}&lt;/p&gt;
        // This means you can use `Option` methods on it
        &lt;p&gt;{move || odd_text().map(|text| text.len())}&lt;/p&gt;

        &lt;h2&gt;&quot;Conditional Logic&quot;&lt;/h2&gt;
        // You can do dynamic conditional if-then-else
        // logic in several ways
        //
        // a. An &quot;if&quot; expression in a function
        //    This will simply re-render every time the value
        //    changes, which makes it good for lightweight UI
        &lt;p&gt;
            {move || if is_odd() {
                &quot;Odd&quot;
            } else {
                &quot;Even&quot;
            }}
        &lt;/p&gt;

        // b. Toggling some kind of class
        //    This is smart for an element that's going to
        //    toggled often, because it doesn't destroy
        //    it in between states
        //    (you can find the `hidden` class in `index.html`)
        &lt;p class:hidden=is_odd&gt;&quot;Appears if even.&quot;&lt;/p&gt;

        // c. The &lt;Show/&gt; component
        //    This only renders the fallback and the child
        //    once, lazily, and toggles between them when
        //    needed. This makes it more efficient in many cases
        //    than a {move || if ...} block
        &lt;Show when=is_odd
            fallback=|| view! { &lt;p&gt;&quot;Even steven&quot;&lt;/p&gt; }
        &gt;
            &lt;p&gt;&quot;Oddment&quot;&lt;/p&gt;
        &lt;/Show&gt;

        // d. Because `bool::then()` converts a `bool` to
        //    `Option`, you can use it to create a show/hide toggled
        {move || is_odd().then(|| view! { &lt;p&gt;&quot;Oddity!&quot;&lt;/p&gt; })}

        &lt;h2&gt;&quot;Converting between Types&quot;&lt;/h2&gt;
        // e. Note: if branches return different types,
        //    you can convert between them with
        //    `.into_any()` (for different HTML element types)
        //    or `.into_view()` (for all view types)
        {move || match is_odd() {
            true if value() == 1 =&gt; {
                // &lt;pre&gt; returns HtmlElement&lt;Pre&gt;
                view! { &lt;pre&gt;&quot;One&quot;&lt;/pre&gt; }.into_any()
            },
            false if value() == 2 =&gt; {
                // &lt;p&gt; returns HtmlElement&lt;P&gt;
                // so we convert into a more generic type
                view! { &lt;p&gt;&quot;Two&quot;&lt;/p&gt; }.into_any()
            }
            _ =&gt; view! { &lt;textarea&gt;{value()}&lt;/textarea&gt; }.into_any()
        }}
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p><a href="view/./06_control_flow.html">In the last chapter</a>, we saw that you can render <code>Option&lt;T&gt;</code>:
in the <code>None</code> case, it will render nothing, and in the <code>T</code> case, it will render <code>T</code>
(that is, if <code>T</code> implements <code>IntoView</code>). You can actually do something very similar
with a <code>Result&lt;T, E&gt;</code>. In the <code>Err(_)</code> case, it will render nothing. In the <code>Ok(T)</code>
case, it will render the <code>T</code>.</p>
<p>Let’s start with a simple component to capture a number input.</p>
<pre><code class="language-rust">#[component]
fn NumericInput() -&gt; impl IntoView {
    let (value, set_value) = create_signal(Ok(0));

    // when input changes, try to parse a number from the input
    let on_input = move |ev| set_value(event_target_value(&amp;ev).parse::&lt;i32&gt;());

    view! {
        &lt;label&gt;
            &quot;Type a number (or not!)&quot;
            &lt;input type=&quot;number&quot; on:input=on_input/&gt;
            &lt;p&gt;
                &quot;You entered &quot;
                &lt;strong&gt;{value}&lt;/strong&gt;
            &lt;/p&gt;
        &lt;/label&gt;
    }
}</code></pre>
<p>Every time you change the input, <code>on_input</code> will attempt to parse its value into a 32-bit
integer (<code>i32</code>), and store it in our <code>value</code> signal, which is a <code>Result&lt;i32, _&gt;</code>. If you
type the number <code>42</code>, the UI will display</p>
<pre><code>You entered 42
</code></pre>
<p>But if you type the string<code>foo</code>, it will display</p>
<pre><code>You entered
</code></pre>
<p>This is not great. It saves us using <code>.unwrap_or_default()</code> or something, but it would be
much nicer if we could catch the error and do something with it.</p>
<p>You can do that, with the <a href="https://docs.rs/leptos/latest/leptos/fn.ErrorBoundary.html"><code>&lt;ErrorBoundary/&gt;</code></a>
component.</p>
<h2 id="errorboundary"><a class="header" href="#errorboundary"><code>&lt;ErrorBoundary/&gt;</code></a></h2>
<p>An <code>&lt;ErrorBoundary/&gt;</code> is a little like the <code>&lt;Show/&gt;</code> component we saw in the last chapter.
If everything’s okay—which is to say, if everything is <code>Ok(_)</code>—it renders its children.
But if there’s an <code>Err(_)</code> rendered among those children, it will trigger the
<code>&lt;ErrorBoundary/&gt;</code>’s <code>fallback</code>.</p>
<p>Let’s add an <code>&lt;ErrorBoundary/&gt;</code> to this example.</p>
<pre><code class="language-rust">#[component]
fn NumericInput() -&gt; impl IntoView {
    let (value, set_value) = create_signal(Ok(0));

    let on_input = move |ev| set_value(event_target_value(&amp;ev).parse::&lt;i32&gt;());

    view! {
        &lt;h1&gt;&quot;Error Handling&quot;&lt;/h1&gt;
        &lt;label&gt;
            &quot;Type a number (or something that's not a number!)&quot;
            &lt;input type=&quot;number&quot; on:input=on_input/&gt;
            &lt;ErrorBoundary
                // the fallback receives a signal containing current errors
                fallback=|errors| view! {
                    &lt;div class=&quot;error&quot;&gt;
                        &lt;p&gt;&quot;Not a number! Errors: &quot;&lt;/p&gt;
                        // we can render a list of errors as strings, if we'd like
                        &lt;ul&gt;
                            {move || errors.get()
                                .into_iter()
                                .map(|(_, e)| view! { &lt;li&gt;{e.to_string()}&lt;/li&gt;})
                                .collect_view()
                            }
                        &lt;/ul&gt;
                    &lt;/div&gt;
                }
            &gt;
                &lt;p&gt;&quot;You entered &quot; &lt;strong&gt;{value}&lt;/strong&gt;&lt;/p&gt;
            &lt;/ErrorBoundary&gt;
        &lt;/label&gt;
    }
}</code></pre>
<p>Now, if you type <code>42</code>, <code>value</code> is <code>Ok(42)</code> and you’ll see</p>
<pre><code>You entered 42
</code></pre>
<p>If you type <code>foo</code>, value is <code>Err(_)</code> and the <code>fallback</code> will render. We’ve chosen to render
the list of errors as a <code>String</code>, so you’ll see something like</p>
<pre><code>Not a number! Errors:
- cannot parse integer from empty string
</code></pre>
<p>If you fix the error, the error message will disappear and the content you’re wrapping in
an <code>&lt;ErrorBoundary/&gt;</code> will appear again.</p>
<p><a href="https://codesandbox.io/p/sandbox/7-errors-0-5-5mptv9?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/7-errors-0-5-5mptv9?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

#[component]
fn App() -&gt; impl IntoView {
    let (value, set_value) = create_signal(Ok(0));

    // when input changes, try to parse a number from the input
    let on_input = move |ev| set_value(event_target_value(&amp;ev).parse::&lt;i32&gt;());

    view! {
        &lt;h1&gt;&quot;Error Handling&quot;&lt;/h1&gt;
        &lt;label&gt;
            &quot;Type a number (or something that's not a number!)&quot;
            &lt;input type=&quot;number&quot; on:input=on_input/&gt;
            // If an `Err(_) had been rendered inside the &lt;ErrorBoundary/&gt;,
            // the fallback will be displayed. Otherwise, the children of the
            // &lt;ErrorBoundary/&gt; will be displayed.
            &lt;ErrorBoundary
                // the fallback receives a signal containing current errors
                fallback=|errors| view! {
                    &lt;div class=&quot;error&quot;&gt;
                        &lt;p&gt;&quot;Not a number! Errors: &quot;&lt;/p&gt;
                        // we can render a list of errors
                        // as strings, if we'd like
                        &lt;ul&gt;
                            {move || errors.get()
                                .into_iter()
                                .map(|(_, e)| view! { &lt;li&gt;{e.to_string()}&lt;/li&gt;})
                                .collect::&lt;Vec&lt;_&gt;&gt;()
                            }
                        &lt;/ul&gt;
                    &lt;/div&gt;
                }
            &gt;
                &lt;p&gt;
                    &quot;You entered &quot;
                    // because `value` is `Result&lt;i32, _&gt;`,
                    // it will render the `i32` if it is `Ok`,
                    // and render nothing and trigger the error boundary
                    // if it is `Err`. It's a signal, so this will dynamically
                    // update when `value` changes
                    &lt;strong&gt;{value}&lt;/strong&gt;
                &lt;/p&gt;
            &lt;/ErrorBoundary&gt;
        &lt;/label&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parent-child-communication"><a class="header" href="#parent-child-communication">Parent-Child Communication</a></h1>
<p>You can think of your application as a nested tree of components. Each component
handles its own local state and manages a section of the user interface, so
components tend to be relatively self-contained.</p>
<p>Sometimes, though, you’ll want to communicate between a parent component and its
child. For example, imagine you’ve defined a <code>&lt;FancyButton/&gt;</code> component that adds
some styling, logging, or something else to a <code>&lt;button/&gt;</code>. You want to use a
<code>&lt;FancyButton/&gt;</code> in your <code>&lt;App/&gt;</code> component. But how can you communicate between
the two?</p>
<p>It’s easy to communicate state from a parent component to a child component. We
covered some of this in the material on <a href="view/./03_components.html">components and props</a>.
Basically if you want the parent to communicate to the child, you can pass a
<a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html"><code>ReadSignal</code></a>, a
<a href="https://docs.rs/leptos/latest/leptos/struct.Signal.html"><code>Signal</code></a>, or even a
<a href="https://docs.rs/leptos/latest/leptos/enum.MaybeSignal.html"><code>MaybeSignal</code></a> as a prop.</p>
<p>But what about the other direction? How can a child send notifications about events
or state changes back up to the parent?</p>
<p>There are four basic patterns of parent-child communication in Leptos.</p>
<h2 id="1-pass-a-writesignal"><a class="header" href="#1-pass-a-writesignal">1. Pass a <a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html"><code>WriteSignal</code></a></a></h2>
<p>One approach is simply to pass a <code>WriteSignal</code> from the parent down to the child, and update
it in the child. This lets you manipulate the state of the parent from the child.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonA setter=set_toggled/&gt;
    }
}

#[component]
pub fn ButtonA(setter: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>This pattern is simple, but you should be careful with it: passing around a <code>WriteSignal</code>
can make it hard to reason about your code. In this example, it’s pretty clear when you
read <code>&lt;App/&gt;</code> that you are handing off the ability to mutate <code>toggled</code>, but it’s not at
all clear when or how it will change. In this small, local example it’s easy to understand,
but if you find yourself passing around <code>WriteSignal</code>s like this throughout your code,
you should really consider whether this is making it too easy to write spaghetti code.</p>
<h2 id="2-use-a-callback"><a class="header" href="#2-use-a-callback">2. Use a Callback</a></h2>
<p>Another approach would be to pass a callback to the child: say, <code>on_click</code>.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonB on_click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonB(#[prop(into)] on_click: Callback&lt;MouseEvent&gt;) -&gt; impl IntoView
{
    view! {
        &lt;button on:click=on_click&gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>You’ll notice that whereas <code>&lt;ButtonA/&gt;</code> was given a <code>WriteSignal</code> and decided how to mutate it,
<code>&lt;ButtonB/&gt;</code> simply fires an event: the mutation happens back in <code>&lt;App/&gt;</code>. This has the advantage
of keeping local state local, preventing the problem of spaghetti mutation. But it also means
the logic to mutate that signal needs to exist up in <code>&lt;App/&gt;</code>, not down in <code>&lt;ButtonB/&gt;</code>. These
are real trade-offs, not a simple right-or-wrong choice.</p>
<blockquote>
<p>Note the way we use the <code>Callback&lt;In, Out&gt;</code> type. This is basically a
wrapper around a closure <code>Fn(In) -&gt; Out</code> that is also <code>Copy</code> and makes it
easy to pass around.</p>
<p>We also used the <code>#[prop(into)]</code> attribute so we can pass a normal closure into
<code>on_click</code>. Please see the <a href="view/./03_components.html#into-props">chapter &quot;<code>into</code> Props&quot;</a> for more details.</p>
</blockquote>
<h3 id="21-use-closure-instead-of-callback"><a class="header" href="#21-use-closure-instead-of-callback">2.1 Use Closure instead of <code>Callback</code></a></h3>
<p>You can use a Rust closure <code>Fn(MouseEvent)</code> directly instead of <code>Callback</code>:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonB on_click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonB&lt;F&gt;(on_click: F) -&gt; impl IntoView
where
    F: Fn(MouseEvent) + 'static
{
    view! {
        &lt;button on:click=on_click&gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>The code is very similar in this case. On more advanced use-cases using a
closure might require some cloning compared to using a <code>Callback</code>.</p>
<blockquote>
<p>Note the way we declare the generic type <code>F</code> here for the callback. If you’re
confused, look back at the <a href="view/./03_components.html#generic-props">generic props</a> section
of the chapter on components.</p>
</blockquote>
<h2 id="3-use-an-event-listener"><a class="header" href="#3-use-an-event-listener">3. Use an Event Listener</a></h2>
<p>You can actually write Option 2 in a slightly different way. If the callback maps directly onto
a native DOM event, you can add an <code>on:</code> listener directly to the place you use the component
in your <code>view</code> macro in <code>&lt;App/&gt;</code>.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        // note the on:click instead of on_click
        // this is the same syntax as an HTML element event listener
        &lt;ButtonC on:click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonC() -&gt; impl IntoView {
    view! {
        &lt;button&gt;&quot;Toggle&quot;&lt;/button&gt;
    }
}</code></pre>
<p>This lets you write way less code in <code>&lt;ButtonC/&gt;</code> than you did for <code>&lt;ButtonB/&gt;</code>,
and still gives a correctly-typed event to the listener. This works by adding an
<code>on:</code> event listener to each element that <code>&lt;ButtonC/&gt;</code> returns: in this case, just
the one <code>&lt;button&gt;</code>.</p>
<p>Of course, this only works for actual DOM events that you’re passing directly through
to the elements you’re rendering in the component. For more complex logic that
doesn’t map directly onto an element (say you create <code>&lt;ValidatedForm/&gt;</code> and want an
<code>on_valid_form_submit</code> callback) you should use Option 2.</p>
<h2 id="4-providing-a-context"><a class="header" href="#4-providing-a-context">4. Providing a Context</a></h2>
<p>This version is actually a variant on Option 1. Say you have a deeply-nested component
tree:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout/&gt;
    }
}

#[component]
pub fn Layout() -&gt; impl IntoView {
    view! {
        &lt;header&gt;
            &lt;h1&gt;&quot;My Page&quot;&lt;/h1&gt;
        &lt;/header&gt;
        &lt;main&gt;
            &lt;Content/&gt;
        &lt;/main&gt;
    }
}

#[component]
pub fn Content() -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;content&quot;&gt;
            &lt;ButtonD/&gt;
        &lt;/div&gt;
    }
}

#[component]
pub fn ButtonD&lt;F&gt;() -&gt; impl IntoView {
    todo!()
}</code></pre>
<p>Now <code>&lt;ButtonD/&gt;</code> is no longer a direct child of <code>&lt;App/&gt;</code>, so you can’t simply
pass your <code>WriteSignal</code> to its props. You could do what’s sometimes called
“prop drilling,” adding a prop to each layer between the two:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout set_toggled/&gt;
    }
}

#[component]
pub fn Layout(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;header&gt;
            &lt;h1&gt;&quot;My Page&quot;&lt;/h1&gt;
        &lt;/header&gt;
        &lt;main&gt;
            &lt;Content set_toggled/&gt;
        &lt;/main&gt;
    }
}

#[component]
pub fn Content(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;content&quot;&gt;
            &lt;ButtonD set_toggled/&gt;
        &lt;/div&gt;
    }
}

#[component]
pub fn ButtonD&lt;F&gt;(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    todo!()
}</code></pre>
<p>This is a mess. <code>&lt;Layout/&gt;</code> and <code>&lt;Content/&gt;</code> don’t need <code>set_toggled</code>; they just
pass it through to <code>&lt;ButtonD/&gt;</code>. But I need to declare the prop in triplicate.
This is not only annoying but hard to maintain: imagine we add a “half-toggled”
option and the type of <code>set_toggled</code> needs to change to an <code>enum</code>. We have to change
it in three places!</p>
<p>Isn’t there some way to skip levels?</p>
<p>There is!</p>
<h3 id="41-the-context-api"><a class="header" href="#41-the-context-api">4.1 The Context API</a></h3>
<p>You can provide data that skips levels by using <a href="https://docs.rs/leptos/latest/leptos/fn.provide_context.html"><code>provide_context</code></a>
and <a href="https://docs.rs/leptos/latest/leptos/fn.use_context.html"><code>use_context</code></a>. Contexts are identified
by the type of the data you provide (in this example, <code>WriteSignal&lt;bool&gt;</code>), and they exist in a top-down
tree that follows the contours of your UI tree. In this example, we can use context to skip the
unnecessary prop drilling.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);

    // share `set_toggled` with all children of this component
    provide_context(set_toggled);

    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout/&gt;
    }
}

// &lt;Layout/&gt; and &lt;Content/&gt; omitted
// To work in this version, drop their references to set_toggled

#[component]
pub fn ButtonD() -&gt; impl IntoView {
    // use_context searches up the context tree, hoping to
    // find a `WriteSignal&lt;bool&gt;`
    // in this case, I .expect() because I know I provided it
    let setter = use_context::&lt;WriteSignal&lt;bool&gt;&gt;()
        .expect(&quot;to have found the setter provided&quot;);

    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>The same caveats apply to this as to <code>&lt;ButtonA/&gt;</code>: passing a <code>WriteSignal</code>
around should be done with caution, as it allows you to mutate state from
arbitrary parts of your code. But when done carefully, this can be one of
the most effective techniques for global state management in Leptos: simply
provide the state at the highest level you’ll need it, and use it wherever
you need it lower down.</p>
<p>Note that there are no performance downsides to this approach. Because you
are passing a fine-grained reactive signal, <em>nothing happens</em> in the intervening
components (<code>&lt;Layout/&gt;</code> and <code>&lt;Content/&gt;</code>) when you update it. You are communicating
directly between <code>&lt;ButtonD/&gt;</code> and <code>&lt;App/&gt;</code>. In fact—and this is the power of
fine-grained reactivity—you are communicating directly between a button click
in <code>&lt;ButtonD/&gt;</code> and a single text node in <code>&lt;App/&gt;</code>. It’s as if the components
themselves don’t exist at all. And, well... at runtime, they don’t. It’s just
signals and effects, all the way down.</p>
<p><a href="https://codesandbox.io/p/sandbox/8-parent-child-0-5-7rz7qd?file=%2Fsrc%2Fmain.rs%3A1%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/8-parent-child-0-5-7rz7qd?file=%2Fsrc%2Fmain.rs%3A1%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::{ev::MouseEvent, *};

// This highlights four different ways that child components can communicate
// with their parent:
// 1) &lt;ButtonA/&gt;: passing a WriteSignal as one of the child component props,
//    for the child component to write into and the parent to read
// 2) &lt;ButtonB/&gt;: passing a closure as one of the child component props, for
//    the child component to call
// 3) &lt;ButtonC/&gt;: adding an `on:` event listener to a component
// 4) &lt;ButtonD/&gt;: providing a context that is used in the component (rather than prop drilling)

#[derive(Copy, Clone)]
struct SmallcapsContext(WriteSignal&lt;bool&gt;);

#[component]
pub fn App() -&gt; impl IntoView {
    // just some signals to toggle three classes on our &lt;p&gt;
    let (red, set_red) = create_signal(false);
    let (right, set_right) = create_signal(false);
    let (italics, set_italics) = create_signal(false);
    let (smallcaps, set_smallcaps) = create_signal(false);

    // the newtype pattern isn't *necessary* here but is a good practice
    // it avoids confusion with other possible future `WriteSignal&lt;bool&gt;` contexts
    // and makes it easier to refer to it in ButtonC
    provide_context(SmallcapsContext(set_smallcaps));

    view! {
        &lt;main&gt;
            &lt;p
                // class: attributes take F: Fn() =&gt; bool, and these signals all implement Fn()
                class:red=red
                class:right=right
                class:italics=italics
                class:smallcaps=smallcaps
            &gt;
                &quot;Lorem ipsum sit dolor amet.&quot;
            &lt;/p&gt;

            // Button A: pass the signal setter
            &lt;ButtonA setter=set_red/&gt;

            // Button B: pass a closure
            &lt;ButtonB on_click=move |_| set_right.update(|value| *value = !*value)/&gt;

            // Button B: use a regular event listener
            // setting an event listener on a component like this applies it
            // to each of the top-level elements the component returns
            &lt;ButtonC on:click=move |_| set_italics.update(|value| *value = !*value)/&gt;

            // Button D gets its setter from context rather than props
            &lt;ButtonD/&gt;
        &lt;/main&gt;
    }
}

/// Button A receives a signal setter and updates the signal itself
#[component]
pub fn ButtonA(
    /// Signal that will be toggled when the button is clicked.
    setter: WriteSignal&lt;bool&gt;,
) -&gt; impl IntoView {
    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle Red&quot;
        &lt;/button&gt;
    }
}

/// Button B receives a closure
#[component]
pub fn ButtonB&lt;F&gt;(
    /// Callback that will be invoked when the button is clicked.
    on_click: F,
) -&gt; impl IntoView
where
    F: Fn(MouseEvent) + 'static,
{
    view! {
        &lt;button
            on:click=on_click
        &gt;
            &quot;Toggle Right&quot;
        &lt;/button&gt;
    }

    // just a note: in an ordinary function ButtonB could take on_click: impl Fn(MouseEvent) + 'static
    // and save you from typing out the generic
    // the component macro actually expands to define a
    //
    // struct ButtonBProps&lt;F&gt; where F: Fn(MouseEvent) + 'static {
    //   on_click: F
    // }
    //
    // this is what allows us to have named props in our component invocation,
    // instead of an ordered list of function arguments
    // if Rust ever had named function arguments we could drop this requirement
}

/// Button C is a dummy: it renders a button but doesn't handle
/// its click. Instead, the parent component adds an event listener.
#[component]
pub fn ButtonC() -&gt; impl IntoView {
    view! {
        &lt;button&gt;
            &quot;Toggle Italics&quot;
        &lt;/button&gt;
    }
}

/// Button D is very similar to Button A, but instead of passing the setter as a prop
/// we get it from the context
#[component]
pub fn ButtonD() -&gt; impl IntoView {
    let setter = use_context::&lt;SmallcapsContext&gt;().unwrap().0;

    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle Small Caps&quot;
        &lt;/button&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-children"><a class="header" href="#component-children">Component Children</a></h1>
<p>It’s pretty common to want to pass children into a component, just as you can pass
children into an HTML element. For example, imagine I have a <code>&lt;FancyForm/&gt;</code> component
that enhances an HTML <code>&lt;form&gt;</code>. I need some way to pass all its inputs.</p>
<pre><code class="language-rust">view! {
    &lt;Form&gt;
        &lt;fieldset&gt;
            &lt;label&gt;
                &quot;Some Input&quot;
                &lt;input type=&quot;text&quot; name=&quot;something&quot;/&gt;
            &lt;/label&gt;
        &lt;/fieldset&gt;
        &lt;button&gt;&quot;Submit&quot;&lt;/button&gt;
    &lt;/Form&gt;
}</code></pre>
<p>How can you do this in Leptos? There are basically two ways to pass components to
other components:</p>
<ol>
<li><strong>render props</strong>: properties that are functions that return a view</li>
<li>the <strong><code>children</code></strong> prop: a special component property that includes anything
you pass as a child to the component.</li>
</ol>
<p>In fact, you’ve already seen these both in action in the <a href="view//view/06_control_flow.html#show"><code>&lt;Show/&gt;</code></a> component:</p>
<pre><code class="language-rust">view! {
  &lt;Show
    // `when` is a normal prop
    when=move || value() &gt; 5
    // `fallback` is a &quot;render prop&quot;: a function that returns a view
    fallback=|| view! { &lt;Small/&gt; }
  &gt;
    // `&lt;Big/&gt;` (and anything else here)
    // will be given to the `children` prop
    &lt;Big/&gt;
  &lt;/Show&gt;
}</code></pre>
<p>Let’s define a component that takes some children and a render prop.</p>
<pre><code class="language-rust">#[component]
pub fn TakesChildren&lt;F, IV&gt;(
    /// Takes a function (type F) that returns anything that can be
    /// converted into a View (type IV)
    render_prop: F,
    /// `children` takes the `Children` type
    children: Children,
) -&gt; impl IntoView
where
    F: Fn() -&gt; IV,
    IV: IntoView,
{
    view! {
        &lt;h2&gt;&quot;Render Prop&quot;&lt;/h2&gt;
        {render_prop()}

        &lt;h2&gt;&quot;Children&quot;&lt;/h2&gt;
        {children()}
    }
}</code></pre>
<p><code>render_prop</code> and <code>children</code> are both functions, so we can call them to generate
the appropriate views. <code>children</code>, in particular, is an alias for
<code>Box&lt;dyn FnOnce() -&gt; Fragment&gt;</code>. (Aren't you glad we named it <code>Children</code> instead?)</p>
<blockquote>
<p>If you need a <code>Fn</code> or <code>FnMut</code> here because you need to call <code>children</code> more than once,
we also provide <code>ChildrenFn</code> and <code>ChildrenMut</code> aliases.</p>
</blockquote>
<p>We can use the component like this:</p>
<pre><code class="language-rust">view! {
    &lt;TakesChildren render_prop=|| view! { &lt;p&gt;&quot;Hi, there!&quot;&lt;/p&gt; }&gt;
        // these get passed to `children`
        &quot;Some text&quot;
        &lt;span&gt;&quot;A span&quot;&lt;/span&gt;
    &lt;/TakesChildren&gt;
}</code></pre>
<h2 id="manipulating-children"><a class="header" href="#manipulating-children">Manipulating Children</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/struct.Fragment.html"><code>Fragment</code></a> type is
basically a way of wrapping a <code>Vec&lt;View&gt;</code>. You can insert it anywhere into your view.</p>
<p>But you can also access those inner views directly to manipulate them. For example, here’s
a component that takes its children and turns them into an unordered list.</p>
<pre><code class="language-rust">#[component]
pub fn WrapsChildren(children: Children) -&gt; impl IntoView {
    // Fragment has `nodes` field that contains a Vec&lt;View&gt;
    let children = children()
        .nodes
        .into_iter()
        .map(|child| view! { &lt;li&gt;{child}&lt;/li&gt; })
        .collect_view();

    view! {
        &lt;ul&gt;{children}&lt;/ul&gt;
    }
}</code></pre>
<p>Calling it like this will create a list:</p>
<pre><code class="language-rust">view! {
    &lt;WrapsChildren&gt;
        &quot;A&quot;
        &quot;B&quot;
        &quot;C&quot;
    &lt;/WrapsChildren&gt;
}</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/9-component-children-0-5-m4jwhp?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/9-component-children-0-5-m4jwhp?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

// Often, you want to pass some kind of child view to another
// component. There are two basic patterns for doing this:
// - &quot;render props&quot;: creating a component prop that takes a function
//   that creates a view
// - the `children` prop: a special property that contains content
//   passed as the children of a component in your view, not as a
//   property

#[component]
pub fn App() -&gt; impl IntoView {
    let (items, set_items) = create_signal(vec![0, 1, 2]);
    let render_prop = move || {
        // items.with(...) reacts to the value without cloning
        // by applying a function. Here, we pass the `len` method
        // on a `Vec&lt;_&gt;` directly
        let len = move || items.with(Vec::len);
        view! {
            &lt;p&gt;&quot;Length: &quot; {len}&lt;/p&gt;
        }
    };

    view! {
        // This component just displays the two kinds of children,
        // embedding them in some other markup
        &lt;TakesChildren
            // for component props, you can shorthand
            // `render_prop=render_prop` =&gt; `render_prop`
            // (this doesn't work for HTML element attributes)
            render_prop
        &gt;
            // these look just like the children of an HTML element
            &lt;p&gt;&quot;Here's a child.&quot;&lt;/p&gt;
            &lt;p&gt;&quot;Here's another child.&quot;&lt;/p&gt;
        &lt;/TakesChildren&gt;
        &lt;hr/&gt;
        // This component actually iterates over and wraps the children
        &lt;WrapsChildren&gt;
            &lt;p&gt;&quot;Here's a child.&quot;&lt;/p&gt;
            &lt;p&gt;&quot;Here's another child.&quot;&lt;/p&gt;
        &lt;/WrapsChildren&gt;
    }
}

/// Displays a `render_prop` and some children within markup.
#[component]
pub fn TakesChildren&lt;F, IV&gt;(
    /// Takes a function (type F) that returns anything that can be
    /// converted into a View (type IV)
    render_prop: F,
    /// `children` takes the `Children` type
    /// this is an alias for `Box&lt;dyn FnOnce() -&gt; Fragment&gt;`
    /// ... aren't you glad we named it `Children` instead?
    children: Children,
) -&gt; impl IntoView
where
    F: Fn() -&gt; IV,
    IV: IntoView,
{
    view! {
        &lt;h1&gt;&lt;code&gt;&quot;&lt;TakesChildren/&gt;&quot;&lt;/code&gt;&lt;/h1&gt;
        &lt;h2&gt;&quot;Render Prop&quot;&lt;/h2&gt;
        {render_prop()}
        &lt;hr/&gt;
        &lt;h2&gt;&quot;Children&quot;&lt;/h2&gt;
        {children()}
    }
}

/// Wraps each child in an `&lt;li&gt;` and embeds them in a `&lt;ul&gt;`.
#[component]
pub fn WrapsChildren(children: Children) -&gt; impl IntoView {
    // children() returns a `Fragment`, which has a
    // `nodes` field that contains a Vec&lt;View&gt;
    // this means we can iterate over the children
    // to create something new!
    let children = children()
        .nodes
        .into_iter()
        .map(|child| view! { &lt;li&gt;{child}&lt;/li&gt; })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    view! {
        &lt;h1&gt;&lt;code&gt;&quot;&lt;WrapsChildren/&gt;&quot;&lt;/code&gt;&lt;/h1&gt;
        // wrap our wrapped children in a UL
        &lt;ul&gt;{children}&lt;/ul&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-macros-the-view-builder-syntax"><a class="header" href="#no-macros-the-view-builder-syntax">No Macros: The View Builder Syntax</a></h1>
<blockquote>
<p>If you’re perfectly happy with the <code>view!</code> macro syntax described so far, you’re welcome to skip this chapter. The builder syntax described in this section is always available, but never required.</p>
</blockquote>
<p>For one reason or another, many developers would prefer to avoid macros. Perhaps you don’t like the limited <code>rustfmt</code> support. (Although, you should check out <a href="https://github.com/bram209/leptosfmt"><code>leptosfmt</code></a>, which is an excellent tool!) Perhaps you worry about the effect of macros on compile time. Perhaps you prefer the aesthetics of pure Rust syntax, or you have trouble context-switching between an HTML-like syntax and your Rust code. Or perhaps you want more flexibility in how you create and manipulate HTML elements than the <code>view</code> macro provides.</p>
<p>If you fall into any of those camps, the builder syntax may be for you.</p>
<p>The <code>view</code> macro expands an HTML-like syntax to a series of Rust functions and method calls. If you’d rather not use the <code>view</code> macro, you can simply use that expanded syntax yourself. And it’s actually pretty nice!</p>
<p>First off, if you want you can even drop the <code>#[component]</code> macro: a component is just a setup function that creates your view, so you can define a component as a simple function call:</p>
<pre><code class="language-rust">pub fn counter(initial_value: i32, step: u32) -&gt; impl IntoView { }</code></pre>
<p>Elements are created by calling a function with the same name as the HTML element:</p>
<pre><code class="language-rust">p()</code></pre>
<p>You can add children to the element with <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.child"><code>.child()</code></a>, which takes a single child or a tuple or array of types that implement <a href="https://docs.rs/leptos/latest/leptos/trait.IntoView.html"><code>IntoView</code></a>.</p>
<pre><code class="language-rust">p().child((em().child(&quot;Big, &quot;), strong().child(&quot;bold &quot;), &quot;text&quot;))</code></pre>
<p>Attributes are added with <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.attr"><code>.attr()</code></a>. This can take any of the same types that you could pass as an attribute into the view macro (types that implement <a href="https://docs.rs/leptos/latest/leptos/trait.IntoAttribute.html"><code>IntoAttribute</code></a>).</p>
<pre><code class="language-rust">p().attr(&quot;id&quot;, &quot;foo&quot;).attr(&quot;data-count&quot;, move || count().to_string())</code></pre>
<p>Similarly, the <code>class:</code>, <code>prop:</code>, and <code>style:</code> syntaxes map directly onto <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.class"><code>.class()</code></a>, <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.prop"><code>.prop()</code></a>, and <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.style"><code>.style()</code></a> methods.</p>
<p>Event listeners can be added with <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.on"><code>.on()</code></a>. Typed events found in <a href="https://docs.rs/leptos/latest/leptos/ev/index.html"><code>leptos::ev</code></a> prevent typos in event names and allow for correct type inference in the callback function.</p>
<pre><code class="language-rust">button()
    .on(ev::click, move |_| set_count.update(|count| count.clear()))
    .child(&quot;Clear&quot;)</code></pre>
<blockquote>
<p>Many additional methods can be found in the <a href="https://docs.rs/leptos/latest/leptos/struct.HtmlElement.html#method.child"><code>HtmlElement</code></a> docs, including some methods that are not directly available in the <code>view</code> macro.</p>
</blockquote>
<p>All of this adds up to a very Rusty syntax to build full-featured views, if you prefer this style.</p>
<pre><code class="language-rust">/// A simple counter view.
// A component is really just a function call: it runs once to create the DOM and reactive system
pub fn counter(initial_value: i32, step: u32) -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    div()
        .child((
            button()
                // typed events found in leptos::ev
                // 1) prevent typos in event names
                // 2) allow for correct type inference in callbacks
                .on(ev::click, move |_| set_count.update(|count| count.clear()))
                .child(&quot;Clear&quot;),
            button()
                .on(ev::click, move |_| {
                    set_count.update(|count| count.decrease())
                })
                .child(&quot;-1&quot;),
            span().child((&quot;Value: &quot;, move || count.get().value(), &quot;!&quot;)),
            button()
                .on(ev::click, move |_| {
                    set_count.update(|count| count.increase())
                })
                .child(&quot;+1&quot;),
        ))
}</code></pre>
<p>This also has the benefit of being more flexible: because these are all plain Rust functions and methods, it’s easier to use them in things like iterator adapters without any additional “magic”:</p>
<pre><code class="language-rust">// take some set of attribute names and values
let attrs: Vec&lt;(&amp;str, AttributeValue)&gt; = todo!();
// you can use the builder syntax to “spread” these onto the
// element in a way that’s not possible with the view macro
let p = attrs
    .into_iter()
    .fold(p(), |el, (name, value)| el.attr(name, value));
</code></pre>
<blockquote>
<h2 id="performance-note"><a class="header" href="#performance-note">Performance Note</a></h2>
<p>One caveat: the <code>view</code> macro applies significant optimizations in server-side-rendering (SSR) mode to improve HTML rendering performance significantly (think 2-4x faster, depending on the characteristics of any given app). It does this by analyzing your <code>view</code> at compile time and converting the static parts into simple HTML strings, rather than expanding them into the builder syntax.</p>
<p>This means two things:</p>
<ol>
<li>The builder syntax and <code>view</code> macro should not be mixed, or should only be mixed very carefully: at least in SSR mode, the output of the <code>view</code> should be treated as a “black box” that can’t have additional builder methods applied to it without causing inconsistencies.</li>
<li>Using the builder syntax will result in less-than-optimal SSR performance. It won’t be slow, by any means (and it’s worth running your own benchmarks in any case), just slower than the <code>view</code>-optimized version.</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactivity"><a class="header" href="#reactivity">Reactivity</a></h1>
<p>Leptos is built on top of a fine-grained reactive system, designed to run expensive side effects (like rendering something in a browser, or making a network request) as infrequently as possible in response to change, reactive values.</p>
<p>So far we’ve seen signals in action. These chapters will go into a bit more depth, and look at effects, which are the other half of the story.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-signals"><a class="header" href="#working-with-signals">Working with Signals</a></h1>
<p>So far we’ve used some simple examples of <a href="https://docs.rs/leptos/latest/leptos/fn.create_signal.html"><code>create_signal</code></a>, which returns a <a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html"><code>ReadSignal</code></a> getter and a <a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html"><code>WriteSignal</code></a> setter.</p>
<h2 id="getting-and-setting"><a class="header" href="#getting-and-setting">Getting and Setting</a></h2>
<p>There are four basic signal operations:</p>
<ol>
<li><a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html#impl-SignalGet%3CT%3E-for-ReadSignal%3CT%3E"><code>.get()</code></a> clones the current value of the signal and tracks any future changes to the value reactively.</li>
<li><a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html#impl-SignalWith%3CT%3E-for-ReadSignal%3CT%3E"><code>.with()</code></a> takes a function, which receives the current value of the signal by reference (<code>&amp;T</code>), and tracks any future changes.</li>
<li><a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html#impl-SignalSet%3CT%3E-for-WriteSignal%3CT%3E"><code>.set()</code></a> replaces the current value of the signal and notifies any subscribers that they need to update.</li>
<li><a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html#impl-SignalUpdate%3CT%3E-for-WriteSignal%3CT%3E"><code>.update()</code></a> takes a function, which receives a mutable reference to the current value of the signal (<code>&amp;mut T</code>), and notifies any subscribers that they need to update. (<code>.update()</code> doesn’t return the value returned by the closure, but you can use <a href="https://docs.rs/leptos/latest/leptos/trait.SignalUpdate.html#tymethod.try_update"><code>.try_update()</code></a> if you need to; for example, if you’re removing an item from a <code>Vec&lt;_&gt;</code> and want the removed item.)</li>
</ol>
<p>Calling a <code>ReadSignal</code> as a function is syntax sugar for <code>.get()</code>. Calling a <code>WriteSignal</code> as a function is syntax sugar for <code>.set()</code>. So</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
set_count(1);
logging::log!(count());</code></pre>
<p>is the same as</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
set_count.set(1);
logging::log!(count.get());</code></pre>
<p>You might notice that <code>.get()</code> and <code>.set()</code> can be implemented in terms of <code>.with()</code> and <code>.update()</code>. In other words, <code>count.get()</code> is identical with <code>count.with(|n| n.clone())</code>, and <code>count.set(1)</code> is implemented by doing <code>count.update(|n| *n = 1)</code>.</p>
<p>But of course, <code>.get()</code> and <code>.set()</code> (or the plain function-call forms!) are much nicer syntax.</p>
<p>However, there are some very good use cases for <code>.with()</code> and <code>.update()</code>.</p>
<p>For example, consider a signal that holds a <code>Vec&lt;String&gt;</code>.</p>
<pre><code class="language-rust">let (names, set_names) = create_signal(Vec::new());
if names().is_empty() {
	set_names(vec![&quot;Alice&quot;.to_string()]);
}</code></pre>
<p>In terms of logic, this is simple enough, but it’s hiding some significant inefficiencies. Remember that <code>names().is_empty()</code> is sugar for <code>names.get().is_empty()</code>, which clones the value (it’s <code>names.with(|n| n.clone()).is_empty()</code>). This means we clone the whole <code>Vec&lt;String&gt;</code>, run <code>is_empty()</code>, and then immediately throw away the clone.</p>
<p>Likewise, <code>set_names</code> replaces the value with a whole new <code>Vec&lt;_&gt;</code>. This is fine, but we might as well just mutate the original <code>Vec&lt;_&gt;</code> in place.</p>
<pre><code class="language-rust">let (names, set_names) = create_signal(Vec::new());
if names.with(|names| names.is_empty()) {
	set_names.update(|names| names.push(&quot;Alice&quot;.to_string()));
}</code></pre>
<p>Now our function simply takes <code>names</code> by reference to run <code>is_empty()</code>, avoiding that clone.</p>
<p>And if you have Clippy on, or if you have sharp eyes, you may notice we can make this even neater:</p>
<pre><code class="language-rust">if names.with(Vec::is_empty) {
	// ...
}</code></pre>
<p>After all, <code>.with()</code> simply takes a function that takes the value by reference. Since <code>Vec::is_empty</code> takes <code>&amp;self</code>, we can pass it in directly and avoid the unnecessary closure.</p>
<p>There are some helper macros to make using <code>.with()</code> and <code>.update()</code> easier to use, especially when using multiple signals.</p>
<pre><code class="language-rust">let (first, _) = create_signal(&quot;Bob&quot;.to_string());
let (middle, _) = create_signal(&quot;J.&quot;.to_string());
let (last, _) = create_signal(&quot;Smith&quot;.to_string());</code></pre>
<p>If you wanted to concatenate these 3 signals together without unnecessary cloning, you would have to write something like:</p>
<pre><code class="language-rust">let name = move || {
	first.with(|first| {
		middle.with(|middle| last.with(|last| format!(&quot;{first} {middle} {last}&quot;)))
	})
};</code></pre>
<p>Which is very long and annoying to write.</p>
<p>Instead, you can use the <code>with!</code> macro to get references to all the signals at the same time.</p>
<pre><code class="language-rust">let name = move || with!(|first, middle, last| format!(&quot;{first} {middle} {last}&quot;));</code></pre>
<p>This expands to the same thing as above. Take a look at the <code>with!</code> docs for more info, and the corresponding macros <code>update!</code>, <code>with_value!</code> and <code>update_value!</code>.</p>
<h2 id="making-signals-depend-on-each-other"><a class="header" href="#making-signals-depend-on-each-other">Making signals depend on each other</a></h2>
<p>Often people ask about situations in which some signal needs to change based on some other signal’s value. There are three good ways to do this, and one that’s less than ideal but okay under controlled circumstances.</p>
<h3 id="good-options"><a class="header" href="#good-options">Good Options</a></h3>
<p><strong>1) B is a function of A.</strong> Create a signal for A and a derived signal or memo for B.</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(1);
let derived_signal_double_count = move || count() * 2;
let memoized_double_count = create_memo(move |_| count() * 2);</code></pre>
<blockquote>
<p>For guidance on whether to use a derived signal or a memo, see the docs for <a href="https://docs.rs/leptos/latest/leptos/fn.create_memo.html"><code>create_memo</code></a></p>
</blockquote>
<p><strong>2) C is a function of A and some other thing B.</strong> Create signals for A and B and a derived signal or memo for C.</p>
<pre><code class="language-rust">let (first_name, set_first_name) = create_signal(&quot;Bridget&quot;.to_string());
let (last_name, set_last_name) = create_signal(&quot;Jones&quot;.to_string());
let full_name = move || with!(|first_name, last_name| format!(&quot;{first_name} {last_name}&quot;));</code></pre>
<p><strong>3) A and B are independent signals, but sometimes updated at the same time.</strong> When you make the call to update A, make a separate call to update B.</p>
<pre><code class="language-rust">let (age, set_age) = create_signal(32);
let (favorite_number, set_favorite_number) = create_signal(42);
// use this to handle a click on a `Clear` button
let clear_handler = move |_| {
  set_age(0);
  set_favorite_number(0);
};</code></pre>
<h3 id="if-you-really-must"><a class="header" href="#if-you-really-must">If you really must...</a></h3>
<p><strong>4) Create an effect to write to B whenever A changes.</strong> This is officially discouraged, for several reasons:
a) It will always be less efficient, as it means every time A updates you do two full trips through the reactive process. (You set A, which causes the effect to run, as well as any other effects that depend on A. Then you set B, which causes any effects that depend on B to run.)
b) It increases your chances of accidentally creating things like infinite loops or over-re-running effects. This is the kind of ping-ponging, reactive spaghetti code that was common in the early 2010s and that we try to avoid with things like read-write segregation and discouraging writing to signals from effects.</p>
<p>In most situations, it’s best to rewrite things such that there’s a clear, top-down data flow based on derived signals or memos. But this isn’t the end of the world.</p>
<blockquote>
<p>I’m intentionally not providing an example here. Read the <a href="https://docs.rs/leptos/latest/leptos/fn.create_effect.html"><code>create_effect</code></a> docs to figure out how this would work.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="responding-to-changes-with-create_effect"><a class="header" href="#responding-to-changes-with-create_effect">Responding to Changes with <code>create_effect</code></a></h1>
<p>We’ve made it this far without having mentioned half of the reactive system: effects.</p>
<p>Reactivity works in two halves: updating individual reactive values (“signals”) notifies the pieces of code that depend on them (“effects”) that they need to run again. These two halves of the reactive system are inter-dependent. Without effects, signals can change within the reactive system but never be observed in a way that interacts with the outside world. Without signals, effects run once but never again, as there’s no observable value to subscribe to. Effects are quite literally “side effects” of the reactive system: they exist to synchronize the reactive system with the non-reactive world outside it.</p>
<p>Hidden behind the whole reactive DOM renderer that we’ve seen so far is a function called <code>create_effect</code>.</p>
<p><a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_effect.html"><code>create_effect</code></a> takes a function as its argument. It immediately runs the function. If you access any reactive signal inside that function, it registers the fact that the effect depends on that signal with the reactive runtime. Whenever one of the signals that the effect depends on changes, the effect runs again.</p>
<pre><code class="language-rust">let (a, set_a) = create_signal(0);
let (b, set_b) = create_signal(0);

create_effect(move |_| {
  // immediately prints &quot;Value: 0&quot; and subscribes to `a`
  log::debug!(&quot;Value: {}&quot;, a());
});</code></pre>
<p>The effect function is called with an argument containing whatever value it returned the last time it ran. On the initial run, this is <code>None</code>.</p>
<p>By default, effects <strong>do not run on the server</strong>. This means you can call browser-specific APIs within the effect function without causing issues. If you need an effect to run on the server, use <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_isomorphic_effect.html"><code>create_isomorphic_effect</code></a>.</p>
<h2 id="autotracking-and-dynamic-dependencies"><a class="header" href="#autotracking-and-dynamic-dependencies">Autotracking and Dynamic Dependencies</a></h2>
<p>If you’re familiar with a framework like React, you might notice one key difference. React and similar frameworks typically require you to pass a “dependency array,” an explicit set of variables that determine when the effect should rerun.</p>
<p>Because Leptos comes from the tradition of synchronous reactive programming, we don’t need this explicit dependency list. Instead, we automatically track dependencies depending on which signals are accessed within the effect.</p>
<p>This has two effects (no pun intended). Dependencies are:</p>
<ol>
<li><strong>Automatic</strong>: You don’t need to maintain a dependency list, or worry about what should or shouldn’t be included. The framework simply tracks which signals might cause the effect to rerun, and handles it for you.</li>
<li><strong>Dynamic</strong>: The dependency list is cleared and updated every time the effect runs. If your effect contains a conditional (for example), only signals that are used in the current branch are tracked. This means that effects rerun the absolute minimum number of times.</li>
</ol>
<blockquote>
<p>If this sounds like magic, and if you want a deep dive into how automatic dependency tracking works, <a href="https://www.youtube.com/watch?v=GWB3vTWeLd4">check out this video</a>. (Apologies for the low volume!)</p>
</blockquote>
<h2 id="effects-as-zero-cost-ish-abstraction"><a class="header" href="#effects-as-zero-cost-ish-abstraction">Effects as Zero-Cost-ish Abstraction</a></h2>
<p>While they’re not a “zero-cost abstraction” in the most technical sense—they require some additional memory use, exist at runtime, etc.—at a higher level, from the perspective of whatever expensive API calls or other work you’re doing within them, effects are a zero-cost abstraction. They rerun the absolute minimum number of times necessary, given how you’ve described them.</p>
<p>Imagine that I’m creating some kind of chat software, and I want people to be able to display their full name, or just their first name, and to notify the server whenever their name changes:</p>
<pre><code class="language-rust">let (first, set_first) = create_signal(String::new());
let (last, set_last) = create_signal(String::new());
let (use_last, set_use_last) = create_signal(true);

// this will add the name to the log
// any time one of the source signals changes
create_effect(move |_| {
    log(
        if use_last() {
            format!(&quot;{} {}&quot;, first(), last())
        } else {
            first()
        },
    )
});</code></pre>
<p>If <code>use_last</code> is <code>true</code>, effect should rerun whenever <code>first</code>, <code>last</code>, or <code>use_last</code> changes. But if I toggle <code>use_last</code> to <code>false</code>, a change in <code>last</code> will never cause the full name to change. In fact, <code>last</code> will be removed from the dependency list until <code>use_last</code> toggles again. This saves us from sending multiple unnecessary requests to the API if I change <code>last</code> multiple times while <code>use_last</code> is still <code>false</code>.</p>
<h2 id="to-create_effect-or-not-to-create_effect"><a class="header" href="#to-create_effect-or-not-to-create_effect">To <code>create_effect</code>, or not to <code>create_effect</code>?</a></h2>
<p>Effects are intended to run <em>side-effects</em> of the system, not to synchronize state <em>within</em> the system. In other words: don’t write to signals within effects.</p>
<p>If you need to define a signal that depends on the value of other signals, use a derived signal or <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_memo.html"><code>create_memo</code></a>.</p>
<p>If you need to synchronize some reactive value with the non-reactive world outside—like a web API, the console, the filesystem, or the DOM—create an effect.</p>
<blockquote>
<p>If you’re curious for more information about when you should and shouldn’t use <code>create_effect</code>, <a href="https://www.youtube.com/watch?v=aQOFJQ2JkvQ">check out this video</a> for a more in-depth consideration!</p>
</blockquote>
<h2 id="effects-and-rendering"><a class="header" href="#effects-and-rendering">Effects and Rendering</a></h2>
<p>We’ve managed to get this far without mentioning effects because they’re built into the Leptos DOM renderer. We’ve seen that you can create a signal and pass it into the <code>view</code> macro, and it will update the relevant DOM node whenever the signal changes:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);

view! {
    &lt;p&gt;{count}&lt;/p&gt;
}</code></pre>
<p>This works because the framework essentially creates an effect wrapping this update. You can imagine Leptos translating this view into something like this:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);

// create a DOM element
let p = create_element(&quot;p&quot;);

// create an effect to reactively update the text
create_effect(move |prev_value| {
    // first, access the signal’s value and convert it to a string
    let text = count().to_string();

    // if this is different from the previous value, update the node
    if prev_value != Some(text) {
        p.set_text_content(&amp;text);
    }

    // return this value so we can memoize the next update
    text
});</code></pre>
<p>Every time <code>count</code> is updated, this effect wil rerun. This is what allows reactive, fine-grained updates to the DOM.</p>
<h2 id="explicit-cancelable-tracking-with-watch"><a class="header" href="#explicit-cancelable-tracking-with-watch">Explicit, Cancelable Tracking with <code>watch</code></a></h2>
<p>In addition to <code>create_effect</code>, Leptos provides a <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.watch.html"><code>watch</code></a> function, which can be used for two main purposes:</p>
<ol>
<li>Separating tracking and responding to changes by explicitly passing in a set of values to track.</li>
<li>Canceling tracking by calling a stop function.</li>
</ol>
<p>Like <code>create_resource</code>, <code>watch</code> takes a first argument, which is reactively tracked, and a second, which is not. Whenever a reactive value in its <code>deps</code> argument is changed, the <code>callback</code> is run. <code>watch</code> returns a function that can be called to stop tracking the dependencies.</p>
<pre><code class="language-rust">let (num, set_num) = create_signal(0);

let stop = watch(
    move || num.get(),
    move |num, prev_num, _| {
        log::debug!(&quot;Number: {}; Prev: {:?}&quot;, num, prev_num);
    },
    false,
);

set_num.set(1); // &gt; &quot;Number: 1; Prev: Some(0)&quot;

stop(); // stop watching

set_num.set(2); // (nothing happens)</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/14-effect-0-5-d6hkch?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/14-effect-0-5-d6hkch?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::html::Input;
use leptos::*;

#[derive(Copy, Clone)]
struct LogContext(RwSignal&lt;Vec&lt;String&gt;&gt;);

#[component]
fn App() -&gt; impl IntoView {
    // Just making a visible log here
    // You can ignore this...
    let log = create_rw_signal::&lt;Vec&lt;String&gt;&gt;(vec![]);
    let logged = move || log().join(&quot;\n&quot;);

    // the newtype pattern isn't *necessary* here but is a good practice
    // it avoids confusion with other possible future `RwSignal&lt;Vec&lt;String&gt;&gt;` contexts
    // and makes it easier to refer to it
    provide_context(LogContext(log));

    view! {
        &lt;CreateAnEffect/&gt;
        &lt;pre&gt;{logged}&lt;/pre&gt;
    }
}

#[component]
fn CreateAnEffect() -&gt; impl IntoView {
    let (first, set_first) = create_signal(String::new());
    let (last, set_last) = create_signal(String::new());
    let (use_last, set_use_last) = create_signal(true);

    // this will add the name to the log
    // any time one of the source signals changes
    create_effect(move |_| {
        log(if use_last() {
            with!(|first, last| format!(&quot;{first} {last}&quot;))
        } else {
            first()
        })
    });

    view! {
        &lt;h1&gt;
            &lt;code&gt;&quot;create_effect&quot;&lt;/code&gt;
            &quot; Version&quot;
        &lt;/h1&gt;
        &lt;form&gt;
            &lt;label&gt;
                &quot;First Name&quot;
                &lt;input
                    type=&quot;text&quot;
                    name=&quot;first&quot;
                    prop:value=first
                    on:change=move |ev| set_first(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Last Name&quot;
                &lt;input
                    type=&quot;text&quot;
                    name=&quot;last&quot;
                    prop:value=last
                    on:change=move |ev| set_last(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot;
                &lt;input
                    type=&quot;checkbox&quot;
                    name=&quot;use_last&quot;
                    prop:checked=use_last
                    on:change=move |ev| set_use_last(event_target_checked(&amp;ev))
                /&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn ManualVersion() -&gt; impl IntoView {
    let first = create_node_ref::&lt;Input&gt;();
    let last = create_node_ref::&lt;Input&gt;();
    let use_last = create_node_ref::&lt;Input&gt;();

    let mut prev_name = String::new();
    let on_change = move |_| {
        log(&quot;      listener&quot;);
        let first = first.get().unwrap();
        let last = last.get().unwrap();
        let use_last = use_last.get().unwrap();
        let this_one = if use_last.checked() {
            format!(&quot;{} {}&quot;, first.value(), last.value())
        } else {
            first.value()
        };

        if this_one != prev_name {
            log(&amp;this_one);
            prev_name = this_one;
        }
    };

    view! {
        &lt;h1&gt;&quot;Manual Version&quot;&lt;/h1&gt;
        &lt;form on:change=on_change&gt;
            &lt;label&gt;&quot;First Name&quot; &lt;input type=&quot;text&quot; name=&quot;first&quot; node_ref=first/&gt;&lt;/label&gt;
            &lt;label&gt;&quot;Last Name&quot; &lt;input type=&quot;text&quot; name=&quot;last&quot; node_ref=last/&gt;&lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot; &lt;input type=&quot;checkbox&quot; name=&quot;use_last&quot; checked node_ref=use_last/&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn EffectVsDerivedSignal() -&gt; impl IntoView {
    let (my_value, set_my_value) = create_signal(String::new());
    // Don't do this.
    /*let (my_optional_value, set_optional_my_value) = create_signal(Option::&lt;String&gt;::None);

    create_effect(move |_| {
        if !my_value.get().is_empty() {
            set_optional_my_value(Some(my_value.get()));
        } else {
            set_optional_my_value(None);
        }
    });*/

    // Do this
    let my_optional_value =
        move || (!my_value.with(String::is_empty)).then(|| Some(my_value.get()));

    view! {
        &lt;input prop:value=my_value on:input=move |ev| set_my_value(event_target_value(&amp;ev))/&gt;

        &lt;p&gt;
            &lt;code&gt;&quot;my_optional_value&quot;&lt;/code&gt;
            &quot; is &quot;
            &lt;code&gt;
                &lt;Show when=move || my_optional_value().is_some() fallback=|| view! { &quot;None&quot; }&gt;
                    &quot;Some(\&quot;&quot;
                    {my_optional_value().unwrap()}
                    &quot;\&quot;)&quot;
                &lt;/Show&gt;
            &lt;/code&gt;
        &lt;/p&gt;
    }
}

#[component]
pub fn Show&lt;F, W, IV&gt;(
    /// The components Show wraps
    children: Box&lt;dyn Fn() -&gt; Fragment&gt;,
    /// A closure that returns a bool that determines whether this thing runs
    when: W,
    /// A closure that returns what gets rendered if the when statement is false
    fallback: F,
) -&gt; impl IntoView
where
    W: Fn() -&gt; bool + 'static,
    F: Fn() -&gt; IV + 'static,
    IV: IntoView,
{
    let memoized_when = create_memo(move |_| when());

    move || match memoized_when.get() {
        true =&gt; children().into_view(),
        false =&gt; fallback().into_view(),
    }
}

fn log(msg: impl std::fmt::Display) {
    let log = use_context::&lt;LogContext&gt;().unwrap().0;
    log.update(|log| log.push(msg.to_string()));
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-reactivity-and-functions"><a class="header" href="#interlude-reactivity-and-functions">Interlude: Reactivity and Functions</a></h1>
<p>One of our core contributors said to me recently: “I never used closures this often
until I started using Leptos.” And it’s true. Closures are at the heart of any Leptos
application. It sometimes looks a little silly:</p>
<pre><code class="language-rust">// a signal holds a value, and can be updated
let (count, set_count) = create_signal(0);

// a derived signal is a function that accesses other signals
let double_count = move || count() * 2;
let count_is_odd = move || count() &amp; 1 == 1;
let text = move || if count_is_odd() {
    &quot;odd&quot;
} else {
    &quot;even&quot;
};

// an effect automatically tracks the signals it depends on
// and reruns when they change
create_effect(move |_| {
    logging::log!(&quot;text = {}&quot;, text());
});

view! {
    &lt;p&gt;{move || text().to_uppercase()}&lt;/p&gt;
}</code></pre>
<p>Closures, closures everywhere!</p>
<p>But why?</p>
<h2 id="functions-and-ui-frameworks"><a class="header" href="#functions-and-ui-frameworks">Functions and UI Frameworks</a></h2>
<p>Functions are at the heart of every UI framework. And this makes perfect sense. Creating a user interface is basically divided into two phases:</p>
<ol>
<li>initial rendering</li>
<li>updates</li>
</ol>
<p>In a web framework, the framework does some kind of initial rendering. Then it hands control back over to the browser. When certain events fire (like a mouse click) or asynchronous tasks finish (like an HTTP request finishing), the browser wakes the framework back up to update something. The framework runs some kind of code to update your user interface, and goes back asleep until the browser wakes it up again.</p>
<p>The key phrase here is “runs some kind of code.” The natural way to “run some kind of code” at an arbitrary point in time—in Rust or in any other programming language—is to call a function. And in fact every UI framework is based on rerunning some kind of function over and over:</p>
<ol>
<li>virtual DOM (VDOM) frameworks like React, Yew, or Dioxus rerun a component or render function over and over, to generate a virtual DOM tree that can be reconciled with the previous result to patch the DOM</li>
<li>compiled frameworks like Angular and Svelte divide your component templates into “create” and “update” functions, rerunning the update function when they detect a change to the component’s state</li>
<li>in fine-grained reactive frameworks like SolidJS, Sycamore, or Leptos, <em>you</em> define the functions that rerun</li>
</ol>
<p>That’s what all our components are doing.</p>
<p>Take our typical <code>&lt;SimpleCounter/&gt;</code> example in its simplest form:</p>
<pre><code class="language-rust">#[component]
pub fn SimpleCounter() -&gt; impl IntoView {
    let (value, set_value) = create_signal(0);

    let increment = move |_| set_value.update(|value| *value += 1);

    view! {
        &lt;button on:click=increment&gt;
            {value}
        &lt;/button&gt;
    }
}</code></pre>
<p>The <code>SimpleCounter</code> function itself runs once. The <code>value</code> signal is created once. The framework hands off the <code>increment</code> function to the browser as an event listener. When you click the button, the browser calls <code>increment</code>, which updates <code>value</code> via <code>set_value</code>. And that updates the single text node represented in our view by <code>{value}</code>.</p>
<p>Closures are key to reactivity. They provide the framework with the ability to rerun the smallest possible unit of your application in response to a change.</p>
<p>So remember two things:</p>
<ol>
<li>Your component function is a setup function, not a render function: it only runs once.</li>
<li>For values in your view template to be reactive, they must be functions: either signals (which implement the <code>Fn</code> traits) or closures.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-your-components"><a class="header" href="#testing-your-components">Testing Your Components</a></h1>
<p>Testing user interfaces can be relatively tricky, but really important. This article
will discuss a couple principles and approaches for testing a Leptos app.</p>
<h2 id="1-test-business-logic-with-ordinary-rust-tests"><a class="header" href="#1-test-business-logic-with-ordinary-rust-tests">1. Test business logic with ordinary Rust tests</a></h2>
<p>In many cases, it makes sense to pull the logic out of your components and test
it separately. For some simple components, there’s no particular logic to test, but
for many it’s worth using a testable wrapping type and implementing the logic in
ordinary Rust <code>impl</code> blocks.</p>
<p>For example, instead of embedding logic in a component directly like this:</p>
<pre><code class="language-rust">#[component]
pub fn TodoApp() -&gt; impl IntoView {
    let (todos, set_todos) = create_signal(vec![Todo { /* ... */ }]);
    // ⚠️ this is hard to test because it's embedded in the component
    let num_remaining = move || todos.with(|todos| {
        todos.iter().filter(|todo| !todo.completed).sum()
    });
}</code></pre>
<p>You could pull that logic out into a separate data structure and test it:</p>
<pre><code class="language-rust">pub struct Todos(Vec&lt;Todo&gt;);

impl Todos {
    pub fn num_remaining(&amp;self) -&gt; usize {
        self.0.iter().filter(|todo| !todo.completed).sum()
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_remaining() {
        // ...
    }
}

#[component]
pub fn TodoApp() -&gt; impl IntoView {
    let (todos, set_todos) = create_signal(Todos(vec![Todo { /* ... */ }]));
    // ✅ this has a test associated with it
    let num_remaining = move || todos.with(Todos::num_remaining);
}</code></pre>
<p>In general, the less of your logic is wrapped into your components themselves, the
more idiomatic your code will feel and the easier it will be to test.</p>
<h2 id="2-test-components-with-end-to-end-e2e-testing"><a class="header" href="#2-test-components-with-end-to-end-e2e-testing">2. Test components with end-to-end (<code>e2e</code>) testing</a></h2>
<p>Our <a href="https://github.com/leptos-rs/leptos/tree/main/examples"><code>examples</code></a> directory has several examples with extensive end-to-end testing, using different testing tools.</p>
<p>The easiest way to see how to use these is to take a look at the test examples themselves:</p>
<h3 id="wasm-bindgen-test-with-counter"><a class="header" href="#wasm-bindgen-test-with-counter"><code>wasm-bindgen-test</code> with <a href="https://github.com/leptos-rs/leptos/blob/main/examples/counter/tests/web.rs"><code>counter</code></a></a></h3>
<p>This is a fairly simple manual testing setup that uses the <a href="https://rustwasm.github.io/wasm-pack/book/commands/test.html"><code>wasm-pack test</code></a> command.</p>
<h4 id="sample-test"><a class="header" href="#sample-test">Sample Test</a></h4>
<pre><code class="language-rust">#[wasm_bindgen_test]
fn clear() {
    let document = leptos::document();
    let test_wrapper = document.create_element(&quot;section&quot;).unwrap();
    let _ = document.body().unwrap().append_child(&amp;test_wrapper);

    mount_to(
        test_wrapper.clone().unchecked_into(),
        || view! { &lt;SimpleCounter initial_value=10 step=1/&gt; },
    );

    let div = test_wrapper.query_selector(&quot;div&quot;).unwrap().unwrap();
    let clear = test_wrapper
        .query_selector(&quot;button&quot;)
        .unwrap()
        .unwrap()
        .unchecked_into::&lt;web_sys::HtmlElement&gt;();

    clear.click();

assert_eq!(
    div.outer_html(),
    // here we spawn a mini reactive system to render the test case
    run_scope(create_runtime(), || {
        // it's as if we're creating it with a value of 0, right?
        let (value, set_value) = create_signal(0);

        // we can remove the event listeners because they're not rendered to HTML
        view! {
            &lt;div&gt;
                &lt;button&gt;&quot;Clear&quot;&lt;/button&gt;
                &lt;button&gt;&quot;-1&quot;&lt;/button&gt;
                &lt;span&gt;&quot;Value: &quot; {value} &quot;!&quot;&lt;/span&gt;
                &lt;button&gt;&quot;+1&quot;&lt;/button&gt;
            &lt;/div&gt;
        }
        // the view returned an HtmlElement&lt;Div&gt;, which is a smart pointer for
        // a DOM element. So we can still just call .outer_html()
        .outer_html()
    })
);
}</code></pre>
<h3 id="wasm-bindgen-test-with-counters_stable"><a class="header" href="#wasm-bindgen-test-with-counters_stable"><a href="https://github.com/leptos-rs/leptos/tree/main/examples/counters_stable/tests/web"><code>wasm-bindgen-test</code> with <code>counters_stable</code></a></a></h3>
<p>This more developed test suite uses a system of fixtures to refactor the manual DOM manipulation of the <code>counter</code> tests and easily test a wide range of cases.</p>
<h4 id="sample-test-1"><a class="header" href="#sample-test-1">Sample Test</a></h4>
<pre><code class="language-rust">use super::*;
use crate::counters_page as ui;
use pretty_assertions::assert_eq;

#[wasm_bindgen_test]
fn should_increase_the_total_count() {
    // Given
    ui::view_counters();
    ui::add_counter();

    // When
    ui::increment_counter(1);
    ui::increment_counter(1);
    ui::increment_counter(1);

    // Then
    assert_eq!(ui::total(), 3);
}</code></pre>
<h3 id="playwright-with-counters_stable"><a class="header" href="#playwright-with-counters_stable"><a href="https://github.com/leptos-rs/leptos/tree/main/examples/counters_stable/e2e">Playwright with <code>counters_stable</code></a></a></h3>
<p>These tests use the common JavaScript testing tool Playwright to run end-to-end tests on the same example, using a library and testing approach familiar to may who have done frontend development before.</p>
<h4 id="sample-test-2"><a class="header" href="#sample-test-2">Sample Test</a></h4>
<pre><code class="language-js">import { test, expect } from &quot;@playwright/test&quot;;
import { CountersPage } from &quot;./fixtures/counters_page&quot;;

test.describe(&quot;Increment Count&quot;, () =&gt; {
  test(&quot;should increase the total count&quot;, async ({ page }) =&gt; {
    const ui = new CountersPage(page);
    await ui.goto();
    await ui.addCounter();

    await ui.incrementCount();
    await ui.incrementCount();
    await ui.incrementCount();

    await expect(ui.total).toHaveText(&quot;3&quot;);
  });
});
</code></pre>
<h3 id="gherkincucumber-tests-with-todo_app_sqlite"><a class="header" href="#gherkincucumber-tests-with-todo_app_sqlite"><a href="https://github.com/leptos-rs/leptos/blob/main/examples/todo_app_sqlite/e2e/README.md">Gherkin/Cucumber Tests with <code>todo_app_sqlite</code></a></a></h3>
<p>You can integrate any testing tool you’d like into this flow. This example uses Cucumber, a testing framework based on natural language.</p>
<pre><code>@add_todo
Feature: Add Todo

    Background:
        Given I see the app

    @add_todo-see
    Scenario: Should see the todo
        Given I set the todo as Buy Bread
        When I click the Add button
        Then I see the todo named Buy Bread

    # @allow.skipped
    @add_todo-style
    Scenario: Should see the pending todo
        When I add a todo as Buy Oranges
        Then I see the pending todo
</code></pre>
<p>The definitions for these actions are defined in Rust code.</p>
<pre><code class="language-rust">use crate::fixtures::{action, world::AppWorld};
use anyhow::{Ok, Result};
use cucumber::{given, when};

#[given(&quot;I see the app&quot;)]
#[when(&quot;I open the app&quot;)]
async fn i_open_the_app(world: &amp;mut AppWorld) -&gt; Result&lt;()&gt; {
    let client = &amp;world.client;
    action::goto_path(client, &quot;&quot;).await?;

    Ok(())
}

#[given(regex = &quot;^I add a todo as (.*)$&quot;)]
#[when(regex = &quot;^I add a todo as (.*)$&quot;)]
async fn i_add_a_todo_titled(world: &amp;mut AppWorld, text: String) -&gt; Result&lt;()&gt; {
    let client = &amp;world.client;
    action::add_todo(client, text.as_str()).await?;

    Ok(())
}

// etc.</code></pre>
<h3 id="learning-more"><a class="header" href="#learning-more">Learning More</a></h3>
<p>Feel free to check out the CI setup in the Leptos repo to learn more about how to use these tools in your own application. All of these testing methods are run regularly against actual Leptos example apps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-async"><a class="header" href="#working-with-async">Working with <code>async</code></a></h1>
<p>So far we’ve only been working with synchronous users interfaces: You provide some input,
the app immediately processes it and updates the interface. This is great, but is a tiny
subset of what web applications do. In particular, most web apps have to deal with some kind of asynchronous data loading, usually loading something from an API.</p>
<p>Asynchronous data is notoriously hard to integrate with the synchronous parts of your code. Leptos provides a cross-platform <a href="https://docs.rs/leptos/latest/leptos/fn.spawn_local.html"><code>spawn_local</code></a> function that makes it easy to run a <code>Future</code>, but there’s much more to it than that.</p>
<p>In this chapter, we’ll see how Leptos helps smooth out that process for you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-data-with-resources"><a class="header" href="#loading-data-with-resources">Loading Data with Resources</a></h1>
<p>A <a href="https://docs.rs/leptos/latest/leptos/struct.Resource.html">Resource</a> is a reactive data structure that reflects the current state of an asynchronous task, allowing you to integrate asynchronous <code>Future</code>s into the synchronous reactive system. Rather than waiting for its data to load with <code>.await</code>, you transform the <code>Future</code> into a signal that returns <code>Some(T)</code> if it has resolved, and <code>None</code> if it’s still pending.</p>
<p>You do this by using the <a href="https://docs.rs/leptos/latest/leptos/fn.create_resource.html"><code>create_resource</code></a> function. This takes two arguments:</p>
<ol>
<li>a source signal, which will generate a new <code>Future</code> whenever it changes</li>
<li>a fetcher function, which takes the data from that signal and returns a <code>Future</code></li>
</ol>
<p>Here’s an example</p>
<pre><code class="language-rust">// our source signal: some synchronous, local state
let (count, set_count) = create_signal(0);

// our resource
let async_data = create_resource(
    count,
    // every time `count` changes, this will run
    |value| async move {
        logging::log!(&quot;loading data from API&quot;);
        load_data(value).await
    },
);</code></pre>
<p>To create a resource that simply runs once, you can pass a non-reactive, empty source signal:</p>
<pre><code class="language-rust">let once = create_resource(|| (), |_| async move { load_data().await });</code></pre>
<p>To access the value you can use <code>.get()</code> or <code>.with(|data| /* */)</code>. These work just like <code>.get()</code> and <code>.with()</code> on a signal—<code>get</code> clones the value and returns it, <code>with</code> applies a closure to it—but for any <code>Resource&lt;_, T&gt;</code>, they always return <code>Option&lt;T&gt;</code>, not <code>T</code>: because it’s always possible that your resource is still loading.</p>
<p>So, you can show the current state of a resource in your view:</p>
<pre><code class="language-rust">let once = create_resource(|| (), |_| async move { load_data().await });
view! {
    &lt;h1&gt;&quot;My Data&quot;&lt;/h1&gt;
    {move || match once.get() {
        None =&gt; view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }.into_view(),
        Some(data) =&gt; view! { &lt;ShowData data/&gt; }.into_view()
    }}
}</code></pre>
<p>Resources also provide a <code>refetch()</code> method that allows you to manually reload the data (for example, in response to a button click) and a <code>loading()</code> method that returns a <code>ReadSignal&lt;bool&gt;</code> indicating whether the resource is currently loading or not.</p>
<p><a href="https://codesandbox.io/p/sandbox/10-resources-0-5-x6h5j6?file=%2Fsrc%2Fmain.rs%3A2%2C3">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/10-resources-0-5-9jq86q?file=%2Fsrc%2Fmain.rs%3A2%2C3" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use gloo_timers::future::TimeoutFuture;
use leptos::*;

// Here we define an async function
// This could be anything: a network request, database read, etc.
// Here, we just multiply a number by 10
async fn load_data(value: i32) -&gt; i32 {
    // fake a one-second delay
    TimeoutFuture::new(1_000).await;
    value * 10
}

#[component]
fn App() -&gt; impl IntoView {
    // this count is our synchronous, local state
    let (count, set_count) = create_signal(0);

    // create_resource takes two arguments after its scope
    let async_data = create_resource(
        // the first is the &quot;source signal&quot;
        count,
        // the second is the loader
        // it takes the source signal's value as its argument
        // and does some async work
        |value| async move { load_data(value).await },
    );
    // whenever the source signal changes, the loader reloads

    // you can also create resources that only load once
    // just return the unit type () from the source signal
    // that doesn't depend on anything: we just load it once
    let stable = create_resource(|| (), |_| async move { load_data(1).await });

    // we can access the resource values with .get()
    // this will reactively return None before the Future has resolved
    // and update to Some(T) when it has resolved
    let async_result = move || {
        async_data
            .get()
            .map(|value| format!(&quot;Server returned {value:?}&quot;))
            // This loading state will only show before the first load
            .unwrap_or_else(|| &quot;Loading...&quot;.into())
    };

    // the resource's loading() method gives us a
    // signal to indicate whether it's currently loading
    let loading = async_data.loading();
    let is_loading = move || if loading() { &quot;Loading...&quot; } else { &quot;Idle.&quot; };

    view! {
        &lt;button
            on:click=move |_| {
                set_count.update(|n| *n += 1);
            }
        &gt;
            &quot;Click me&quot;
        &lt;/button&gt;
        &lt;p&gt;
            &lt;code&gt;&quot;stable&quot;&lt;/code&gt;&quot;: &quot; {move || stable.get()}
        &lt;/p&gt;
        &lt;p&gt;
            &lt;code&gt;&quot;count&quot;&lt;/code&gt;&quot;: &quot; {count}
        &lt;/p&gt;
        &lt;p&gt;
            &lt;code&gt;&quot;async_value&quot;&lt;/code&gt;&quot;: &quot;
            {async_result}
            &lt;br/&gt;
            {is_loading}
        &lt;/p&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suspense"><a class="header" href="#suspense"><code>&lt;Suspense/&gt;</code></a></h1>
<p>In the previous chapter, we showed how you can create a simple loading screen to show some fallback while a resource is loading.</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
let once = create_resource(count, |count| async move { load_a(count).await });

view! {
    &lt;h1&gt;&quot;My Data&quot;&lt;/h1&gt;
    {move || match once.get() {
        None =&gt; view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }.into_view(),
        Some(data) =&gt; view! { &lt;ShowData data/&gt; }.into_view()
    }}
}</code></pre>
<p>But what if we have two resources, and want to wait for both of them?</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
let (count2, set_count2) = create_signal(0);
let a = create_resource(count, |count| async move { load_a(count).await });
let b = create_resource(count2, |count| async move { load_b(count).await });

view! {
    &lt;h1&gt;&quot;My Data&quot;&lt;/h1&gt;
    {move || match (a.get(), b.get()) {
        (Some(a), Some(b)) =&gt; view! {
            &lt;ShowA a/&gt;
            &lt;ShowA b/&gt;
        }.into_view(),
        _ =&gt; view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }.into_view()
    }}
}</code></pre>
<p>That’s not <em>so</em> bad, but it’s kind of annoying. What if we could invert the flow of control?</p>
<p>The <a href="https://docs.rs/leptos/latest/leptos/fn.Suspense.html"><code>&lt;Suspense/&gt;</code></a> component lets us do exactly that. You give it a <code>fallback</code> prop and children, one or more of which usually involves reading from a resource. Reading from a resource “under” a <code>&lt;Suspense/&gt;</code> (i.e., in one of its children) registers that resource with the <code>&lt;Suspense/&gt;</code>. If it’s still waiting for resources to load, it shows the <code>fallback</code>. When they’ve all loaded, it shows the children.</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(0);
let (count2, set_count2) = create_signal(0);
let a = create_resource(count, |count| async move { load_a(count).await });
let b = create_resource(count2, |count| async move { load_b(count).await });

view! {
    &lt;h1&gt;&quot;My Data&quot;&lt;/h1&gt;
    &lt;Suspense
        fallback=move || view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }
    &gt;
        &lt;h2&gt;&quot;My Data&quot;&lt;/h2&gt;
        &lt;h3&gt;&quot;A&quot;&lt;/h3&gt;
        {move || {
            a.get()
                .map(|a| view! { &lt;ShowA a/&gt; })
        }}
        &lt;h3&gt;&quot;B&quot;&lt;/h3&gt;
        {move || {
            b.get()
                .map(|b| view! { &lt;ShowB b/&gt; })
        }}
    &lt;/Suspense&gt;
}</code></pre>
<p>Every time one of the resources is reloading, the <code>&quot;Loading...&quot;</code> fallback will show again.</p>
<p>This inversion of the flow of control makes it easier to add or remove individual resources, as you don’t need to handle the matching yourself. It also unlocks some massive performance improvements during server-side rendering, which we’ll talk about during a later chapter.</p>
<h2 id="await"><a class="header" href="#await"><code>&lt;Await/&gt;</code></a></h2>
<p>In you’re simply trying to wait for some <code>Future</code> to resolve before rendering, you may find the <code>&lt;Await/&gt;</code> component helpful in reducing boilerplate. <code>&lt;Await/&gt;</code> essentially combines a resource with the source argument <code>|| ()</code> with a <code>&lt;Suspense/&gt;</code> with no fallback.</p>
<p>In other words:</p>
<ol>
<li>It only polls the <code>Future</code> once, and does not respond to any reactive changes.</li>
<li>It does not render anything until the <code>Future</code> resolves.</li>
<li>After the <code>Future</code> resolves, it binds its data to whatever variable name you choose and then renders its children with that variable in scope.</li>
</ol>
<pre><code class="language-rust">async fn fetch_monkeys(monkey: i32) -&gt; i32 {
    // maybe this didn't need to be async
    monkey * 2
}
view! {
    &lt;Await
        // `future` provides the `Future` to be resolved
        future=|| fetch_monkeys(3)
        // the data is bound to whatever variable name you provide
        let:data
    &gt;
        // you receive the data by reference and can use it in your view here
        &lt;p&gt;{*data} &quot; little monkeys, jumping on the bed.&quot;&lt;/p&gt;
    &lt;/Await&gt;
}</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/11-suspense-0-5-qzpgqs?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/11-suspense-0-5-qzpgqs?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use gloo_timers::future::TimeoutFuture;
use leptos::*;

async fn important_api_call(name: String) -&gt; String {
    TimeoutFuture::new(1_000).await;
    name.to_ascii_uppercase()
}

#[component]
fn App() -&gt; impl IntoView {
    let (name, set_name) = create_signal(&quot;Bill&quot;.to_string());

    // this will reload every time `name` changes
    let async_data = create_resource(

        name,
        |name| async move { important_api_call(name).await },
    );

    view! {
        &lt;input
            on:input=move |ev| {
                set_name(event_target_value(&amp;ev));
            }
            prop:value=name
        /&gt;
        &lt;p&gt;&lt;code&gt;&quot;name:&quot;&lt;/code&gt; {name}&lt;/p&gt;
        &lt;Suspense
            // the fallback will show whenever a resource
            // read &quot;under&quot; the suspense is loading
            fallback=move || view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }
        &gt;
            // the children will be rendered once initially,
            // and then whenever any resources has been resolved
            &lt;p&gt;
                &quot;Your shouting name is &quot;
                {move || async_data.get()}
            &lt;/p&gt;
        &lt;/Suspense&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transition"><a class="header" href="#transition"><code>&lt;Transition/&gt;</code></a></h1>
<p>You’ll notice in the <code>&lt;Suspense/&gt;</code> example that if you keep reloading the data, it keeps flickering back to <code>&quot;Loading...&quot;</code>. Sometimes this is fine. For other times, there’s <a href="https://docs.rs/leptos/latest/leptos/fn.Transition.html"><code>&lt;Transition/&gt;</code></a>.</p>
<p><code>&lt;Transition/&gt;</code> behaves exactly the same as <code>&lt;Suspense/&gt;</code>, but instead of falling back every time, it only shows the fallback the first time. On all subsequent loads, it continues showing the old data until the new data are ready. This can be really handy to prevent the flickering effect, and to allow users to continue interacting with your application.</p>
<p>This example shows how you can create a simple tabbed contact list with <code>&lt;Transition/&gt;</code>. When you select a new tab, it continues showing the current contact until the new data loads. This can be a much better user experience than constantly falling back to a loading message.</p>
<p><a href="https://codesandbox.io/p/sandbox/12-transition-0-5-2jg5lz?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/12-transition-0-5-2jg5lz?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use gloo_timers::future::TimeoutFuture;
use leptos::*;

async fn important_api_call(id: usize) -&gt; String {
    TimeoutFuture::new(1_000).await;
    match id {
        0 =&gt; &quot;Alice&quot;,
        1 =&gt; &quot;Bob&quot;,
        2 =&gt; &quot;Carol&quot;,
        _ =&gt; &quot;User not found&quot;,
    }
    .to_string()
}

#[component]
fn App() -&gt; impl IntoView {
    let (tab, set_tab) = create_signal(0);

    // this will reload every time `tab` changes
    let user_data = create_resource(tab, |tab| async move { important_api_call(tab).await });

    view! {
        &lt;div class=&quot;buttons&quot;&gt;
            &lt;button
                on:click=move |_| set_tab(0)
                class:selected=move || tab() == 0
            &gt;
                &quot;Tab A&quot;
            &lt;/button&gt;
            &lt;button
                on:click=move |_| set_tab(1)
                class:selected=move || tab() == 1
            &gt;
                &quot;Tab B&quot;
            &lt;/button&gt;
            &lt;button
                on:click=move |_| set_tab(2)
                class:selected=move || tab() == 2
            &gt;
                &quot;Tab C&quot;
            &lt;/button&gt;
            {move || if user_data.loading().get() {
                &quot;Loading...&quot;
            } else {
                &quot;&quot;
            }}
        &lt;/div&gt;
        &lt;Transition
            // the fallback will show initially
            // on subsequent reloads, the current child will
            // continue showing
            fallback=move || view! { &lt;p&gt;&quot;Loading...&quot;&lt;/p&gt; }
        &gt;
            &lt;p&gt;
                {move || user_data.read()}
            &lt;/p&gt;
        &lt;/Transition&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutating-data-with-actions"><a class="header" href="#mutating-data-with-actions">Mutating Data with Actions</a></h1>
<p>We’ve talked about how to load <code>async</code> data with resources. Resources immediately load data and work closely with <code>&lt;Suspense/&gt;</code> and <code>&lt;Transition/&gt;</code> components to show whether data is loading in your app. But what if you just want to call some arbitrary <code>async</code> function and keep track of what it’s doing?</p>
<p>Well, you could always use <a href="https://docs.rs/leptos/latest/leptos/fn.spawn_local.html"><code>spawn_local</code></a>. This allows you to just spawn an <code>async</code> task in a synchronous environment by handing the <code>Future</code> off to the browser (or, on the server, Tokio or whatever other runtime you’re using). But how do you know if it’s still pending? Well, you could just set a signal to show whether it’s loading, and another one to show the result...</p>
<p>All of this is true. Or you could use the final <code>async</code> primitive: <a href="https://docs.rs/leptos/latest/leptos/fn.create_action.html"><code>create_action</code></a>.</p>
<p>Actions and resources seem similar, but they represent fundamentally different things. If you’re trying to load data by running an <code>async</code> function, either once or when some other value changes, you probably want to use <code>create_resource</code>. If you’re trying to occasionally run an <code>async</code> function in response to something like a user clicking a button, you probably want to use <code>create_action</code>.</p>
<p>Say we have some <code>async</code> function we want to run.</p>
<pre><code class="language-rust">async fn add_todo_request(new_title: &amp;str) -&gt; Uuid {
    /* do some stuff on the server to add a new todo */
}</code></pre>
<p><code>create_action</code> takes an <code>async</code> function that takes a reference to a single argument, which you could think of as its “input type.”</p>
<blockquote>
<p>The input is always a single type. If you want to pass in multiple arguments, you can do it with a struct or tuple.</p>
<pre><code class="language-rust">// if there's a single argument, just use that
let action1 = create_action(|input: &amp;String| {
   let input = input.clone();
   async move { todo!() }
});

// if there are no arguments, use the unit type `()`
let action2 = create_action(|input: &amp;()| async { todo!() });

// if there are multiple arguments, use a tuple
let action3 = create_action(
  |input: &amp;(usize, String)| async { todo!() }
);</code></pre>
<p>Because the action function takes a reference but the <code>Future</code> needs to have a <code>'static</code> lifetime, you’ll usually need to clone the value to pass it into the <code>Future</code>. This is admittedly awkward but it unlocks some powerful features like optimistic UI. We’ll see a little more about that in future chapters.</p>
</blockquote>
<p>So in this case, all we need to do to create an action is</p>
<pre><code class="language-rust">let add_todo_action = create_action(|input: &amp;String| {
    let input = input.to_owned();
    async move { add_todo_request(&amp;input).await }
});</code></pre>
<p>Rather than calling <code>add_todo_action</code> directly, we’ll call it with <code>.dispatch()</code>, as in</p>
<pre><code class="language-rust">add_todo_action.dispatch(&quot;Some value&quot;.to_string());</code></pre>
<p>You can do this from an event listener, a timeout, or anywhere; because <code>.dispatch()</code> isn’t an <code>async</code> function, it can be called from a synchronous context.</p>
<p>Actions provide access to a few signals that synchronize between the asynchronous action you’re calling and the synchronous reactive system:</p>
<pre><code class="language-rust">let submitted = add_todo_action.input(); // RwSignal&lt;Option&lt;String&gt;&gt;
let pending = add_todo_action.pending(); // ReadSignal&lt;bool&gt;
let todo_id = add_todo_action.value(); // RwSignal&lt;Option&lt;Uuid&gt;&gt;</code></pre>
<p>This makes it easy to track the current state of your request, show a loading indicator, or do “optimistic UI” based on the assumption that the submission will succeed.</p>
<pre><code class="language-rust">let input_ref = create_node_ref::&lt;Input&gt;();

view! {
    &lt;form
        on:submit=move |ev| {
            ev.prevent_default(); // don't reload the page...
            let input = input_ref.get().expect(&quot;input to exist&quot;);
            add_todo_action.dispatch(input.value());
        }
    &gt;
        &lt;label&gt;
            &quot;What do you need to do?&quot;
            &lt;input type=&quot;text&quot;
                node_ref=input_ref
            /&gt;
        &lt;/label&gt;
        &lt;button type=&quot;submit&quot;&gt;&quot;Add Todo&quot;&lt;/button&gt;
    &lt;/form&gt;
    // use our loading state
    &lt;p&gt;{move || pending().then(&quot;Loading...&quot;)}&lt;/p&gt;
}</code></pre>
<p>Now, there’s a chance this all seems a little over-complicated, or maybe too restricted. I wanted to include actions here, alongside resources, as the missing piece of the puzzle. In a real Leptos app, you’ll actually most often use actions alongside server functions, <a href="https://docs.rs/leptos/latest/leptos/fn.create_server_action.html"><code>create_server_action</code></a>, and the <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.ActionForm.html"><code>&lt;ActionForm/&gt;</code></a> component to create really powerful progressively-enhanced forms. So if this primitive seems useless to you... Don’t worry! Maybe it will make sense later. (Or check out our <a href="https://github.com/leptos-rs/leptos/blob/main/examples/todo_app_sqlite/src/todo.rs"><code>todo_app_sqlite</code></a> example now.)</p>
<p><a href="https://codesandbox.io/p/sandbox/13-actions-0-5-8xk35v?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/13-actions-0-5-8xk35v?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use gloo_timers::future::TimeoutFuture;
use leptos::{html::Input, *};
use uuid::Uuid;

// Here we define an async function
// This could be anything: a network request, database read, etc.
// Think of it as a mutation: some imperative async action you run,
// whereas a resource would be some async data you load
async fn add_todo(text: &amp;str) -&gt; Uuid {
    _ = text;
    // fake a one-second delay
    TimeoutFuture::new(1_000).await;
    // pretend this is a post ID or something
    Uuid::new_v4()
}

#[component]
fn App() -&gt; impl IntoView {
    // an action takes an async function with single argument
    // it can be a simple type, a struct, or ()
    let add_todo = create_action(|input: &amp;String| {
        // the input is a reference, but we need the Future to own it
        // this is important: we need to clone and move into the Future
        // so it has a 'static lifetime
        let input = input.to_owned();
        async move { add_todo(&amp;input).await }
    });

    // actions provide a bunch of synchronous, reactive variables
    // that tell us different things about the state of the action
    let submitted = add_todo.input();
    let pending = add_todo.pending();
    let todo_id = add_todo.value();

    let input_ref = create_node_ref::&lt;Input&gt;();

    view! {
        &lt;form
            on:submit=move |ev| {
                ev.prevent_default(); // don't reload the page...
                let input = input_ref.get().expect(&quot;input to exist&quot;);
                add_todo.dispatch(input.value());
            }
        &gt;
            &lt;label&gt;
                &quot;What do you need to do?&quot;
                &lt;input type=&quot;text&quot;
                    node_ref=input_ref
                /&gt;
            &lt;/label&gt;
            &lt;button type=&quot;submit&quot;&gt;&quot;Add Todo&quot;&lt;/button&gt;
        &lt;/form&gt;
        &lt;p&gt;{move || pending().then(|| &quot;Loading...&quot;)}&lt;/p&gt;
        &lt;p&gt;
            &quot;Submitted: &quot;
            &lt;code&gt;{move || format!(&quot;{:#?}&quot;, submitted())}&lt;/code&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &quot;Pending: &quot;
            &lt;code&gt;{move || format!(&quot;{:#?}&quot;, pending())}&lt;/code&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &quot;Todo ID: &quot;
            &lt;code&gt;{move || format!(&quot;{:#?}&quot;, todo_id())}&lt;/code&gt;
        &lt;/p&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projecting-children"><a class="header" href="#projecting-children">Projecting Children</a></h1>
<p>As you build components you may occasionally find yourself wanting to “project” children through multiple layers of components.</p>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Consider the following:</p>
<pre><code class="language-rust">pub fn LoggedIn&lt;F, IV&gt;(fallback: F, children: ChildrenFn) -&gt; impl IntoView
where
    F: Fn() -&gt; IV + 'static,
    IV: IntoView,
{
    view! {
        &lt;Suspense
            fallback=|| ()
        &gt;
            &lt;Show
				// check whether user is verified
				// by reading from the resource
                when=move || todo!()
                fallback=fallback
            &gt;
				{children()}
			&lt;/Show&gt;
        &lt;/Suspense&gt;
    }
}</code></pre>
<p>This is pretty straightforward: when the user is logged in, we want to show <code>children</code>. If the user is not logged in, we want to show <code>fallback</code>. And while we’re waiting to find out, we just render <code>()</code>, i.e., nothing.</p>
<p>In other words, we want to pass the children of <code>&lt;LoggedIn/&gt;</code> <em>through</em> the <code>&lt;Suspense/&gt;</code> component to become the children of the <code>&lt;Show/&gt;</code>. This is what I mean by “projection.”</p>
<p>This won’t compile.</p>
<pre><code>error[E0507]: cannot move out of `fallback`, a captured variable in an `Fn` closure
error[E0507]: cannot move out of `children`, a captured variable in an `Fn` closure
</code></pre>
<p>The problem here is that both <code>&lt;Suspense/&gt;</code> and <code>&lt;Show/&gt;</code> need to be able to construct their <code>children</code> multiple times. The first time you construct <code>&lt;Suspense/&gt;</code>’s children, it would take ownership of <code>fallback</code> and <code>children</code> to move them into the invocation of <code>&lt;Show/&gt;</code>, but then they're not available for future <code>&lt;Suspense/&gt;</code> children construction.</p>
<h2 id="the-details"><a class="header" href="#the-details">The Details</a></h2>
<blockquote>
<p>Feel free to skip ahead to the solution.</p>
</blockquote>
<p>If you want to really understand the issue here, it may help to look at the expanded <code>view</code> macro. Here’s a cleaned-up version:</p>
<pre><code class="language-rust">Suspense(
    ::leptos::component_props_builder(&amp;Suspense)
        .fallback(|| ())
        .children({
            // fallback and children are moved into this closure
            Box::new(move || {
                {
                    // fallback and children captured here
                    leptos::Fragment::lazy(|| {
                        vec![
                            (Show(
                                ::leptos::component_props_builder(&amp;Show)
                                    .when(|| true)
									// but fallback is moved into Show here
                                    .fallback(fallback)
									// and children is moved into Show here
                                    .children(children)
                                    .build(),
                            )
                            .into_view()),
                        ]
                    })
                }
            })
        })
        .build(),
)</code></pre>
<p>All components own their props; so the <code>&lt;Show/&gt;</code> in this case can’t be called because it only has captured references to <code>fallback</code> and <code>children</code>.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>However, both <code>&lt;Suspense/&gt;</code> and <code>&lt;Show/&gt;</code> take <code>ChildrenFn</code>, i.e., their <code>children</code> should implement the <code>Fn</code> type so they can be called multiple times with only an immutable reference. This means we don’t need to own <code>children</code> or <code>fallback</code>; we just need to be able to pass <code>'static</code> references to them.</p>
<p>We can solve this problem by using the <a href="https://docs.rs/leptos/latest/leptos/fn.store_value.html"><code>store_value</code></a> primitive. This essentially stores a value in the reactive system, handing ownership off to the framework in exchange for a reference that is, like signals, <code>Copy</code> and <code>'static</code>, which we can access or modify through certain methods.</p>
<p>In this case, it’s really simple:</p>
<pre><code class="language-rust">pub fn LoggedIn&lt;F, IV&gt;(fallback: F, children: ChildrenFn) -&gt; impl IntoView
where
    F: Fn() -&gt; IV + 'static,
    IV: IntoView,
{
    let fallback = store_value(fallback);
    let children = store_value(children);
    view! {
        &lt;Suspense
            fallback=|| ()
        &gt;
            &lt;Show
                when=|| todo!()
                fallback=move || fallback.with_value(|fallback| fallback())
            &gt;
                {children.with_value(|children| children())}
            &lt;/Show&gt;
        &lt;/Suspense&gt;
    }
}</code></pre>
<p>At the top level, we store both <code>fallback</code> and <code>children</code> in the reactive scope owned by <code>LoggedIn</code>. Now we can simply move those references down through the other layers into the <code>&lt;Show/&gt;</code> component and call them there.</p>
<h2 id="a-final-note"><a class="header" href="#a-final-note">A Final Note</a></h2>
<p>Note that this works because <code>&lt;Show/&gt;</code> and <code>&lt;Suspense/&gt;</code> only need an immutable reference to their children (which <code>.with_value</code> can give it), not ownership.</p>
<p>In other cases, you may need to project owned props through a function that takes <code>ChildrenFn</code> and therefore needs to be called more than once. In this case, you may find the <code>clone:</code> helper in the<code>view</code> macro helpful.</p>
<p>Consider this example</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let name = &quot;Alice&quot;.to_string();
    view! {
        &lt;Outer&gt;
            &lt;Inner&gt;
                &lt;Inmost name=name.clone()/&gt;
            &lt;/Inner&gt;
        &lt;/Outer&gt;
    }
}

#[component]
pub fn Outer(children: ChildrenFn) -&gt; impl IntoView {
    children()
}

#[component]
pub fn Inner(children: ChildrenFn) -&gt; impl IntoView {
    children()
}

#[component]
pub fn Inmost(name: String) -&gt; impl IntoView {
    view! {
        &lt;p&gt;{name}&lt;/p&gt;
    }
}</code></pre>
<p>Even with <code>name=name.clone()</code>, this gives the error</p>
<pre><code>cannot move out of `name`, a captured variable in an `Fn` closure
</code></pre>
<p>It’s captured through multiple levels of children that need to run more than once, and there’s no obvious way to clone it <em>into</em> the children.</p>
<p>In this case, the <code>clone:</code> syntax comes in handy. Calling <code>clone:name</code> will clone <code>name</code> <em>before</em> moving it into <code>&lt;Inner/&gt;</code>’s children, which solves our ownership issue.</p>
<pre><code class="language-rust">view! {
	&lt;Outer&gt;
		&lt;Inner clone:name&gt;
			&lt;Inmost name=name.clone()/&gt;
		&lt;/Inner&gt;
	&lt;/Outer&gt;
}</code></pre>
<p>These issues can be a little tricky to understand or debug, because of the opacity of the <code>view</code> macro. But in general, they can always be solved.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-state-management"><a class="header" href="#global-state-management">Global State Management</a></h1>
<p>So far, we've only been working with local state in components, and we’ve seen how to coordinate state between parent and child components. On occasion, there are times where people look for a more general solution for global state management that can work throughout an application.</p>
<p>In general, <strong>you do not need this chapter.</strong> The typical pattern is to compose your application out of components, each of which manages its own local state, not to store all state in a global structure. However, there are some cases (like theming, saving user settings, or sharing data between components in different parts of your UI) in which you may want to use some kind of global state management.</p>
<p>The three best approaches to global state are</p>
<ol>
<li>Using the router to drive global state via the URL</li>
<li>Passing signals through context</li>
<li>Creating a global state struct and creating lenses into it with <code>create_slice</code></li>
</ol>
<h2 id="option-1-url-as-global-state"><a class="header" href="#option-1-url-as-global-state">Option #1: URL as Global State</a></h2>
<p>In many ways, the URL is actually the best way to store global state. It can be accessed from any component, anywhere in your tree. There are native HTML elements like <code>&lt;form&gt;</code> and <code>&lt;a&gt;</code> that exist solely to update the URL. And it persists across page reloads and between devices; you can share a URL with a friend or send it from your phone to your laptop and any state stored in it will be replicated.</p>
<p>The next few sections of the tutorial will be about the router, and we’ll get much more into these topics.</p>
<p>But for now, we'll just look at options #2 and #3.</p>
<h2 id="option-2-passing-signals-through-context"><a class="header" href="#option-2-passing-signals-through-context">Option #2: Passing Signals through Context</a></h2>
<p>In the section on <a href="view/08_parent_child.html">parent-child communication</a>, we saw that you can use <code>provide_context</code> to pass signal from a parent component to a child, and <code>use_context</code> to read it in the child. But <code>provide_context</code> works across any distance. If you want to create a global signal that holds some piece of state, you can provide it and access it via context anywhere in the descendants of the component where you provide it.</p>
<p>A signal provided via context only causes reactive updates where it is read, not in any of the components in between, so it maintains the power of fine-grained reactive updates, even at a distance.</p>
<p>We start by creating a signal in the root of the app and providing it to
all its children and descendants using <code>provide_context</code>.</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
    // here we create a signal in the root that can be consumed
    // anywhere in the app.
    let (count, set_count) = create_signal(0);
    // we'll pass the setter to specific components,
    // but provide the count itself to the whole app via context
    provide_context(count);

    view! {
        // SetterButton is allowed to modify the count
        &lt;SetterButton set_count/&gt;
        // These consumers can only read from it
        // But we could give them write access by passing `set_count` if we wanted
        &lt;FancyMath/&gt;
        &lt;ListItems/&gt;
    }
}</code></pre>
<p><code>&lt;SetterButton/&gt;</code> is the kind of counter we’ve written several times now.
(See the sandbox below if you don’t understand what I mean.)</p>
<p><code>&lt;FancyMath/&gt;</code> and <code>&lt;ListItems/&gt;</code> both consume the signal we’re providing via
<code>use_context</code> and do something with it.</p>
<pre><code class="language-rust">/// A component that does some &quot;fancy&quot; math with the global count
#[component]
fn FancyMath() -&gt; impl IntoView {
    // here we consume the global count signal with `use_context`
    let count = use_context::&lt;ReadSignal&lt;u32&gt;&gt;()
        // we know we just provided this in the parent component
        .expect(&quot;there to be a `count` signal provided&quot;);
    let is_even = move || count() &amp; 1 == 0;

    view! {
        &lt;div class=&quot;consumer blue&quot;&gt;
            &quot;The number &quot;
            &lt;strong&gt;{count}&lt;/strong&gt;
            {move || if is_even() {
                &quot; is&quot;
            } else {
                &quot; is not&quot;
            }}
            &quot; even.&quot;
        &lt;/div&gt;
    }
}</code></pre>
<p>Note that this same pattern can be applied to more complex state. If you have multiple fields you want to update independently, you can do that by providing some struct of signals:</p>
<pre><code class="language-rust">#[derive(Copy, Clone, Debug)]
struct GlobalState {
    count: RwSignal&lt;i32&gt;,
    name: RwSignal&lt;String&gt;
}

impl GlobalState {
    pub fn new() -&gt; Self {
        Self {
            count: create_rw_signal(0),
            name: create_rw_signal(&quot;Bob&quot;.to_string())
        }
    }
}

#[component]
fn App() -&gt; impl IntoView {
    provide_context(GlobalState::new());

    // etc.
}</code></pre>
<h2 id="option-3-create-a-global-state-struct-and-slices"><a class="header" href="#option-3-create-a-global-state-struct-and-slices">Option #3: Create a Global State Struct and Slices</a></h2>
<p>You may find it cumbersome to wrap each field of a structure in a separate signal like this. In some cases, it can be useful to create a plain struct with non-reactive fields, and then wrap that in a signal.</p>
<pre><code class="language-rust">#[derive(Copy, Clone, Debug, Default)]
struct GlobalState {
    count: i32,
    name: String
}

#[component]
fn App() -&gt; impl IntoView {
    provide_context(create_rw_signal(GlobalState::default()));

    // etc.
}</code></pre>
<p>But there’s a problem: because our whole state is wrapped in one signal, updating the value of one field will cause reactive updates in parts of the UI that only depend on the other.</p>
<pre><code class="language-rust">let state = expect_context::&lt;RwSignal&lt;GlobalState&gt;&gt;();
view! {
    &lt;button on:click=move |_| state.update(|n| *n += 1)&gt;&quot;+1&quot;&lt;/button&gt;
    &lt;p&gt;{move || state.with(|state| state.name.clone())}&lt;/p&gt;
}</code></pre>
<p>In this example, clicking the button will cause the text inside <code>&lt;p&gt;</code> to be updated, cloning <code>state.name</code> again! Because signals are the atomic unit of reactivity, updating any field of the signal triggers updates to everything that depends on the signal.</p>
<p>There’s a better way. You can take fine-grained, reactive slices by using <a href="https://docs.rs/leptos/latest/leptos/fn.create_memo.html"><code>create_memo</code></a> or <a href="https://docs.rs/leptos/latest/leptos/fn.create_slice.html"><code>create_slice</code></a> (which uses <code>create_memo</code> but also provides a setter). “Memoizing” a value means creating a new reactive value which will only update when it changes. “Memoizing a slice” means creating a new reactive value which will only update when some field of the state struct updates.</p>
<p>Here, instead of reading from the state signal directly, we create “slices” of that state with fine-grained updates via <code>create_slice</code>. Each slice signal only updates when the particular piece of the larger struct it accesses updates. This means you can create a single root signal, and then take independent, fine-grained slices of it in different components, each of which can update without notifying the others of changes.</p>
<pre><code class="language-rust">/// A component that updates the count in the global state.
#[component]
fn GlobalStateCounter() -&gt; impl IntoView {
    let state = expect_context::&lt;RwSignal&lt;GlobalState&gt;&gt;();

    // `create_slice` lets us create a &quot;lens&quot; into the data
    let (count, set_count) = create_slice(

        // we take a slice *from* `state`
        state,
        // our getter returns a &quot;slice&quot; of the data
        |state| state.count,
        // our setter describes how to mutate that slice, given a new value
        |state, n| state.count = n,
    );

    view! {
        &lt;div class=&quot;consumer blue&quot;&gt;
            &lt;button
                on:click=move |_| {
                    set_count(count() + 1);
                }
            &gt;
                &quot;Increment Global Count&quot;
            &lt;/button&gt;
            &lt;br/&gt;
            &lt;span&gt;&quot;Count is: &quot; {count}&lt;/span&gt;
        &lt;/div&gt;
    }
}</code></pre>
<p>Clicking this button only updates <code>state.count</code>, so if we create another slice
somewhere else that only takes <code>state.name</code>, clicking the button won’t cause
that other slice to update. This allows you to combine the benefits of a top-down
data flow and of fine-grained reactive updates.</p>
<blockquote>
<p><strong>Note</strong>: There are some significant drawbacks to this approach. Both signals and memos need to own their values, so a memo will need to clone the field’s value on every change. The most natural way to manage state in a framework like Leptos is always to provide signals that are as locally-scoped and fine-grained as they can be, not to hoist everything up into global state. But when you <em>do</em> need some kind of global state, <code>create_slice</code> can be a useful tool.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/15-global-state-0-5-8c2ff6?file=%2Fsrc%2Fmain.rs%3A1%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/15-global-state-0-5-8c2ff6?file=%2Fsrc%2Fmain.rs%3A1%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;

// So far, we've only been working with local state in components
// We've only seen how to communicate between parent and child components
// But there are also more general ways to manage global state
//
// The three best approaches to global state are
// 1. Using the router to drive global state via the URL
// 2. Passing signals through context
// 3. Creating a global state struct and creating lenses into it with `create_slice`
//
// Option #1: URL as Global State
// The next few sections of the tutorial will be about the router.
// So for now, we'll just look at options #2 and #3.

// Option #2: Pass Signals through Context
//
// In virtual DOM libraries like React, using the Context API to manage global
// state is a bad idea: because the entire app exists in a tree, changing
// some value provided high up in the tree can cause the whole app to render.
//
// In fine-grained reactive libraries like Leptos, this is simply not the case.
// You can create a signal in the root of your app and pass it down to other
// components using provide_context(). Changing it will only cause rerendering
// in the specific places it is actually used, not the whole app.
#[component]
fn Option2() -&gt; impl IntoView {
    // here we create a signal in the root that can be consumed
    // anywhere in the app.
    let (count, set_count) = create_signal(0);
    // we'll pass the setter to specific components,
    // but provide the count itself to the whole app via context
    provide_context(count);

    view! {
        &lt;h1&gt;&quot;Option 2: Passing Signals&quot;&lt;/h1&gt;
        // SetterButton is allowed to modify the count
        &lt;SetterButton set_count/&gt;
        // These consumers can only read from it
        // But we could give them write access by passing `set_count` if we wanted
        &lt;div style=&quot;display: flex&quot;&gt;
            &lt;FancyMath/&gt;
            &lt;ListItems/&gt;
        &lt;/div&gt;
    }
}

/// A button that increments our global counter.
#[component]
fn SetterButton(set_count: WriteSignal&lt;u32&gt;) -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;provider red&quot;&gt;
            &lt;button on:click=move |_| set_count.update(|count| *count += 1)&gt;
                &quot;Increment Global Count&quot;
            &lt;/button&gt;
        &lt;/div&gt;
    }
}

/// A component that does some &quot;fancy&quot; math with the global count
#[component]
fn FancyMath() -&gt; impl IntoView {
    // here we consume the global count signal with `use_context`
    let count = use_context::&lt;ReadSignal&lt;u32&gt;&gt;()
        // we know we just provided this in the parent component
        .expect(&quot;there to be a `count` signal provided&quot;);
    let is_even = move || count() &amp; 1 == 0;

    view! {
        &lt;div class=&quot;consumer blue&quot;&gt;
            &quot;The number &quot;
            &lt;strong&gt;{count}&lt;/strong&gt;
            {move || if is_even() {
                &quot; is&quot;
            } else {
                &quot; is not&quot;
            }}
            &quot; even.&quot;
        &lt;/div&gt;
    }
}

/// A component that shows a list of items generated from the global count.
#[component]
fn ListItems() -&gt; impl IntoView {
    // again, consume the global count signal with `use_context`
    let count = use_context::&lt;ReadSignal&lt;u32&gt;&gt;().expect(&quot;there to be a `count` signal provided&quot;);

    let squares = move || {
        (0..count())
            .map(|n| view! { &lt;li&gt;{n}&lt;sup&gt;&quot;2&quot;&lt;/sup&gt; &quot; is &quot; {n * n}&lt;/li&gt; })
            .collect::&lt;Vec&lt;_&gt;&gt;()
    };

    view! {
        &lt;div class=&quot;consumer green&quot;&gt;
            &lt;ul&gt;{squares}&lt;/ul&gt;
        &lt;/div&gt;
    }
}

// Option #3: Create a Global State Struct
//
// You can use this approach to build a single global data structure
// that holds the state for your whole app, and then access it by
// taking fine-grained slices using `create_slice` or `create_memo`,
// so that changing one part of the state doesn't cause parts of your
// app that depend on other parts of the state to change.

#[derive(Default, Clone, Debug)]
struct GlobalState {
    count: u32,
    name: String,
}

#[component]
fn Option3() -&gt; impl IntoView {
    // we'll provide a single signal that holds the whole state
    // each component will be responsible for creating its own &quot;lens&quot; into it
    let state = create_rw_signal(GlobalState::default());
    provide_context(state);

    view! {
        &lt;h1&gt;&quot;Option 3: Passing Signals&quot;&lt;/h1&gt;
        &lt;div class=&quot;red consumer&quot; style=&quot;width: 100%&quot;&gt;
            &lt;h2&gt;&quot;Current Global State&quot;&lt;/h2&gt;
            &lt;pre&gt;
                {move || {
                    format!(&quot;{:#?}&quot;, state.get())
                }}
            &lt;/pre&gt;
        &lt;/div&gt;
        &lt;div style=&quot;display: flex&quot;&gt;
            &lt;GlobalStateCounter/&gt;
            &lt;GlobalStateInput/&gt;
        &lt;/div&gt;
    }
}

/// A component that updates the count in the global state.
#[component]
fn GlobalStateCounter() -&gt; impl IntoView {
    let state = use_context::&lt;RwSignal&lt;GlobalState&gt;&gt;().expect(&quot;state to have been provided&quot;);

    // `create_slice` lets us create a &quot;lens&quot; into the data
    let (count, set_count) = create_slice(

        // we take a slice *from* `state`
        state,
        // our getter returns a &quot;slice&quot; of the data
        |state| state.count,
        // our setter describes how to mutate that slice, given a new value
        |state, n| state.count = n,
    );

    view! {
        &lt;div class=&quot;consumer blue&quot;&gt;
            &lt;button
                on:click=move |_| {
                    set_count(count() + 1);
                }
            &gt;
                &quot;Increment Global Count&quot;
            &lt;/button&gt;
            &lt;br/&gt;
            &lt;span&gt;&quot;Count is: &quot; {count}&lt;/span&gt;
        &lt;/div&gt;
    }
}

/// A component that updates the count in the global state.
#[component]
fn GlobalStateInput() -&gt; impl IntoView {
    let state = use_context::&lt;RwSignal&lt;GlobalState&gt;&gt;().expect(&quot;state to have been provided&quot;);

    // this slice is completely independent of the `count` slice
    // that we created in the other component
    // neither of them will cause the other to rerun
    let (name, set_name) = create_slice(
        // we take a slice *from* `state`
        state,
        // our getter returns a &quot;slice&quot; of the data
        |state| state.name.clone(),
        // our setter describes how to mutate that slice, given a new value
        |state, n| state.name = n,
    );

    view! {
        &lt;div class=&quot;consumer green&quot;&gt;
            &lt;input
                type=&quot;text&quot;
                prop:value=name
                on:input=move |ev| {
                    set_name(event_target_value(&amp;ev));
                }
            /&gt;
            &lt;br/&gt;
            &lt;span&gt;&quot;Name is: &quot; {name}&lt;/span&gt;
        &lt;/div&gt;
    }
}
// This `main` function is the entry point into the app
// It just mounts our component to the &lt;body&gt;
// Because we defined it as `fn App`, we can now use it in a
// template as &lt;App/&gt;
fn main() {
    leptos::mount_to_body(|| view! { &lt;Option2/&gt;&lt;Option3/&gt; })
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing"><a class="header" href="#routing">Routing</a></h1>
<h2 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h2>
<p>Routing drives most websites. A router is the answer to the question, “Given this URL, what should appear on the page?”</p>
<p>A URL consists of many parts. For example, the URL <code>https://my-cool-blog.com/blog/search?q=Search#results</code> consists of</p>
<ul>
<li>a <em>scheme</em>: <code>https</code></li>
<li>a <em>domain</em>: <code>my-cool-blog.com</code></li>
<li>a <strong>path</strong>: <code>/blog/search</code></li>
<li>a <strong>query</strong> (or <strong>search</strong>): <code>?q=Search</code></li>
<li>a <em>hash</em>: <code>#results</code></li>
</ul>
<p>The Leptos Router works with the path and query (<code>/blog/search?q=Search</code>). Given this piece of the URL, what should the app render on the page?</p>
<h2 id="the-philosophy"><a class="header" href="#the-philosophy">The Philosophy</a></h2>
<p>In most cases, the path should drive what is displayed on the page. From the user’s perspective, for most applications, most major changes in the state of the app should be reflected in the URL. If you copy and paste the URL and open it in another tab, you should find yourself more or less in the same place.</p>
<p>In this sense, the router is really at the heart of the global state management for your application. More than anything else, it drives what is displayed on the page.</p>
<p>The router handles most of this work for you by mapping the current location to particular components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-routes"><a class="header" href="#defining-routes">Defining Routes</a></h1>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>It’s easy to get started with the router.</p>
<p>First things first, make sure you’ve added the <code>leptos_router</code> package to your dependencies.</p>
<blockquote>
<p>It’s important that the router is a separate package from <code>leptos</code> itself. This means that everything in the router can be defined in user-land code. If you want to create your own router, or use no router, you’re completely free to do that!</p>
</blockquote>
<p>And import the relevant types from the router, either with something like</p>
<pre><code class="language-rust">use leptos_router::{Route, RouteProps, Router, RouterProps, Routes, RoutesProps};</code></pre>
<p>or simply</p>
<pre><code class="language-rust">use leptos_router::*;</code></pre>
<h2 id="providing-the-router"><a class="header" href="#providing-the-router">Providing the <code>&lt;Router/&gt;</code></a></h2>
<p>Routing behavior is provided by the <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.Router.html"><code>&lt;Router/&gt;</code></a> component. This should usually be somewhere near the root of your application, the rest of the app.</p>
<blockquote>
<p>You shouldn’t try to use multiple <code>&lt;Router/&gt;</code>s in your app. Remember that the router drives global state: if you have multiple routers, which one decides what to do when the URL changes?</p>
</blockquote>
<p>Let’s start with a simple <code>&lt;App/&gt;</code> component using the router:</p>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
pub fn App() -&gt; impl IntoView {
  view! {
    &lt;Router&gt;
      &lt;nav&gt;
        /* ... */
      &lt;/nav&gt;
      &lt;main&gt;
        /* ... */
      &lt;/main&gt;
    &lt;/Router&gt;
  }
}</code></pre>
<h2 id="defining-routes-1"><a class="header" href="#defining-routes-1">Defining <code>&lt;Routes/&gt;</code></a></h2>
<p>The <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.Routes.html"><code>&lt;Routes/&gt;</code></a> component is where you define all the routes to which a user can navigate in your application. Each possible route is defined by a <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.Route.html"><code>&lt;Route/&gt;</code></a> component.</p>
<p>You should place the <code>&lt;Routes/&gt;</code> component at the location within your app where you want routes to be rendered. Everything outside <code>&lt;Routes/&gt;</code> will be present on every page, so you can leave things like a navigation bar or menu outside the <code>&lt;Routes/&gt;</code>.</p>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
pub fn App() -&gt; impl IntoView {
  view! {
    &lt;Router&gt;
      &lt;nav&gt;
        /* ... */
      &lt;/nav&gt;
      &lt;main&gt;
        // all our routes will appear inside &lt;main&gt;
        &lt;Routes&gt;
          /* ... */
        &lt;/Routes&gt;
      &lt;/main&gt;
    &lt;/Router&gt;
  }
}</code></pre>
<p>Individual routes are defined by providing children to <code>&lt;Routes/&gt;</code> with the <code>&lt;Route/&gt;</code> component. <code>&lt;Route/&gt;</code> takes a <code>path</code> and a <code>view</code>. When the current location matches <code>path</code>, the <code>view</code> will be created and displayed.</p>
<p>The <code>path</code> can include</p>
<ul>
<li>a static path (<code>/users</code>),</li>
<li>dynamic, named parameters beginning with a colon (<code>/:id</code>),</li>
<li>and/or a wildcard beginning with an asterisk (<code>/user/*any</code>)</li>
</ul>
<p>The <code>view</code> is a function that returns a view. Any component with no props works here, as does a closure that returns some view.</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/&quot; view=Home/&gt;
  &lt;Route path=&quot;/users&quot; view=Users/&gt;
  &lt;Route path=&quot;/users/:id&quot; view=UserProfile/&gt;
  &lt;Route path=&quot;/*any&quot; view=|| view! { &lt;h1&gt;&quot;Not Found&quot;&lt;/h1&gt; }/&gt;
&lt;/Routes&gt;</code></pre>
<blockquote>
<p><code>view</code> takes a <code>Fn() -&gt; impl IntoView</code>. If a component has no props, it can be passed directly into the <code>view</code>. In this case, <code>view=Home</code> is just a shorthand for <code>|| view! { &lt;Home/&gt; }</code>.</p>
</blockquote>
<p>Now if you navigate to <code>/</code> or to <code>/users</code> you’ll get the home page or the <code>&lt;Users/&gt;</code>. If you go to <code>/users/3</code> or <code>/blahblah</code> you’ll get a user profile or your 404 page (<code>&lt;NotFound/&gt;</code>). On every navigation, the router determines which <code>&lt;Route/&gt;</code> should be matched, and therefore what content should be displayed where the <code>&lt;Routes/&gt;</code> component is defined.</p>
<p>Note that you can define your routes in any order. The router scores each route to see how good a match it is, rather than simply trying to match them top to bottom.</p>
<p>Simple enough?</p>
<h2 id="conditional-routes"><a class="header" href="#conditional-routes">Conditional Routes</a></h2>
<p><code>leptos_router</code> is based on the assumption that you have one and only one <code>&lt;Routes/&gt;</code> component in your app. It uses this to generate routes on the server side, optimize route matching by caching calculated branches, and render your application.</p>
<p>You should not conditionally render <code>&lt;Routes/&gt;</code> using another component like <code>&lt;Show/&gt;</code> or <code>&lt;Suspense/&gt;</code>.</p>
<pre><code class="language-rust">// ❌ don't do this!
view! {
  &lt;Show when=|| is_loaded() fallback=|| view! { &lt;p&gt;&quot;Loading&quot;&lt;/p&gt; }&gt;
    &lt;Routes&gt;
      &lt;Route path=&quot;/&quot; view=Home/&gt;
    &lt;/Routes&gt;
  &lt;/Show&gt;
}</code></pre>
<p>Instead, you can use nested routing to render your <code>&lt;Routes/&gt;</code> once, and conditionally render the router outlet:</p>
<pre><code class="language-rust">// ✅ do this instead!
view! {
  &lt;Routes&gt;
    // parent route
    &lt;Route path=&quot;/&quot; view=move || {
      view! {
        // only show the outlet if data have loaded
        &lt;Show when=|| is_loaded() fallback=|| view! { &lt;p&gt;&quot;Loading&quot;&lt;/p&gt; }&gt;
          &lt;Outlet/&gt;
        &lt;/Show&gt;
      }
    }&gt;
      // nested child route
      &lt;Route path=&quot;/&quot; view=Home/&gt;
    &lt;/Route&gt;
  &lt;/Routes&gt;
}</code></pre>
<p>If this looks bizarre, don’t worry! The next section of the book is about this kind of nested routing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-routing"><a class="header" href="#nested-routing">Nested Routing</a></h1>
<p>We just defined the following set of routes:</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/&quot; view=Home/&gt;
  &lt;Route path=&quot;/users&quot; view=Users/&gt;
  &lt;Route path=&quot;/users/:id&quot; view=UserProfile/&gt;
  &lt;Route path=&quot;/*any&quot; view=NotFound/&gt;
&lt;/Routes&gt;</code></pre>
<p>There’s a certain amount of duplication here: <code>/users</code> and <code>/users/:id</code>. This is fine for a small app, but you can probably already tell it won’t scale well. Wouldn’t it be nice if we could nest these routes?</p>
<p>Well... you can!</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/&quot; view=Home/&gt;
  &lt;Route path=&quot;/users&quot; view=Users&gt;
    &lt;Route path=&quot;:id&quot; view=UserProfile/&gt;
  &lt;/Route&gt;
  &lt;Route path=&quot;/*any&quot; view=NotFound/&gt;
&lt;/Routes&gt;</code></pre>
<p>But wait. We’ve just subtly changed what our application does.</p>
<p>The next section is one of the most important in this entire routing section of the guide. Read it carefully, and feel free to ask questions if there’s anything you don’t understand.</p>
<h1 id="nested-routes-as-layout"><a class="header" href="#nested-routes-as-layout">Nested Routes as Layout</a></h1>
<p>Nested routes are a form of layout, not a method of route definition.</p>
<p>Let me put that another way: The goal of defining nested routes is not primarily to avoid repeating yourself when typing out the paths in your route definitions. It is actually to tell the router to display multiple <code>&lt;Route/&gt;</code>s on the page at the same time, side by side.</p>
<p>Let’s look back at our practical example.</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/users&quot; view=Users/&gt;
  &lt;Route path=&quot;/users/:id&quot; view=UserProfile/&gt;
&lt;/Routes&gt;</code></pre>
<p>This means:</p>
<ul>
<li>If I go to <code>/users</code>, I get the <code>&lt;Users/&gt;</code> component.</li>
<li>If I go to <code>/users/3</code>, I get the <code>&lt;UserProfile/&gt;</code> component (with the parameter <code>id</code> set to <code>3</code>; more on that later)</li>
</ul>
<p>Let’s say I use nested routes instead:</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/users&quot; view=Users&gt;
    &lt;Route path=&quot;:id&quot; view=UserProfile/&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</code></pre>
<p>This means:</p>
<ul>
<li>If I go to <code>/users/3</code>, the path matches two <code>&lt;Route/&gt;</code>s: <code>&lt;Users/&gt;</code> and <code>&lt;UserProfile/&gt;</code>.</li>
<li>If I go to <code>/users</code>, the path is not matched.</li>
</ul>
<p>I actually need to add a fallback route</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/users&quot; view=Users&gt;
    &lt;Route path=&quot;:id&quot; view=UserProfile/&gt;
    &lt;Route path=&quot;&quot; view=NoUser/&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</code></pre>
<p>Now:</p>
<ul>
<li>If I go to <code>/users/3</code>, the path matches <code>&lt;Users/&gt;</code> and <code>&lt;UserProfile/&gt;</code>.</li>
<li>If I go to <code>/users</code>, the path matches <code>&lt;Users/&gt;</code> and <code>&lt;NoUser/&gt;</code>.</li>
</ul>
<p>When I use nested routes, in other words, each <strong>path</strong> can match multiple <strong>routes</strong>: each URL can render the views provided by multiple <code>&lt;Route/&gt;</code> components, at the same time, on the same page.</p>
<p>This may be counter-intuitive, but it’s very powerful, for reasons you’ll hopefully see in a few minutes.</p>
<h2 id="why-nested-routing"><a class="header" href="#why-nested-routing">Why Nested Routing?</a></h2>
<p>Why bother with this?</p>
<p>Most web applications contain levels of navigation that correspond to different parts of the layout. For example, in an email app you might have a URL like <code>/contacts/greg</code>, which shows a list of contacts on the left of the screen, and contact details for Greg on the right of the screen. The contact list and the contact details should always appear on the screen at the same time. If there’s no contact selected, maybe you want to show a little instructional text.</p>
<p>You can easily define this with nested routes</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/contacts&quot; view=ContactList&gt;
    &lt;Route path=&quot;:id&quot; view=ContactInfo/&gt;
    &lt;Route path=&quot;&quot; view=|| view! {
      &lt;p&gt;&quot;Select a contact to view more info.&quot;&lt;/p&gt;
    }/&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</code></pre>
<p>You can go even deeper. Say you want to have tabs for each contact’s address, email/phone, and your conversations with them. You can add <em>another</em> set of nested routes inside <code>:id</code>:</p>
<pre><code class="language-rust">&lt;Routes&gt;
  &lt;Route path=&quot;/contacts&quot; view=ContactList&gt;
    &lt;Route path=&quot;:id&quot; view=ContactInfo&gt;
      &lt;Route path=&quot;&quot; view=EmailAndPhone/&gt;
      &lt;Route path=&quot;address&quot; view=Address/&gt;
      &lt;Route path=&quot;messages&quot; view=Messages/&gt;
    &lt;/Route&gt;
    &lt;Route path=&quot;&quot; view=|| view! {
      &lt;p&gt;&quot;Select a contact to view more info.&quot;&lt;/p&gt;
    }/&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</code></pre>
<blockquote>
<p>The main page of the <a href="https://remix.run/">Remix website</a>, a React framework from the creators of React Router, has a great visual example if you scroll down, with three levels of nested routing: Sales &gt; Invoices &gt; an invoice.</p>
</blockquote>
<h2 id="outlet"><a class="header" href="#outlet"><code>&lt;Outlet/&gt;</code></a></h2>
<p>Parent routes do not automatically render their nested routes. After all, they are just components; they don’t know exactly where they should render their children, and “just stick it at the end of the parent component” is not a great answer.</p>
<p>Instead, you tell a parent component where to render any nested components with an <code>&lt;Outlet/&gt;</code> component. The <code>&lt;Outlet/&gt;</code> simply renders one of two things:</p>
<ul>
<li>if there is no nested route that has been matched, it shows nothing</li>
<li>if there is a nested route that has been matched, it shows its <code>view</code></li>
</ul>
<p>That’s all! But it’s important to know and to remember, because it’s a common source of “Why isn’t this working?” frustration. If you don’t provide an <code>&lt;Outlet/&gt;</code>, the nested route won’t be displayed.</p>
<pre><code class="language-rust">#[component]
pub fn ContactList() -&gt; impl IntoView {
  let contacts = todo!();

  view! {
    &lt;div style=&quot;display: flex&quot;&gt;
      // the contact list
      &lt;For each=contacts
        key=|contact| contact.id
        children=|contact| todo!()
      /&gt;
      // the nested child, if any
      // don’t forget this!
      &lt;Outlet/&gt;
    &lt;/div&gt;
  }
}</code></pre>
<h2 id="refactoring-route-definitions"><a class="header" href="#refactoring-route-definitions">Refactoring Route Definitions</a></h2>
<p>You don’t need to define all your routes in one place if you don’t want to. You can refactor any <code>&lt;Route/&gt;</code> and its children out into a separate component.</p>
<p>For example, you can refactor the example above to use two separate components:</p>
<pre><code class="language-rust">#[component]
fn App() -&gt; impl IntoView {
  view! {
    &lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/contacts&quot; view=ContactList&gt;
          &lt;ContactInfoRoutes/&gt;
          &lt;Route path=&quot;&quot; view=|| view! {
            &lt;p&gt;&quot;Select a contact to view more info.&quot;&lt;/p&gt;
          }/&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  }
}

#[component(transparent)]
fn ContactInfoRoutes() -&gt; impl IntoView {
  view! {
    &lt;Route path=&quot;:id&quot; view=ContactInfo&gt;
      &lt;Route path=&quot;&quot; view=EmailAndPhone/&gt;
      &lt;Route path=&quot;address&quot; view=Address/&gt;
      &lt;Route path=&quot;messages&quot; view=Messages/&gt;
    &lt;/Route&gt;
  }
}</code></pre>
<p>This second component is a <code>#[component(transparent)]</code>, meaning it just returns its data, not a view: in this case, it's a <a href="https://docs.rs/leptos_router/latest/leptos_router/struct.RouteDefinition.html"><code>RouteDefinition</code></a> struct, which is what the <code>&lt;Route/&gt;</code> returns. As long as it is marked <code>#[component(transparent)]</code>, this sub-route can be defined wherever you want, and inserted as a component into your tree of route definitions.</p>
<h2 id="nested-routing-and-performance"><a class="header" href="#nested-routing-and-performance">Nested Routing and Performance</a></h2>
<p>All of this is nice, conceptually, but again—what’s the big deal?</p>
<p>Performance.</p>
<p>In a fine-grained reactive library like Leptos, it’s always important to do the least amount of rendering work you can. Because we’re working with real DOM nodes and not diffing a virtual DOM, we want to “rerender” components as infrequently as possible. Nested routing makes this extremely easy.</p>
<p>Imagine my contact list example. If I navigate from Greg to Alice to Bob and back to Greg, the contact information needs to change on each navigation. But the <code>&lt;ContactList/&gt;</code> should never be rerendered. Not only does this save on rendering performance, it also maintains state in the UI. For example, if I have a search bar at the top of <code>&lt;ContactList/&gt;</code>, navigating from Greg to Alice to Bob won’t clear the search.</p>
<p>In fact, in this case, we don’t even need to rerender the <code>&lt;Contact/&gt;</code> component when moving between contacts. The router will just reactively update the <code>:id</code> parameter as we navigate, allowing us to make fine-grained updates. As we navigate between contacts, we’ll update single text nodes to change the contact’s name, address, and so on, without doing <em>any</em> additional rerendering.</p>
<blockquote>
<p>This sandbox includes a couple features (like nested routing) discussed in this section and the previous one, and a couple we’ll cover in the rest of this chapter. The router is such an integrated system that it makes sense to provide a single example, so don’t be surprised if there’s anything you don’t understand.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;h1&gt;&quot;Contact App&quot;&lt;/h1&gt;
            // this &lt;nav&gt; will show on every routes,
            // because it's outside the &lt;Routes/&gt;
            // note: we can just use normal &lt;a&gt; tags
            // and the router will use client-side navigation
            &lt;nav&gt;
                &lt;h2&gt;&quot;Navigation&quot;&lt;/h2&gt;
                &lt;a href=&quot;/&quot;&gt;&quot;Home&quot;&lt;/a&gt;
                &lt;a href=&quot;/contacts&quot;&gt;&quot;Contacts&quot;&lt;/a&gt;
            &lt;/nav&gt;
            &lt;main&gt;
                &lt;Routes&gt;
                    // / just has an un-nested &quot;Home&quot;
                    &lt;Route path=&quot;/&quot; view=|| view! {
                        &lt;h3&gt;&quot;Home&quot;&lt;/h3&gt;
                    }/&gt;
                    // /contacts has nested routes
                    &lt;Route
                        path=&quot;/contacts&quot;
                        view=ContactList
                      &gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;:id&quot; view=ContactInfo&gt;
                            &lt;Route path=&quot;&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Contact Info)&quot;
                                &lt;/div&gt;
                            }/&gt;
                            &lt;Route path=&quot;conversations&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Conversations)&quot;
                                &lt;/div&gt;
                            }/&gt;
                        &lt;/Route&gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;&quot; view=|| view! {
                            &lt;div class=&quot;select-user&quot;&gt;
                                &quot;Select a user to view contact info.&quot;
                            &lt;/div&gt;
                        }/&gt;
                    &lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

#[component]
fn ContactList() -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;contact-list&quot;&gt;
            // here's our contact list component itself
            &lt;div class=&quot;contact-list-contacts&quot;&gt;
                &lt;h3&gt;&quot;Contacts&quot;&lt;/h3&gt;
                &lt;A href=&quot;alice&quot;&gt;&quot;Alice&quot;&lt;/A&gt;
                &lt;A href=&quot;bob&quot;&gt;&quot;Bob&quot;&lt;/A&gt;
                &lt;A href=&quot;steve&quot;&gt;&quot;Steve&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; will show the nested child route
            // we can position this outlet wherever we want
            // within the layout
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

#[component]
fn ContactInfo() -&gt; impl IntoView {
    // we can access the :id param reactively with `use_params_map`
    let params = use_params_map();
    let id = move || params.with(|params| params.get(&quot;id&quot;).cloned().unwrap_or_default());

    // imagine we're loading data from an API here
    let name = move || match id().as_str() {
        &quot;alice&quot; =&gt; &quot;Alice&quot;,
        &quot;bob&quot; =&gt; &quot;Bob&quot;,
        &quot;steve&quot; =&gt; &quot;Steve&quot;,
        _ =&gt; &quot;User not found.&quot;,
    };

    view! {
        &lt;div class=&quot;contact-info&quot;&gt;
            &lt;h4&gt;{name}&lt;/h4&gt;
            &lt;div class=&quot;tabs&quot;&gt;
                &lt;A href=&quot;&quot; exact=true&gt;&quot;Contact Info&quot;&lt;/A&gt;
                &lt;A href=&quot;conversations&quot;&gt;&quot;Conversations&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; here is the tabs that are nested
            // underneath the /contacts/:id route
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="params-and-queries"><a class="header" href="#params-and-queries">Params and Queries</a></h1>
<p>Static paths are useful for distinguishing between different pages, but almost every application wants to pass data through the URL at some point.</p>
<p>There are two ways you can do this:</p>
<ol>
<li>named route <strong>params</strong> like <code>id</code> in <code>/users/:id</code></li>
<li>named route <strong>queries</strong> like <code>q</code> in <code>/search?q=Foo</code></li>
</ol>
<p>Because of the way URLs are built, you can access the query from <em>any</em> <code>&lt;Route/&gt;</code> view. You can access route params from the <code>&lt;Route/&gt;</code> that defines them or any of its nested children.</p>
<p>Accessing params and queries is pretty simple with a couple of hooks:</p>
<ul>
<li><a href="https://docs.rs/leptos_router/latest/leptos_router/fn.use_query.html"><code>use_query</code></a> or <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.use_query_map.html"><code>use_query_map</code></a></li>
<li><a href="https://docs.rs/leptos_router/latest/leptos_router/fn.use_params.html"><code>use_params</code></a> or <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.use_query_map.html"><code>use_params_map</code></a></li>
</ul>
<p>Each of these comes with a typed option (<code>use_query</code> and <code>use_params</code>) and an untyped option (<code>use_query_map</code> and <code>use_params_map</code>).</p>
<p>The untyped versions hold a simple key-value map. To use the typed versions, derive the <a href="https://docs.rs/leptos_router/0.2.3/leptos_router/trait.Params.html"><code>Params</code></a> trait on a struct.</p>
<blockquote>
<p><code>Params</code> is a very lightweight trait to convert a flat key-value map of strings into a struct by applying <code>FromStr</code> to each field. Because of the flat structure of route params and URL queries, it’s significantly less flexible than something like <code>serde</code>; it also adds much less weight to your binary.</p>
</blockquote>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[derive(Params)]
struct ContactParams {
	id: usize
}

#[derive(Params)]
struct ContactSearch {
	q: String
}</code></pre>
<blockquote>
<p>Note: The <code>Params</code> derive macro is located at <code>leptos::Params</code>, and the <code>Params</code> trait is at <code>leptos_router::Params</code>. If you avoid using glob imports like <code>use leptos::*;</code>, make sure you’re importing the right one for the derive macro.</p>
<p>If you are not using the <code>nightly</code> feature, you will get the error</p>
<pre><code>no function or associated item named `into_param` found for struct `std::string::String` in the current scope
</code></pre>
<p>At the moment, supporting both <code>T: FromStr</code> and <code>Option&lt;T&gt;</code> for typed params requires a nightly feature. You can fix this by simply changing the struct to use <code>q: Option&lt;String&gt;</code> instead of <code>q: String</code>.</p>
</blockquote>
<p>Now we can use them in a component. Imagine a URL that has both params and a query, like <code>/contacts/:id?q=Search</code>.</p>
<p>The typed versions return <code>Memo&lt;Result&lt;T, _&gt;&gt;</code>. It’s a Memo so it reacts to changes in the URL. It’s a <code>Result</code> because the params or query need to be parsed from the URL, and may or may not be valid.</p>
<pre><code class="language-rust">let params = use_params::&lt;ContactParams&gt;();
let query = use_query::&lt;ContactSearch&gt;();

// id: || -&gt; usize
let id = move || {
	params.with(|params| {
		params.as_ref()
			.map(|params| params.id)
			.unwrap_or_default()
	})
};</code></pre>
<p>The untyped versions return <code>Memo&lt;ParamsMap&gt;</code>. Again, it’s memo to react to changes in the URL. <a href="https://docs.rs/leptos_router/0.2.3/leptos_router/struct.ParamsMap.html"><code>ParamsMap</code></a> behaves a lot like any other map type, with a <code>.get()</code> method that returns <code>Option&lt;&amp;String&gt;</code>.</p>
<pre><code class="language-rust">let params = use_params_map();
let query = use_query_map();

// id: || -&gt; Option&lt;String&gt;
let id = move || {
	params.with(|params| params.get(&quot;id&quot;).cloned())
};</code></pre>
<p>This can get a little messy: deriving a signal that wraps an <code>Option&lt;_&gt;</code> or <code>Result&lt;_&gt;</code> can involve a couple steps. But it’s worth doing this for two reasons:</p>
<ol>
<li>It’s correct, i.e., it forces you to consider the cases, “What if the user doesn’t pass a value for this query field? What if they pass an invalid value?”</li>
<li>It’s performant. Specifically, when you navigate between different paths that match the same <code>&lt;Route/&gt;</code> with only params or the query changing, you can get fine-grained updates to different parts of your app without rerendering. For example, navigating between different contacts in our contact-list example does a targeted update to the name field (and eventually contact info) without needing to replace or rerender the wrapping <code>&lt;Contact/&gt;</code>. This is what fine-grained reactivity is for.</li>
</ol>
<blockquote>
<p>This is the same example from the previous section. The router is such an integrated system that it makes sense to provide a single example highlighting multiple features, even if we haven’t explained them all yet.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;h1&gt;&quot;Contact App&quot;&lt;/h1&gt;
            // this &lt;nav&gt; will show on every routes,
            // because it's outside the &lt;Routes/&gt;
            // note: we can just use normal &lt;a&gt; tags
            // and the router will use client-side navigation
            &lt;nav&gt;
                &lt;h2&gt;&quot;Navigation&quot;&lt;/h2&gt;
                &lt;a href=&quot;/&quot;&gt;&quot;Home&quot;&lt;/a&gt;
                &lt;a href=&quot;/contacts&quot;&gt;&quot;Contacts&quot;&lt;/a&gt;
            &lt;/nav&gt;
            &lt;main&gt;
                &lt;Routes&gt;
                    // / just has an un-nested &quot;Home&quot;
                    &lt;Route path=&quot;/&quot; view=|| view! {
                        &lt;h3&gt;&quot;Home&quot;&lt;/h3&gt;
                    }/&gt;
                    // /contacts has nested routes
                    &lt;Route
                        path=&quot;/contacts&quot;
                        view=ContactList
                      &gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;:id&quot; view=ContactInfo&gt;
                            &lt;Route path=&quot;&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Contact Info)&quot;
                                &lt;/div&gt;
                            }/&gt;
                            &lt;Route path=&quot;conversations&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Conversations)&quot;
                                &lt;/div&gt;
                            }/&gt;
                        &lt;/Route&gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;&quot; view=|| view! {
                            &lt;div class=&quot;select-user&quot;&gt;
                                &quot;Select a user to view contact info.&quot;
                            &lt;/div&gt;
                        }/&gt;
                    &lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

#[component]
fn ContactList() -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;contact-list&quot;&gt;
            // here's our contact list component itself
            &lt;div class=&quot;contact-list-contacts&quot;&gt;
                &lt;h3&gt;&quot;Contacts&quot;&lt;/h3&gt;
                &lt;A href=&quot;alice&quot;&gt;&quot;Alice&quot;&lt;/A&gt;
                &lt;A href=&quot;bob&quot;&gt;&quot;Bob&quot;&lt;/A&gt;
                &lt;A href=&quot;steve&quot;&gt;&quot;Steve&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; will show the nested child route
            // we can position this outlet wherever we want
            // within the layout
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

#[component]
fn ContactInfo() -&gt; impl IntoView {
    // we can access the :id param reactively with `use_params_map`
    let params = use_params_map();
    let id = move || params.with(|params| params.get(&quot;id&quot;).cloned().unwrap_or_default());

    // imagine we're loading data from an API here
    let name = move || match id().as_str() {
        &quot;alice&quot; =&gt; &quot;Alice&quot;,
        &quot;bob&quot; =&gt; &quot;Bob&quot;,
        &quot;steve&quot; =&gt; &quot;Steve&quot;,
        _ =&gt; &quot;User not found.&quot;,
    };

    view! {
        &lt;div class=&quot;contact-info&quot;&gt;
            &lt;h4&gt;{name}&lt;/h4&gt;
            &lt;div class=&quot;tabs&quot;&gt;
                &lt;A href=&quot;&quot; exact=true&gt;&quot;Contact Info&quot;&lt;/A&gt;
                &lt;A href=&quot;conversations&quot;&gt;&quot;Conversations&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; here is the tabs that are nested
            // underneath the /contacts/:id route
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-a-component"><a class="header" href="#the-a-component">The <code>&lt;A/&gt;</code> Component</a></h1>
<p>Client-side navigation works perfectly fine with ordinary HTML <code>&lt;a&gt;</code> elements. The router adds a listener that handles every click on a <code>&lt;a&gt;</code> element and tries to handle it on the client side, i.e., without doing another round trip to the server to request HTML. This is what enables the snappy “single-page app” navigations you’re probably familiar with from most modern web apps.</p>
<p>The router will bail out of handling an <code>&lt;a&gt;</code> click under a number of situations</p>
<ul>
<li>the click event has had <code>prevent_default()</code> called on it</li>
<li>the <kbd>Meta</kbd>, <kbd>Alt</kbd>, <kbd>Ctrl</kbd>, or <kbd>Shift</kbd> keys were held during click</li>
<li>the <code>&lt;a&gt;</code> has a <code>target</code> or <code>download</code> attribute, or <code>rel=&quot;external&quot;</code></li>
<li>the link has a different origin from the current location</li>
</ul>
<p>In other words, the router will only try to do a client-side navigation when it’s pretty sure it can handle it, and it will upgrade every <code>&lt;a&gt;</code> element to get this special behavior.</p>
<blockquote>
<p>This also means that if you need to opt out of client-side routing, you can do so easily. For example, if you have a link to another page on the same domain, but which isn’t part of your Leptos app, you can just use <code>&lt;a rel=&quot;external&quot;&gt;</code> to tell the router it isn’t something it can handle.</p>
</blockquote>
<p>The router also provides an <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.A.html"><code>&lt;A&gt;</code></a> component, which does two additional things:</p>
<ol>
<li>Correctly resolves relative nested routes. Relative routing with ordinary <code>&lt;a&gt;</code> tags can be tricky. For example, if you have a route like <code>/post/:id</code>, <code>&lt;A href=&quot;1&quot;&gt;</code> will generate the correct relative route, but <code>&lt;a href=&quot;1&quot;&gt;</code> likely will not (depending on where it appears in your view.) <code>&lt;A/&gt;</code> resolves routes relative to the path of the nested route within which it appears.</li>
<li>Sets the <code>aria-current</code> attribute to <code>page</code> if this link is the active link (i.e., it’s a link to the page you’re on). This is helpful for accessibility and for styling. For example, if you want to set the link a different color if it’s a link to the page you’re currently on, you can match this attribute with a CSS selector.</li>
</ol>
<h2 id="navigating-programmatically"><a class="header" href="#navigating-programmatically">Navigating Programmatically</a></h2>
<p>Your most-used methods of navigating between pages should be with <code>&lt;a&gt;</code> and <code>&lt;form&gt;</code> elements or with the enhanced <code>&lt;A/&gt;</code> and <code>&lt;Form/&gt;</code> components. Using links and forms to navigate is the best solution for accessibility and graceful degradation.</p>
<p>On occasion, though, you’ll want to navigate programmatically, i.e., call a function that can navigate to a new page. In that case, you should use the <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.use_navigate.html"><code>use_navigate</code></a> function.</p>
<pre><code class="language-rust">let navigate = leptos_router::use_navigate();
navigate(&quot;/somewhere&quot;, Default::default());</code></pre>
<blockquote>
<p>You should almost never do something like <code>&lt;button on:click=move |_| navigate(/* ... */)&gt;</code>. Any <code>on:click</code> that navigates should be an <code>&lt;a&gt;</code>, for reasons of accessibility.</p>
</blockquote>
<p>The second argument here is a set of <a href="https://docs.rs/leptos_router/latest/leptos_router/struct.NavigateOptions.html"><code>NavigateOptions</code></a>, which includes options to resolve the navigation relative to the current route as the <code>&lt;A/&gt;</code> component does, replace it in the navigation stack, include some navigation state, and maintain the current scroll state on navigation.</p>
<blockquote>
<p>Once again, this is the same example. Check out the relative <code>&lt;A/&gt;</code> components, and take a look at the CSS in <code>index.html</code> to see the ARIA-based styling.</p>
</blockquote>
<p><a href="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/16-router-0-5-4xp4zz?file=%2Fsrc%2Fmain.rs%3A102%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;h1&gt;&quot;Contact App&quot;&lt;/h1&gt;
            // this &lt;nav&gt; will show on every routes,
            // because it's outside the &lt;Routes/&gt;
            // note: we can just use normal &lt;a&gt; tags
            // and the router will use client-side navigation
            &lt;nav&gt;
                &lt;h2&gt;&quot;Navigation&quot;&lt;/h2&gt;
                &lt;a href=&quot;/&quot;&gt;&quot;Home&quot;&lt;/a&gt;
                &lt;a href=&quot;/contacts&quot;&gt;&quot;Contacts&quot;&lt;/a&gt;
            &lt;/nav&gt;
            &lt;main&gt;
                &lt;Routes&gt;
                    // / just has an un-nested &quot;Home&quot;
                    &lt;Route path=&quot;/&quot; view=|| view! {
                        &lt;h3&gt;&quot;Home&quot;&lt;/h3&gt;
                    }/&gt;
                    // /contacts has nested routes
                    &lt;Route
                        path=&quot;/contacts&quot;
                        view=ContactList
                      &gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;:id&quot; view=ContactInfo&gt;
                            &lt;Route path=&quot;&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Contact Info)&quot;
                                &lt;/div&gt;
                            }/&gt;
                            &lt;Route path=&quot;conversations&quot; view=|| view! {
                                &lt;div class=&quot;tab&quot;&gt;
                                    &quot;(Conversations)&quot;
                                &lt;/div&gt;
                            }/&gt;
                        &lt;/Route&gt;
                        // if no id specified, fall back
                        &lt;Route path=&quot;&quot; view=|| view! {
                            &lt;div class=&quot;select-user&quot;&gt;
                                &quot;Select a user to view contact info.&quot;
                            &lt;/div&gt;
                        }/&gt;
                    &lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

#[component]
fn ContactList() -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;contact-list&quot;&gt;
            // here's our contact list component itself
            &lt;div class=&quot;contact-list-contacts&quot;&gt;
                &lt;h3&gt;&quot;Contacts&quot;&lt;/h3&gt;
                &lt;A href=&quot;alice&quot;&gt;&quot;Alice&quot;&lt;/A&gt;
                &lt;A href=&quot;bob&quot;&gt;&quot;Bob&quot;&lt;/A&gt;
                &lt;A href=&quot;steve&quot;&gt;&quot;Steve&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; will show the nested child route
            // we can position this outlet wherever we want
            // within the layout
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

#[component]
fn ContactInfo() -&gt; impl IntoView {
    // we can access the :id param reactively with `use_params_map`
    let params = use_params_map();
    let id = move || params.with(|params| params.get(&quot;id&quot;).cloned().unwrap_or_default());

    // imagine we're loading data from an API here
    let name = move || match id().as_str() {
        &quot;alice&quot; =&gt; &quot;Alice&quot;,
        &quot;bob&quot; =&gt; &quot;Bob&quot;,
        &quot;steve&quot; =&gt; &quot;Steve&quot;,
        _ =&gt; &quot;User not found.&quot;,
    };

    view! {
        &lt;div class=&quot;contact-info&quot;&gt;
            &lt;h4&gt;{name}&lt;/h4&gt;
            &lt;div class=&quot;tabs&quot;&gt;
                &lt;A href=&quot;&quot; exact=true&gt;&quot;Contact Info&quot;&lt;/A&gt;
                &lt;A href=&quot;conversations&quot;&gt;&quot;Conversations&quot;&lt;/A&gt;
            &lt;/div&gt;

            // &lt;Outlet/&gt; here is the tabs that are nested
            // underneath the /contacts/:id route
            &lt;Outlet/&gt;
        &lt;/div&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-form-component"><a class="header" href="#the-form-component">The <code>&lt;Form/&gt;</code> Component</a></h1>
<p>Links and forms sometimes seem completely unrelated. But, in fact, they work in very similar ways.</p>
<p>In plain HTML, there are three ways to navigate to another page:</p>
<ol>
<li>An <code>&lt;a&gt;</code> element that links to another page: Navigates to the URL in its <code>href</code> attribute with the <code>GET</code> HTTP method.</li>
<li>A <code>&lt;form method=&quot;GET&quot;&gt;</code>: Navigates to the URL in its <code>action</code> attribute with the <code>GET</code> HTTP method and the form data from its inputs encoded in the URL query string.</li>
<li>A <code>&lt;form method=&quot;POST&quot;&gt;</code>: Navigates to the URL in its <code>action</code> attribute with the <code>POST</code> HTTP method and the form data from its inputs encoded in the body of the request.</li>
</ol>
<p>Since we have a client-side router, we can do client-side link navigations without reloading the page, i.e., without a full round-trip to the server and back. It makes sense that we can do client-side form navigations in the same way.</p>
<p>The router provides a <a href="https://docs.rs/leptos_router/latest/leptos_router/fn.Form.html"><code>&lt;Form&gt;</code></a> component, which works like the HTML <code>&lt;form&gt;</code> element, but uses client-side navigations instead of full page reloads. <code>&lt;Form/&gt;</code> works with both <code>GET</code> and <code>POST</code> requests. With <code>method=&quot;GET&quot;</code>, it will navigate to the URL encoded in the form data. With <code>method=&quot;POST&quot;</code> it will make a <code>POST</code> request and handle the server’s response.</p>
<p><code>&lt;Form/&gt;</code> provides the basis for some components like <code>&lt;ActionForm/&gt;</code> and <code>&lt;MultiActionForm/&gt;</code> that we’ll see in later chapters. But it also enables some powerful patterns of its own.</p>
<p>For example, imagine that you want to create a search field that updates search results in real time as the user searches, without a page reload, but that also stores the search in the URL so a user can copy and paste it to share results with someone else.</p>
<p>It turns out that the patterns we’ve learned so far make this easy to implement.</p>
<pre><code class="language-rust">async fn fetch_results() {
	// some async function to fetch our search results
}

#[component]
pub fn FormExample() -&gt; impl IntoView {
    // reactive access to URL query strings
    let query = use_query_map();
	// search stored as ?q=
    let search = move || query().get(&quot;q&quot;).cloned().unwrap_or_default();
	// a resource driven by the search string
	let search_results = create_resource(search, fetch_results);

	view! {
		&lt;Form method=&quot;GET&quot; action=&quot;&quot;&gt;
			&lt;input type=&quot;search&quot; name=&quot;q&quot; value=search/&gt;
			&lt;input type=&quot;submit&quot;/&gt;
		&lt;/Form&gt;
		&lt;Transition fallback=move || ()&gt;
			/* render search results */
		&lt;/Transition&gt;
	}
}</code></pre>
<p>Whenever you click <code>Submit</code>, the <code>&lt;Form/&gt;</code> will “navigate” to <code>?q={search}</code>. But because this navigation is done on the client side, there’s no page flicker or reload. The URL query string changes, which triggers <code>search</code> to update. Because <code>search</code> is the source signal for the <code>search_results</code> resource, this triggers <code>search_results</code> to reload its resource. The <code>&lt;Transition/&gt;</code> continues displaying the current search results until the new ones have loaded. When they are complete, it switches to displaying the new result.</p>
<p>This is a great pattern. The data flow is extremely clear: all data flows from the URL to the resource into the UI. The current state of the application is stored in the URL, which means you can refresh the page or text the link to a friend and it will show exactly what you’re expecting. And once we introduce server rendering, this pattern will prove to be really fault-tolerant, too: because it uses a <code>&lt;form&gt;</code> element and URLs under the hood, it actually works really well without even loading your WASM on the client.</p>
<p>We can actually take it a step further and do something kind of clever:</p>
<pre><code class="language-rust">view! {
	&lt;Form method=&quot;GET&quot; action=&quot;&quot;&gt;
		&lt;input type=&quot;search&quot; name=&quot;q&quot; value=search
			oninput=&quot;this.form.requestSubmit()&quot;
		/&gt;
	&lt;/Form&gt;
}</code></pre>
<p>You’ll notice that this version drops the <code>Submit</code> button. Instead, we add an <code>oninput</code> attribute to the input. Note that this is <em>not</em> <code>on:input</code>, which would listen for the <code>input</code> event and run some Rust code. Without the colon, <code>oninput</code> is the plain HTML attribute. So the string is actually a JavaScript string. <code>this.form</code> gives us the form the input is attached to. <code>requestSubmit()</code> fires the <code>submit</code> event on the <code>&lt;form&gt;</code>, which is caught by <code>&lt;Form/&gt;</code> just as if we had clicked a <code>Submit</code> button. Now the form will “navigate” on every keystroke or input to keep the URL (and therefore the search) perfectly in sync with the user’s input as they type.</p>
<p><a href="https://codesandbox.io/p/sandbox/20-form-0-5-9g7v9p?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/20-form-0-5-9g7v9p?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;h1&gt;&lt;code&gt;&quot;&lt;Form/&gt;&quot;&lt;/code&gt;&lt;/h1&gt;
            &lt;main&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;&quot; view=FormExample/&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

#[component]
pub fn FormExample() -&gt; impl IntoView {
    // reactive access to URL query
    let query = use_query_map();
    let name = move || query().get(&quot;name&quot;).cloned().unwrap_or_default();
    let number = move || query().get(&quot;number&quot;).cloned().unwrap_or_default();
    let select = move || query().get(&quot;select&quot;).cloned().unwrap_or_default();

    view! {
        // read out the URL query strings
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;&lt;/td&gt;
                &lt;td&gt;{name}&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;code&gt;&quot;number&quot;&lt;/code&gt;&lt;/td&gt;
                &lt;td&gt;{number}&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;code&gt;&quot;select&quot;&lt;/code&gt;&lt;/td&gt;
                &lt;td&gt;{select}&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        // &lt;Form/&gt; will navigate whenever submitted
        &lt;h2&gt;&quot;Manual Submission&quot;&lt;/h2&gt;
        &lt;Form method=&quot;GET&quot; action=&quot;&quot;&gt;
            // input names determine query string key
            &lt;input type=&quot;text&quot; name=&quot;name&quot; value=name/&gt;
            &lt;input type=&quot;number&quot; name=&quot;number&quot; value=number/&gt;
            &lt;select name=&quot;select&quot;&gt;
                // `selected` will set which starts as selected
                &lt;option selected=move || select() == &quot;A&quot;&gt;
                    &quot;A&quot;
                &lt;/option&gt;
                &lt;option selected=move || select() == &quot;B&quot;&gt;
                    &quot;B&quot;
                &lt;/option&gt;
                &lt;option selected=move || select() == &quot;C&quot;&gt;
                    &quot;C&quot;
                &lt;/option&gt;
            &lt;/select&gt;
            // submitting should cause a client-side
            // navigation, not a full reload
            &lt;input type=&quot;submit&quot;/&gt;
        &lt;/Form&gt;
        // This &lt;Form/&gt; uses some JavaScript to submit
        // on every input
        &lt;h2&gt;&quot;Automatic Submission&quot;&lt;/h2&gt;
        &lt;Form method=&quot;GET&quot; action=&quot;&quot;&gt;
            &lt;input
                type=&quot;text&quot;
                name=&quot;name&quot;
                value=name
                // this oninput attribute will cause the
                // form to submit on every input to the field
                oninput=&quot;this.form.requestSubmit()&quot;
            /&gt;
            &lt;input
                type=&quot;number&quot;
                name=&quot;number&quot;
                value=number
                oninput=&quot;this.form.requestSubmit()&quot;
            /&gt;
            &lt;select name=&quot;select&quot;
                onchange=&quot;this.form.requestSubmit()&quot;
            &gt;
                &lt;option selected=move || select() == &quot;A&quot;&gt;
                    &quot;A&quot;
                &lt;/option&gt;
                &lt;option selected=move || select() == &quot;B&quot;&gt;
                    &quot;B&quot;
                &lt;/option&gt;
                &lt;option selected=move || select() == &quot;C&quot;&gt;
                    &quot;C&quot;
                &lt;/option&gt;
            &lt;/select&gt;
            // submitting should cause a client-side
            // navigation, not a full reload
            &lt;input type=&quot;submit&quot;/&gt;
        &lt;/Form&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-styling"><a class="header" href="#interlude-styling">Interlude: Styling</a></h1>
<p>Anyone creating a website or application soon runs into the question of styling. For a small app, a single CSS file is probably plenty to style your user interface. But as an application grows, many developers find that plain CSS becomes increasingly hard to manage.</p>
<p>Some frontend frameworks (like Angular, Vue, and Svelte) provide built-in ways to scope your CSS to particular components, making it easier to manage styles across a whole application without styles meant to modify one small component having a global effect. Other frameworks (like React or Solid) don’t provide built-in CSS scoping, but rely on libraries in the ecosystem to do it for them. Leptos is in this latter camp: the framework itself has no opinions about CSS at all, but provides a few tools and primitives that allow others to build styling libraries.</p>
<p>Here are a few different approaches to styling your Leptos app, other than plain CSS.</p>
<h2 id="tailwindcss-utility-first-css"><a class="header" href="#tailwindcss-utility-first-css">TailwindCSS: Utility-first CSS</a></h2>
<p><a href="https://tailwindcss.com/">TailwindCSS</a> is a popular utility-first CSS library. It allows you to style your application by using inline utility classes, with a custom CLI tool that scans your files for Tailwind class names and bundles the necessary CSS.</p>
<p>This allows you to write components like this:</p>
<pre><code class="language-rust">#[component]
fn Home() -&gt; impl IntoView {
    let (count, set_count) = create_signal(0);

    view! {
        &lt;main class=&quot;my-0 mx-auto max-w-3xl text-center&quot;&gt;
            &lt;h2 class=&quot;p-6 text-4xl&quot;&gt;&quot;Welcome to Leptos with Tailwind&quot;&lt;/h2&gt;
            &lt;p class=&quot;px-10 pb-10 text-left&quot;&gt;&quot;Tailwind will scan your Rust files for Tailwind class names and compile them into a CSS file.&quot;&lt;/p&gt;
            &lt;button
                class=&quot;bg-sky-600 hover:bg-sky-700 px-5 py-3 text-white rounded-lg&quot;
                on:click=move |_| set_count.update(|count| *count += 1)
            &gt;
                {move || if count() == 0 {
                    &quot;Click me!&quot;.to_string()
                } else {
                    count().to_string()
                }}
            &lt;/button&gt;
        &lt;/main&gt;
    }
}</code></pre>
<p>It can be a little complicated to set up the Tailwind integration at first, but you can check out our two examples of how to use Tailwind with a <a href="https://github.com/leptos-rs/leptos/tree/main/examples/tailwind_csr">client-side-rendered <code>trunk</code> application</a> or with a <a href="https://github.com/leptos-rs/leptos/tree/main/examples/tailwind_actix">server-rendered <code>cargo-leptos</code> application</a>. <code>cargo-leptos</code> also has some <a href="https://github.com/leptos-rs/cargo-leptos#site-parameters">built-in Tailwind support</a> that you can use as an alternative to Tailwind’s CLI.</p>
<h2 id="stylers-compile-time-css-extraction"><a class="header" href="#stylers-compile-time-css-extraction">Stylers: Compile-time CSS Extraction</a></h2>
<p><a href="https://github.com/abishekatp/stylers">Stylers</a> is a compile-time scoped CSS library that lets you declare scoped CSS in the body of your component. Stylers will extract this CSS at compile time into CSS files that you can then import into your app, which means that it doesn’t add anything to the WASM binary size of your application.</p>
<p>This allows you to write components like this:</p>
<pre><code class="language-rust">use stylers::style;

#[component]
pub fn App() -&gt; impl IntoView {
    let styler_class = style! { &quot;App&quot;,
        #two{
            color: blue;
        }
        div.one{
            color: red;
            content: raw_str(r#&quot;\hello&quot;#);
            font: &quot;1.3em/1.2&quot; Arial, Helvetica, sans-serif;
        }
        div {
            border: 1px solid black;
            margin: 25px 50px 75px 100px;
            background-color: lightblue;
        }
        h2 {
            color: purple;
        }
        @media only screen and (max-width: 1000px) {
            h3 {
                background-color: lightblue;
                color: blue
            }
        }
    };

    view! { class = styler_class,
        &lt;div class=&quot;one&quot;&gt;
            &lt;h1 id=&quot;two&quot;&gt;&quot;Hello&quot;&lt;/h1&gt;
            &lt;h2&gt;&quot;World&quot;&lt;/h2&gt;
            &lt;h2&gt;&quot;and&quot;&lt;/h2&gt;
            &lt;h3&gt;&quot;friends!&quot;&lt;/h3&gt;
        &lt;/div&gt;
    }
}</code></pre>
<h2 id="styled-runtime-css-scoping"><a class="header" href="#styled-runtime-css-scoping">Styled: Runtime CSS Scoping</a></h2>
<p><a href="https://github.com/eboody/styled">Styled</a> is a runtime scoped CSS library that integrates well with Leptos. It lets you declare scoped CSS in the body of your component function, and then applies those styles at runtime.</p>
<pre><code class="language-rust">use styled::style;

#[component]
pub fn MyComponent() -&gt; impl IntoView {
    let styles = style!(
      div {
        background-color: red;
        color: white;
      }
    );

    styled::view! { styles,
        &lt;div&gt;&quot;This text should be red with white text.&quot;&lt;/div&gt;
    }
}</code></pre>
<h2 id="contributions-welcome"><a class="header" href="#contributions-welcome">Contributions Welcome</a></h2>
<p>Leptos has no opinions on how you style your website or app, but we’re very happy to provide support to any tools you’re trying to create to make it easier. If you’re working on a CSS or styling approach that you’d like to add to this list, please let us know!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadata"><a class="header" href="#metadata">Metadata</a></h1>
<p>So far, everything we’ve rendered has been inside the <code>&lt;body&gt;</code> of the HTML document. And this makes sense. After all, everything you can see on a web page lives inside the <code>&lt;body&gt;</code>.</p>
<p>However, there are plenty of occasions where you might want to update something inside the <code>&lt;head&gt;</code> of the document using the same reactive primitives and component patterns you use for your UI.</p>
<p>That’s where the <a href="https://docs.rs/leptos_meta/latest/leptos_meta/"><code>leptos_meta</code></a> package comes in.</p>
<h2 id="metadata-components"><a class="header" href="#metadata-components">Metadata Components</a></h2>
<p><code>leptos_meta</code> provides special components that let you inject data from inside components anywhere in your application into the <code>&lt;head&gt;</code>:</p>
<p><a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Title.html"><code>&lt;Title/&gt;</code></a> allows you to set the document’s title from any component. It also takes a <code>formatter</code> function that can be used to apply the same format to the title set by other pages. So, for example, if you put <code>&lt;Title formatter=|text| format!(&quot;{text} — My Awesome Site&quot;)/&gt;</code> in your <code>&lt;App/&gt;</code> component, and then <code>&lt;Title text=&quot;Page 1&quot;/&gt;</code> and <code>&lt;Title text=&quot;Page 2&quot;/&gt;</code> on your routes, you’ll get <code>Page 1 — My Awesome Site</code> and <code>Page 2 — My Awesome Site</code>.</p>
<p><a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Link.html"><code>&lt;Link/&gt;</code></a> takes the standard attributes of the <code>&lt;link&gt;</code> element.</p>
<p><a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Stylesheet.html"><code>&lt;Stylesheet/&gt;</code></a> creates a <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> with the <code>href</code> you give.</p>
<p><a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Style.html"><code>&lt;Style/&gt;</code></a> creates a <code>&lt;style&gt;</code> with the children you pass in (usually a string). You can use this to import some custom CSS from another file at compile time <code>&lt;Style&gt;{include_str!(&quot;my_route.css&quot;)}&lt;/Style&gt;</code>.</p>
<p><a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Meta.html"><code>&lt;Meta/&gt;</code></a> lets you set <code>&lt;meta&gt;</code> tags with descriptions and other metadata.</p>
<h2 id="script-and-script"><a class="header" href="#script-and-script"><code>&lt;Script/&gt;</code> and <code>&lt;script&gt;</code></a></h2>
<p><code>leptos_meta</code> also provides a <a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Script.html"><code>&lt;Script/&gt;</code></a> component, and it’s worth pausing here for a second. All of the other components we’ve considered inject <code>&lt;head&gt;</code>-only elements in the <code>&lt;head&gt;</code>. But a <code>&lt;script&gt;</code> can also be included in the body.</p>
<p>There’s a very simple way to determine whether you should use a capital-S <code>&lt;Script/&gt;</code> component or a lowercase-s <code>&lt;script&gt;</code> element: the <code>&lt;Script/&gt;</code> component will be rendered in the <code>&lt;head&gt;</code>, and the <code>&lt;script&gt;</code> element will be rendered wherever in the <code>&lt;body&gt;</code> of your user interface you put it in, alongside other normal HTML elements. These cause JavaScript to load and run at different times, so use whichever is appropriate to your needs.</p>
<h2 id="body-and-html"><a class="header" href="#body-and-html"><code>&lt;Body/&gt;</code> and <code>&lt;Html/&gt;</code></a></h2>
<p>There are even a couple elements designed to make semantic HTML and styling easier. <a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Html.html"><code>&lt;Html/&gt;</code></a> lets you set the <code>lang</code> and <code>dir</code> on your <code>&lt;html&gt;</code> tag from your application code. <code>&lt;Html/&gt;</code> and <a href="https://docs.rs/leptos_meta/latest/leptos_meta/fn.Body.html"><code>&lt;Body/&gt;</code></a> both have <code>class</code> props that let you set their respective <code>class</code> attributes, which is sometimes needed by CSS frameworks for styling.</p>
<p><code>&lt;Body/&gt;</code> and <code>&lt;Html/&gt;</code> both also have <code>attributes</code> props which can be used to set any number of additional attributes on them via the <code>attr:</code> syntax:</p>
<pre><code class="language-rust">&lt;Html
	lang=&quot;he&quot;
	dir=&quot;rtl&quot;
	attr:data-theme=&quot;dark&quot;
/&gt;</code></pre>
<h2 id="metadata-and-server-rendering"><a class="header" href="#metadata-and-server-rendering">Metadata and Server Rendering</a></h2>
<p>Now, some of this is useful in any scenario, but some of it is especially important for search-engine optimization (SEO). Making sure you have things like appropriate <code>&lt;title&gt;</code> and <code>&lt;meta&gt;</code> tags is crucial. Modern search engine crawlers do handle client-side rendering, i.e., apps that are shipped as an empty <code>index.html</code> and rendered entirely in JS/WASM. But they prefer to receive pages in which your app has been rendered to actual HTML, with metadata in the <code>&lt;head&gt;</code>.</p>
<p>This is exactly what <code>leptos_meta</code> is for. And in fact, during server rendering, this is exactly what it does: collect all the <code>&lt;head&gt;</code> content you’ve declared by using its components throughout your application, and then inject it into the actual <code>&lt;head&gt;</code>.</p>
<p>But I’m getting ahead of myself. We haven’t actually talked about server-side rendering yet. As a matter of fact... Let’s do that next!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-part-1-client-side-rendering"><a class="header" href="#wrapping-up-part-1-client-side-rendering">Wrapping Up Part 1: Client-Side Rendering</a></h1>
<p>So far, everything we’ve written has been rendered almost entirely in the browser. When we create an app using Trunk, it’s served using a local development server. If you build it for production and deploy it, it’s served by whatever server or CDN you’re using. In either case, what’s served is an HTML page with</p>
<ol>
<li>the URL of your Leptos app, which has been compiled to WebAssembly (WASM)</li>
<li>the URL of the JavaScript used to initialize this WASM blob</li>
<li>an empty <code>&lt;body&gt;</code> element</li>
</ol>
<p>When the JS and WASM have loaded, Leptos will render your app into the <code>&lt;body&gt;</code>. This means that nothing appears on the screen until JS/WASM have loaded and run. This has some drawbacks:</p>
<ol>
<li>It increases load time, as your user’s screen is blank until additional resources have been downloaded.</li>
<li>It’s bad for SEO, as load times are longer and the HTML you serve has no meaningful content.</li>
<li>It’s broken for users for whom JS/WASM don’t load for some reason (e.g., they’re on a train and just went into a tunnel before WASM finished loading; they’re using an older device that doesn’t support WASM; they have JavaScript or WASM turned off for some reason; etc.)</li>
</ol>
<p>These downsides apply across the web ecosystem, but especially to WASM apps.</p>
<p>However, depending the on the requirements of your project, you may be fine with these limitations.</p>
<p>If you just want to deploy your Client-Side Rendered website, skip ahead to the chapter on <a href="https://leptos-rs.github.io/leptos/deployment/index.html">&quot;Deployment&quot;</a> - there, you'll find directions on how best to deploy your Leptos CSR site.</p>
<p>But what do you do if you want to return more than just an empty <code>&lt;body&gt;</code> tag in your <code>index.html</code> page? Use “Server-Side Rendering”!</p>
<p>Whole books could be (and probably have been) written about this topic, but at its core, it’s really simple: rather than returning an empty <code>&lt;body&gt;</code> tag, with SSR, you'll return an initial HTML page that reflects the actual starting state of your app or site, so that while JS/WASM are loading, and until they load, the user can access the plain HTML version.</p>
<p>Part 2 of this book, on Leptos SSR, will cover this topic in some detail!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-2-server-side-rendering"><a class="header" href="#part-2-server-side-rendering">Part 2: Server Side Rendering</a></h1>
<p>The second part of the book is all about how to turn your beautiful UIs into full-stack Rust + Leptos powered websites and applications.</p>
<p>As you read in the last chapter, there are some limitations to using client-side rendered Leptos apps - over the next few chapters, you'll see how we can overcome those limitations
and get the best performance and SEO out of your Leptos apps.</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="ssr/index.html#admonition-info"></a></p>
</div>
<div>
<p>When working with Leptos on the server side, you're free to choose either the Actix-web or the Axum integrations - the full feature set of Leptos is available with either option.</p>
<p>If, however, you need deploy to a WinterCG-compatible runtime like Deno, Cloudflare, etc., then choose the Axum integration as this deployment option is only available with Axum on the server. Lastly, if you'd like to go full-stack WASM/WASI and deploy to WASM-based serverless runtimes, then Axum is your go-to choice here too.</p>
<p>NB: this is a limitation of the web frameworks themselves, not Leptos.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-cargo-leptos"><a class="header" href="#introducing-cargo-leptos">Introducing <code>cargo-leptos</code></a></h1>
<p>So far, we’ve just been running code in the browser and using Trunk to coordinate the build process and run a local development process. If we’re going to add server-side rendering, we’ll need to run our application code on the server as well. This means we’ll need to build two separate binaries, one compiled to native code and running the server, the other compiled to WebAssembly (WASM) and running in the user’s browser. Additionally, the server needs to know how to serve this WASM version (and the JavaScript required to initialize it) to the browser.</p>
<p>This is not an insurmountable task but it adds some complication. For convenience and an easier developer experience, we built the <a href="https://github.com/leptos-rs/cargo-leptos"><code>cargo-leptos</code></a> build tool. <code>cargo-leptos</code> basically exists to coordinate the build process for your app, handling recompiling the server and client halves when you make changes, and adding some built-in support for things like Tailwind, SASS, and testing.</p>
<p>Getting started is pretty easy. Just run</p>
<pre><code class="language-bash">cargo install cargo-leptos
</code></pre>
<p>And then to create a new project, you can run either</p>
<pre><code class="language-bash"># for an Actix template
cargo leptos new --git leptos-rs/start
</code></pre>
<p>or</p>
<pre><code class="language-bash"># for an Axum template
cargo leptos new --git leptos-rs/start-axum
</code></pre>
<p>Now <code>cd</code> into the directory you’ve created and run</p>
<pre><code class="language-bash">cargo leptos watch
</code></pre>
<p>Once your app has compiled you can open up your browser to <a href="http://localhost:3000"><code>http://localhost:3000</code></a> to see it.</p>
<p><code>cargo-leptos</code> has lots of additional features and built in tools. You can learn more <a href="https://github.com/leptos-rs/cargo-leptos/blob/main/README.md">in its <code>README</code></a>.</p>
<p>But what exactly is happening when you open our browser to <code>localhost:3000</code>? Well, read on to find out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-life-of-a-page-load"><a class="header" href="#the-life-of-a-page-load">The Life of a Page Load</a></h1>
<p>Before we get into the weeds it might be helpful to have a higher-level overview. What exactly happens between the moment you type in the URL of a server-rendered Leptos app, and the moment you click a button and a counter increases?</p>
<p>I’m assuming some basic knowledge of how the Internet works here, and won’t get into the weeds about HTTP or whatever. Instead, I’ll try to show how different parts of the Leptos APIs map onto each part of the process.</p>
<p>This description also starts from the premise that your app is being compiled for two separate targets:</p>
<ol>
<li>A server version, often running on Actix or Axum, compiled with the Leptos <code>ssr</code> feature</li>
<li>A browser version, compiled to WebAssembly (WASM) with the Leptos <code>hydrate</code> feature</li>
</ol>
<p>The <a href="https://github.com/leptos-rs/cargo-leptos"><code>cargo-leptos</code></a> build tool exists to coordinate the process of compiling your app for these two different targets.</p>
<h2 id="on-the-server"><a class="header" href="#on-the-server">On the Server</a></h2>
<ul>
<li>Your browser makes a <code>GET</code> request for that URL to your server. At this point, the browser knows almost nothing about the page that’s going to be rendered. (The question “How does the browser know where to ask for the page?” is an interesting one, but out of the scope of this tutorial!)</li>
<li>The server receives that request, and checks whether it has a way to handle a <code>GET</code> request at that path. This is what the <code>.leptos_routes()</code> methods in <a href="https://docs.rs/leptos_axum/0.2.5/leptos_axum/trait.LeptosRoutes.html"><code>leptos_axum</code></a> and <a href="https://docs.rs/leptos_actix/0.2.5/leptos_actix/trait.LeptosRoutes.html"><code>leptos_actix</code></a> are for. When the server starts up, these methods walk over the routing structure you provide in <code>&lt;Routes/&gt;</code>, generating a list of all possible routes your app can handle and telling the server’s router “for each of these routes, if you get a request... hand it off to Leptos.”</li>
<li>The server sees that this route can be handled by Leptos. So it renders your root component (often called something like <code>&lt;App/&gt;</code>), providing it with the URL that’s being requested and some other data like the HTTP headers and request metadata.</li>
<li>Your application runs once on the server, building up an HTML version of the component tree that will be rendered at that route. (There’s more to be said here about resources and <code>&lt;Suspense/&gt;</code> in the next chapter.)</li>
<li>The server returns this HTML page, also injecting information on how to load the version of your app that has been compiled to WASM so that it can run in the browser.</li>
</ul>
<blockquote>
<p>The HTML page that’s returned is essentially your app, “dehydrated” or “freeze-dried”: it is HTML without any of the reactivity or event listeners you’ve added. The browser will “rehydrate” this HTML page by adding the reactive system and attaching event listeners to that server-rendered HTML. Hence the two feature flags that apply to the two halves of this process: <code>ssr</code> on the server for “server-side rendering”, and <code>hydrate</code> in the browser for that process of rehydration.</p>
</blockquote>
<h2 id="in-the-browser"><a class="header" href="#in-the-browser">In the Browser</a></h2>
<ul>
<li>The browser receives this HTML page from the server. It immediately goes back to the server to begin loading the JS and WASM necessary to run the interactive, client side version of the app.</li>
<li>In the meantime, it renders the HTML version.</li>
<li>When the WASM version has reloaded, it does the same route-matching process that the server did. Because the <code>&lt;Routes/&gt;</code> component is identical on the server and in the client, the browser version will read the URL and render the same page that was already returned by the server.</li>
<li>During this initial “hydration” phase, the WASM version of your app doesn’t re-create the DOM nodes that make up your application. Instead, it walks over the existing HTML tree, “picking up” existing elements and adding the necessary interactivity.</li>
</ul>
<blockquote>
<p>Note that there are some trade-offs here. Before this hydration process is complete, the page will <em>appear</em> interactive but won’t actually respond to interactions. For example, if you have a counter button and click it before WASM has loaded, the count will not increment, because the necessary event listeners and reactivity have not been added yet. We’ll look at some ways to build in “graceful degradation” in future chapters.</p>
</blockquote>
<h2 id="client-side-navigation"><a class="header" href="#client-side-navigation">Client-Side Navigation</a></h2>
<p>The next step is very important. Imagine that the user now clicks a link to navigate to another page in your application.</p>
<p>The browser will <em>not</em> make another round trip to the server, reloading the full page as it would for navigating between plain HTML pages or an application that uses server rendering (for example with PHP) but without a client-side half.</p>
<p>Instead, the WASM version of your app will load the new page, right there in the browser, without requesting another page from the server. Essentially, your app upgrades itself from a server-loaded “multi-page app” into a browser-rendered “single-page app.” This yields the best of both worlds: a fast initial load time due to the server-rendered HTML, and fast secondary navigations because of the client-side routing.</p>
<p>Some of what will be described in the following chapters—like the interactions between server functions, resources, and <code>&lt;Suspense/&gt;</code>—may seem overly complicated. You might find yourself asking, “If my page is being rendered to HTML on the server, why can’t I just <code>.await</code> this on the server? If I can just call library X in a server function, why can’t I call it in my component?” The reason is pretty simple: to enable the upgrade from server rendering to client rendering, everything in your application must be able to run either on the server or in the browser.</p>
<p>This is not the only way to create a website or web framework, of course. But it’s the most common way, and we happen to think it’s quite a good way, to create the smoothest possible experience for your users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-rendering-and-ssr-modes"><a class="header" href="#async-rendering-and-ssr-modes">Async Rendering and SSR “Modes”</a></h1>
<p>Server-rendering a page that uses only synchronous data is pretty simple: You just walk down the component tree, rendering each element to an HTML string. But this is a pretty big caveat: it doesn’t answer the question of what we should do with pages that includes asynchronous data, i.e., the sort of stuff that would be rendered under a <code>&lt;Suspense/&gt;</code> node on the client.</p>
<p>When a page loads async data that it needs to render, what should we do? Should we wait for all the async data to load, and then render everything at once? (Let’s call this “async” rendering) Should we go all the way in the opposite direction, just sending the HTML we have immediately down to the client and letting the client load the resources and fill them in? (Let’s call this “synchronous” rendering) Or is there some middle-ground solution that somehow beats them both? (Hint: There is.)</p>
<p>If you’ve ever listened to streaming music or watched a video online, I’m sure you realize that HTTP supports streaming, allowing a single connection to send chunks of data one after another without waiting for the full content to load. You may not realize that browsers are also really good at rendering partial HTML pages. Taken together, this means that you can actually enhance your users’ experience by <strong>streaming HTML</strong>: and this is something that Leptos supports out of the box, with no configuration at all. And there’s actually more than one way to stream HTML: you can stream the chunks of HTML that make up your page in order, like frames of a video, or you can stream them... well, out of order.</p>
<p>Let me say a little more about what I mean.</p>
<p>Leptos supports all the major ways of rendering HTML that includes asynchronous data:</p>
<ol>
<li><a href="ssr/23_ssr_modes.html#synchronous-rendering">Synchronous Rendering</a></li>
<li><a href="ssr/23_ssr_modes.html#async-rendering">Async Rendering</a></li>
<li><a href="ssr/23_ssr_modes.html#in-order-streaming">In-Order streaming</a></li>
<li><a href="ssr/23_ssr_modes.html#out-of-order-streaming">Out-of-Order Streaming</a> (and a partially-blocked variant)</li>
</ol>
<h2 id="synchronous-rendering"><a class="header" href="#synchronous-rendering">Synchronous Rendering</a></h2>
<ol>
<li><strong>Synchronous</strong>: Serve an HTML shell that includes <code>fallback</code> for any <code>&lt;Suspense/&gt;</code>. Load data on the client using <code>create_local_resource</code>, replacing <code>fallback</code> once resources are loaded.</li>
</ol>
<ul>
<li><em>Pros</em>: App shell appears very quickly: great TTFB (time to first byte).</li>
<li><em>Cons</em>
<ul>
<li>Resources load relatively slowly; you need to wait for JS + WASM to load before even making a request.</li>
<li>No ability to include data from async resources in the <code>&lt;title&gt;</code> or other <code>&lt;meta&gt;</code> tags, hurting SEO and things like social media link previews.</li>
</ul>
</li>
</ul>
<p>If you’re using server-side rendering, the synchronous mode is almost never what you actually want, from a performance perspective. This is because it misses out on an important optimization. If you’re loading async resources during server rendering, you can actually begin loading the data on the server. Rather than waiting for the client to receive the HTML response, then loading its JS + WASM, <em>then</em> realize it needs the resources and begin loading them, server rendering can actually begin loading the resources when the client first makes the response. In this sense, during server rendering an async resource is like a <code>Future</code> that begins loading on the server and resolves on the client. As long as the resources are actually serializable, this will always lead to a faster total load time.</p>
<blockquote>
<p>This is why <a href="https://docs.rs/leptos/latest/leptos/fn.create_resource.html"><code>create_resource</code></a> requires resources data to be serializable by default, and why you need to explicitly use <a href="https://docs.rs/leptos/latest/leptos/fn.create_local_resource.html"><code>create_local_resource</code></a> for any async data that is not serializable and should therefore only be loaded in the browser itself. Creating a local resource when you could create a serializable resource is always a deoptimization.</p>
</blockquote>
<h2 id="async-rendering"><a class="header" href="#async-rendering">Async Rendering</a></h2>
<video controls>
	<source src="https://github.com/leptos-rs/leptos/blob/main/docs/video/async.mov?raw=true" type="video/mp4">
</video>
<ol start="2">
<li><strong><code>async</code></strong>: Load all resources on the server. Wait until all data are loaded, and render HTML in one sweep.</li>
</ol>
<ul>
<li><em>Pros</em>: Better handling for meta tags (because you know async data even before you render the <code>&lt;head&gt;</code>). Faster complete load than <strong>synchronous</strong> because async resources begin loading on server.</li>
<li><em>Cons</em>: Slower load time/TTFB: you need to wait for all async resources to load before displaying anything on the client. The page is totally blank until everything is loaded.</li>
</ul>
<h2 id="in-order-streaming"><a class="header" href="#in-order-streaming">In-Order Streaming</a></h2>
<video controls>
	<source src="https://github.com/leptos-rs/leptos/blob/main/docs/video/in-order.mov?raw=true" type="video/mp4">
</video>
<ol start="3">
<li><strong>In-order streaming</strong>: Walk through the component tree, rendering HTML until you hit a <code>&lt;Suspense/&gt;</code>. Send down all the HTML you’ve got so far as a chunk in the stream, wait for all the resources accessed under the <code>&lt;Suspense/&gt;</code> to load, then render it to HTML and keep walking until you hit another <code>&lt;Suspense/&gt;</code> or the end of the page.</li>
</ol>
<ul>
<li><em>Pros</em>: Rather than a blank screen, shows at least <em>something</em> before the data are ready.</li>
<li><em>Cons</em>
<ul>
<li>Loads the shell more slowly than synchronous rendering (or out-of-order streaming) because it needs to pause at every <code>&lt;Suspense/&gt;</code>.</li>
<li>Unable to show fallback states for <code>&lt;Suspense/&gt;</code>.</li>
<li>Can’t begin hydration until the entire page has loaded, so earlier pieces of the page will not be interactive until the suspended chunks have loaded.</li>
</ul>
</li>
</ul>
<h2 id="out-of-order-streaming"><a class="header" href="#out-of-order-streaming">Out-of-Order Streaming</a></h2>
<video controls>
	<source src="https://github.com/leptos-rs/leptos/blob/main/docs/video/out-of-order.mov?raw=true" type="video/mp4">
</video>
<ol start="4">
<li><strong>Out-of-order streaming</strong>: Like synchronous rendering, serve an HTML shell that includes <code>fallback</code> for any <code>&lt;Suspense/&gt;</code>. But load data on the <strong>server</strong>, streaming it down to the client as it resolves, and streaming down HTML for <code>&lt;Suspense/&gt;</code> nodes, which is swapped in to replace the fallback.</li>
</ol>
<ul>
<li><em>Pros</em>: Combines the best of <strong>synchronous</strong> and <strong><code>async</code></strong>.
<ul>
<li>Fast initial response/TTFB because it immediately sends the whole synchronous shell</li>
<li>Fast total time because resources begin loading on the server.</li>
<li>Able to show the fallback loading state and dynamically replace it, instead of showing blank sections for un-loaded data.</li>
</ul>
</li>
<li><em>Cons</em>: Requires JavaScript to be enabled for suspended fragments to appear in correct order. (This small chunk of JS streamed down in a <code>&lt;script&gt;</code> tag alongside the <code>&lt;template&gt;</code> tag that contains the rendered <code>&lt;Suspense/&gt;</code> fragment, so it does not need to load any additional JS files.)</li>
</ul>
<ol start="5">
<li><strong>Partially-blocked streaming</strong>: “Partially-blocked” streaming is useful when you have multiple separate <code>&lt;Suspense/&gt;</code> components on the page.  It is triggered by setting <code>ssr=SsrMode::PartiallyBlocked</code> on a route, and depending on blocking resources within the view.   If one of the <code>&lt;Suspense/&gt;</code> components reads from one or more “blocking resources” (see below), the fallback will not be sent; rather, the server will wait until that <code>&lt;Suspense/&gt;</code> has resolved and then replace the fallback with the resolved fragment on the server, which means that it is included in the initial HTML response and appears even if JavaScript is disabled or not supported. Other <code>&lt;Suspense/&gt;</code> stream in out of order, similar to the <code>SsrMode::OutOfOrder</code> default.</li>
</ol>
<p>This is useful when you have multiple <code>&lt;Suspense/&gt;</code> on the page, and one is more important than the other: think of a blog post and comments, or product information and reviews. It is <em>not</em> useful if there’s only one <code>&lt;Suspense/&gt;</code>, or if every <code>&lt;Suspense/&gt;</code> reads from blocking resources. In those cases it is a slower form of <code>async</code> rendering.</p>
<ul>
<li><em>Pros</em>: Works if JavaScript is disabled or not supported on the user’s device.</li>
<li><em>Cons</em>
<ul>
<li>Slower initial response time than out-of-order.</li>
<li>Marginally overall response due to additional work on the server.</li>
<li>No fallback state shown.</li>
</ul>
</li>
</ul>
<h2 id="using-ssr-modes"><a class="header" href="#using-ssr-modes">Using SSR Modes</a></h2>
<p>Because it offers the best blend of performance characteristics, Leptos defaults to out-of-order streaming. But it’s really simple to opt into these different modes. You do it by adding an <code>ssr</code> property onto one or more of your <code>&lt;Route/&gt;</code> components, like in the <a href="https://github.com/leptos-rs/leptos/blob/main/examples/ssr_modes/src/app.rs"><code>ssr_modes</code> example</a>.</p>
<pre><code class="language-rust">&lt;Routes&gt;
	// We’ll load the home page with out-of-order streaming and &lt;Suspense/&gt;
	&lt;Route path=&quot;&quot; view=HomePage/&gt;

	// We'll load the posts with async rendering, so they can set
	// the title and metadata *after* loading the data
	&lt;Route
		path=&quot;/post/:id&quot;
		view=Post
		ssr=SsrMode::Async
	/&gt;
&lt;/Routes&gt;</code></pre>
<p>For a path that includes multiple nested routes, the most restrictive mode will be used: i.e., if even a single nested route asks for <code>async</code> rendering, the whole initial request will be rendered <code>async</code>. <code>async</code> is the most restricted requirement, followed by in-order, and then out-of-order. (This probably makes sense if you think about it for a few minutes.)</p>
<h2 id="blocking-resources"><a class="header" href="#blocking-resources">Blocking Resources</a></h2>
<p>Any Leptos versions later than <code>0.2.5</code> (i.e., git main and <code>0.3.x</code> or later) introduce a new resource primitive with <code>create_blocking_resource</code>. A blocking resource still loads asynchronously like any other <code>async</code>/<code>.await</code> in Rust; it doesn’t block a server thread or anything. Instead, reading from a blocking resource under a <code>&lt;Suspense/&gt;</code> blocks the HTML <em>stream</em> from returning anything, including its initial synchronous shell, until that <code>&lt;Suspense/&gt;</code> has resolved.</p>
<p>Now from a performance perspective, this is not ideal. None of the synchronous shell for your page will load until that resource is ready. However, rendering nothing means that you can do things like set the <code>&lt;title&gt;</code> or <code>&lt;meta&gt;</code> tags in your <code>&lt;head&gt;</code> in actual HTML. This sounds a lot like <code>async</code> rendering, but there’s one big difference: if you have multiple <code>&lt;Suspense/&gt;</code> sections, you can block on <em>one</em> of them but still render a placeholder and then stream in the other.</p>
<p>For example, think about a blog post. For SEO and for social sharing, I definitely want my blog post’s title and metadata in the initial HTML <code>&lt;head&gt;</code>. But I really don’t care whether comments have loaded yet or not; I’d like to load those as lazily as possible.</p>
<p>With blocking resources, I can do something like this:</p>
<pre><code class="language-rust">#[component]
pub fn BlogPost() -&gt; impl IntoView {
	let post_data = create_blocking_resource(/* load blog post */);
	let comment_data = create_resource(/* load blog post */);
	view! {
		&lt;Suspense fallback=|| ()&gt;
			{move || {
				post_data.with(|data| {
					view! {
						&lt;Title text=data.title/&gt;
						&lt;Meta name=&quot;description&quot; content=data.excerpt/&gt;
						&lt;article&gt;
							/* render the post content */
						&lt;/article&gt;
					}
				})
			}}
		&lt;/Suspense&gt;
		&lt;Suspense fallback=|| &quot;Loading comments...&quot;&gt;
			/* render comment data here */
		&lt;/Suspense&gt;
	}
}</code></pre>
<p>The first <code>&lt;Suspense/&gt;</code>, with the body of the blog post, will block my HTML stream, because it reads from a blocking resource.  Meta tags and other head elements awaiting the blocking resource will be rendered before the stream is sent.</p>
<p>Combined with the following route definition, which uses <code>SsrMode::PartiallyBlocked</code>, the blocking resource will be fully rendered on the server side, making it accessible to users who disable WebAssembly or JavaScript.</p>
<pre><code class="language-rust">&lt;Routes&gt;
	// We’ll load the home page with out-of-order streaming and &lt;Suspense/&gt;
	&lt;Route path=&quot;&quot; view=HomePage/&gt;

	// We'll load the posts with async rendering, so they can set
	// the title and metadata *after* loading the data
	&lt;Route
		path=&quot;/post/:id&quot;
		view=Post
		ssr=SsrMode::PartiallyBlocked
	/&gt;
&lt;/Routes&gt;</code></pre>
<p>The second <code>&lt;Suspense/&gt;</code>, with the comments, will not block the stream. Blocking resources gave me exactly the power and granularity I needed to optimize my page for SEO and user experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hydration-bugs-and-how-to-avoid-them"><a class="header" href="#hydration-bugs-and-how-to-avoid-them">Hydration Bugs <em>(and how to avoid them)</em></a></h1>
<h2 id="a-thought-experiment"><a class="header" href="#a-thought-experiment">A Thought Experiment</a></h2>
<p>Let’s try an experiment to test your intuitions. Open up an app you’re server-rendering with <code>cargo-leptos</code>. (If you’ve just been using <code>trunk</code> so far to play with examples, go <a href="ssr/./21_cargo_leptos.html">clone a <code>cargo-leptos</code> template</a> just for the sake of this exercise.)</p>
<p>Put a log somewhere in your root component. (I usually call mine <code>&lt;App/&gt;</code>, but anything will do.)</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
	logging::log!(&quot;where do I run?&quot;);
	// ... whatever
}</code></pre>
<p>And let’s fire it up</p>
<pre><code class="language-bash">cargo leptos watch
</code></pre>
<p>Where do you expect <code>where do I run?</code> to log?</p>
<ul>
<li>In the command line where you’re running the server?</li>
<li>In the browser console when you load the page?</li>
<li>Neither?</li>
<li>Both?</li>
</ul>
<p>Try it out.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>Okay, consider the spoiler alerted.</p>
<p>You’ll notice of course that it logs in both places, assuming everything goes according to plan. In fact on the server it logs twice—first during the initial server startup, when Leptos renders your app once to extract the route tree, then a second time when you make a request. Each time you reload the page, <code>where do I run?</code> should log once on the server and once on the client.</p>
<p>If you think about the description in the last couple sections, hopefully this makes sense. Your application runs once on the server, where it builds up a tree of HTML which is sent to the client. During this initial render, <code>where do I run?</code> logs on the server.</p>
<p>Once the WASM binary has loaded in the browser, your application runs a second time, walking over the same user interface tree and adding interactivity.</p>
<blockquote>
<p>Does that sound like a waste? It is, in a sense. But reducing that waste is a genuinely hard problem. It’s what some JS frameworks like Qwik are intended to solve, although it’s probably too early to tell whether it’s a net performance gain as opposed to other approaches.</p>
</blockquote>
<h2 id="the-potential-for-bugs"><a class="header" href="#the-potential-for-bugs">The Potential for Bugs</a></h2>
<p>Okay, hopefully all of that made sense. But what does it have to do with the title of this chapter, which is “Hydration bugs (and how to avoid them)”?</p>
<p>Remember that the application needs to run on both the server and the client. This generates a few different sets of potential issues you need to know how to avoid.</p>
<h3 id="mismatches-between-server-and-client-code"><a class="header" href="#mismatches-between-server-and-client-code">Mismatches between server and client code</a></h3>
<p>One way to create a bug is by creating a mismatch between the HTML that’s sent down by the server and what’s rendered on the client. It’s actually fairly hard to do this unintentionally, I think (at least judging by the bug reports I get from people.) But imagine I do something like this</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let data = if cfg!(target_arch = &quot;wasm32&quot;) {
        vec![0, 1, 2]
    } else {
        vec![]
    };
    data.into_iter()
        .map(|value| view! { &lt;span&gt;{value}&lt;/span&gt; })
        .collect_view()
}</code></pre>
<p>In other words, if this is being compiled to WASM, it has three items; otherwise it’s empty.</p>
<p>When I load the page in the browser, I see nothing. If I open the console I see a bunch of warnings:</p>
<pre><code>element with id 0-3 not found, ignoring it for hydration
element with id 0-4 not found, ignoring it for hydration
element with id 0-5 not found, ignoring it for hydration
component with id _0-6c not found, ignoring it for hydration
component with id _0-6o not found, ignoring it for hydration
</code></pre>
<p>The WASM version of your app, running in the browser, expects to find three items; but the HTML has none.</p>
<h4 id="solution-1"><a class="header" href="#solution-1">Solution</a></h4>
<p>It’s pretty rare that you do this intentionally, but it could happen from somehow running different logic on the server and in the browser. If you’re seeing warnings like this and you don’t think it’s your fault, it’s much more likely that it’s a bug with <code>&lt;Suspense/&gt;</code> or something. Feel free to go ahead and open an <a href="https://github.com/leptos-rs/leptos/issues">issue</a> or <a href="https://github.com/leptos-rs/leptos/discussions">discussion</a> on GitHub for help.</p>
<h4 id="solution-2"><a class="header" href="#solution-2">Solution</a></h4>
<p>You can simply tell the effect to wait a tick before updating the signal, by using something like <code>request_animation_frame</code>, which will set a short timeout and then update the signal before the next frame.</p>
<pre><code class="language-rust">create_effect(move |_| {
    // do something like reading from localStorage
    request_animation_frame(move || set_loaded(true));
});</code></pre>
<p>This allows the browser to hydrate with the correct, matching state (<code>loaded</code> is <code>false</code> when it reaches the view), then immediately update it to <code>true</code> once hydration is complete.</p>
<h3 id="not-all-client-code-can-run-on-the-server"><a class="header" href="#not-all-client-code-can-run-on-the-server">Not all client code can run on the server</a></h3>
<p>Imagine you happily import a dependency like <code>gloo-net</code> that you’ve been used to using to make requests in the browser, and use it in a <code>create_resource</code> in a server-rendered app.</p>
<p>You’ll probably instantly see the dreaded message</p>
<pre><code>panicked at 'cannot call wasm-bindgen imported functions on non-wasm targets'
</code></pre>
<p>Uh-oh.</p>
<p>But of course this makes sense. We’ve just said that your app needs to run on the client and the server.</p>
<h4 id="solution-3"><a class="header" href="#solution-3">Solution</a></h4>
<p>There are a few ways to avoid this:</p>
<ol>
<li>Only use libraries that can run on both the server and the client. <code>reqwest</code>, for example, works for making HTTP requests in both settings.</li>
<li>Use different libraries on the server and the client, and gate them using the <code>#[cfg]</code> macro. (<a href="https://github.com/leptos-rs/leptos/blob/main/examples/hackernews/src/api.rs">Click here for an example</a>.)</li>
<li>Wrap client-only code in <code>create_effect</code>. Because <code>create_effect</code> only runs on the client, this can be an effective way to access browser APIs that are not needed for initial rendering.</li>
</ol>
<p>For example, say that I want to store something in the browser’s <code>localStorage</code> whenever a signal changes.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    use gloo_storage::Storage;
	let storage = gloo_storage::LocalStorage::raw();
	logging::log!(&quot;{storage:?}&quot;);
}</code></pre>
<p>This panics because I can’t access <code>LocalStorage</code> during server rendering.</p>
<p>But if I wrap it in an effect...</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    use gloo_storage::Storage;
    create_effect(move |_| {
        let storage = gloo_storage::LocalStorage::raw();
		logging::log!(&quot;{storage:?}&quot;);
    });
}</code></pre>
<p>It’s fine! This will render appropriately on the server, ignoring the client-only code, and then access the storage and log a message on the browser.</p>
<h3 id="not-all-server-code-can-run-on-the-client"><a class="header" href="#not-all-server-code-can-run-on-the-client">Not all server code can run on the client</a></h3>
<p>WebAssembly running in the browser is a pretty limited environment. You don’t have access to a file-system or to many of the other things the standard library may be used to having. Not every crate can even be compiled to WASM, let alone run in a WASM environment.</p>
<p>In particular, you’ll sometimes see errors about the crate <code>mio</code> or missing things from <code>core</code>. This is generally a sign that you are trying to compile something to WASM that can’t be compiled to WASM. If you’re adding server-only dependencies, you’ll want to mark them <code>optional = true</code> in your <code>Cargo.toml</code> and then enable them in the <code>ssr</code> feature definition. (Check out one of the template <code>Cargo.toml</code> files to see more details.)</p>
<p>You can use <code>create_effect</code> to specify that something should only run on the client, and not in the server. Is there a way to specify that something should run only on the server, and not the client?</p>
<p>In fact, there is. The next chapter will cover the topic of server functions in some detail. (In the meantime, you can check out their docs <a href="https://docs.rs/leptos_server/latest/leptos_server/index.html">here</a>.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-the-server"><a class="header" href="#working-with-the-server">Working with the Server</a></h1>
<p>The previous section described the process of server-side rendering, using the server to generate an HTML version of the page that will become interactive in the browser. So far, everything has been “isomorphic”; in other words, your app has had the “same (<em>iso</em>) shape (<em>morphe</em>)” on the client and the server.</p>
<p>But a server can do a lot more than just render HTML! In fact, a server can do a whole bunch of things your browser <em>can’t,</em> like reading from and writing to a SQL database.</p>
<p>If you’re used to building JavaScript frontend apps, you’re probably used to calling out to some kind of REST API to do this sort of server work. If you’re used to building sites with PHP or Python or Ruby (or Java or C# or...), this server-side work is your bread and butter, and it’s the client-side interactivity that tends to be an afterthought.</p>
<p>With Leptos, you can do both: not only in the same language, not only sharing the same types, but even in the same files!</p>
<p>This section will talk about how to build the uniquely-server-side parts of your application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-functions"><a class="header" href="#server-functions">Server Functions</a></h1>
<p>If you’re creating anything beyond a toy app, you’ll need to run code on the server all the time: reading from or writing to a database that only runs on the server, running expensive computations using libraries you don’t want to ship down to the client, accessing APIs that need to be called from the server rather than the client for CORS reasons or because you need a secret API key that’s stored on the server and definitely shouldn’t be shipped down to a user’s browser.</p>
<p>Traditionally, this is done by separating your server and client code, and by setting up something like a REST API or GraphQL API to allow your client to fetch and mutate data on the server. This is fine, but it requires you to write and maintain your code in multiple separate places (client-side code for fetching, server-side functions to run), as well as creating a third thing to manage, which is the API contract between the two.</p>
<p>Leptos is one of a number of modern frameworks that introduce the concept of <strong>server functions</strong>. Server functions have two key characteristics:</p>
<ol>
<li>Server functions are <strong>co-located</strong> with your component code, so that you can organize your work by feature, not by technology. For example, you might have a “dark mode” feature that should persist a user’s dark/light mode preference across sessions, and be applied during server rendering so there’s no flicker. This requires a component that needs to be interactive on the client, and some work to be done on the server (setting a cookie, maybe even storing a user in a database.) Traditionally, this feature might end up being split between two different locations in your code, one in your “frontend” and one in your “backend.” With server functions, you’ll probably just write them both in one <code>dark_mode.rs</code> and forget about it.</li>
<li>Server functions are <strong>isomorphic</strong>, i.e., they can be called either from the server or the browser. This is done by generating code differently for the two platforms. On the server, a server function simply runs. In the browser, the server function’s body is replaced with a stub that actually makes a fetch request to the server, serializing the arguments into the request and deserializing the return value from the response. But on either end, the function can simply be called: you can create an <code>add_todo</code> function that writes to your database, and simply call it from a click handler on a button in the browser!</li>
</ol>
<h2 id="using-server-functions"><a class="header" href="#using-server-functions">Using Server Functions</a></h2>
<p>Actually, I kind of like that example. What would it look like? It’s pretty simple, actually.</p>
<pre><code class="language-rust">// todo.rs

#[server(AddTodo, &quot;/api&quot;)]
pub async fn add_todo(title: String) -&gt; Result&lt;(), ServerFnError&gt; {
    let mut conn = db().await?;

    match sqlx::query(&quot;INSERT INTO todos (title, completed) VALUES ($1, false)&quot;)
        .bind(title)
        .execute(&amp;mut conn)
        .await
    {
        Ok(_row) =&gt; Ok(()),
        Err(e) =&gt; Err(ServerFnError::ServerError(e.to_string())),
    }
}

#[component]
pub fn BusyButton() -&gt; impl IntoView {
	view! {
        &lt;button on:click=move |_| {
            spawn_local(async {
                add_todo(&quot;So much to do!&quot;.to_string()).await;
            });
        }&gt;
            &quot;Add Todo&quot;
        &lt;/button&gt;
	}
}</code></pre>
<p>You’ll notice a couple things here right away:</p>
<ul>
<li>Server functions can use server-only dependencies, like <code>sqlx</code>, and can access server-only resources, like our database.</li>
<li>Server functions are <code>async</code>. Even if they only did synchronous work on the server, the function signature would still need to be <code>async</code>, because calling them from the browser <em>must</em> be asynchronous.</li>
<li>Server functions return <code>Result&lt;T, ServerFnError&gt;</code>. Again, even if they only do infallible work on the server, this is true, because <code>ServerFnError</code>’s variants include the various things that can be wrong during the process of making a network request.</li>
<li>Server functions can be called from the client. Take a look at our click handler. This is code that will <em>only ever</em> run on the client. But it can call the function <code>add_todo</code> (using <code>spawn_local</code> to run the <code>Future</code>) as if it were an ordinary async function:</li>
</ul>
<pre><code class="language-rust">move |_| {
	spawn_local(async {
		add_todo(&quot;So much to do!&quot;.to_string()).await;
	});
}</code></pre>
<ul>
<li>Server functions are top-level functions defined with <code>fn</code>. Unlike event listeners, derived signals, and most everything else in Leptos, they are not closures! As <code>fn</code> calls, they have no access to the reactive state of your app or anything else that is not passed in as an argument. And again, this makes perfect sense: When you make a request to the server, the server doesn’t have access to client state unless you send it explicitly. (Otherwise we’d have to serialize the whole reactive system and send it across the wire with every request, which—while it served classic ASP for a while—is a really bad idea.)</li>
<li>Server function arguments and return values both need to be serializable with <code>serde</code>. Again, hopefully this makes sense: while function arguments in general don’t need to be serialized, calling a server function from the browser means serializing the arguments and sending them over HTTP.</li>
</ul>
<p>There are a few things to note about the way you define a server function, too.</p>
<ul>
<li>Server functions are created by using the <a href="https://docs.rs/leptos_server/latest/leptos_server/index.html#server"><code>#[server]</code> macro</a> to annotate a top-level function, which can be defined anywhere.</li>
<li>We provide the macro a type name. The type name is used internally as a container to hold, serialize, and deserialize the arguments.</li>
<li>We provide the macro a path. This is a prefix for the path at which we’ll mount a server function handler on our server. (See examples for <a href="https://github.com/leptos-rs/leptos/blob/main/examples/todo_app_sqlite/src/main.rs#L44">Actix</a> and <a href="https://github.com/leptos-rs/leptos/blob/598523cd9d0d775b017cb721e41ebae9349f01e2/examples/todo_app_sqlite_axum/src/main.rs#L51">Axum</a>.)</li>
<li>You’ll need to have <code>serde</code> as a dependency with the <code>derive</code> featured enabled for the macro to work properly. You can easily add it to <code>Cargo.toml</code> with <code>cargo add serde --features=derive</code>.</li>
</ul>
<h2 id="server-function-url-prefixes"><a class="header" href="#server-function-url-prefixes">Server Function URL Prefixes</a></h2>
<p>You can optionally define a specific URL prefix to be used in the definition of the server function.
This is done by providing an optional 2nd argument to the <code>#[server]</code> macro.
By default the URL prefix will be <code>/api</code>, if not specified.
Here are some examples:</p>
<pre><code class="language-rust">#[server(AddTodo)]         // will use the default URL prefix of `/api`
#[server(AddTodo, &quot;/foo&quot;)] // will use the URL prefix of `/foo`</code></pre>
<h2 id="server-function-encodings"><a class="header" href="#server-function-encodings">Server Function Encodings</a></h2>
<p>By default, the server function call is a <code>POST</code> request that serializes the arguments as URL-encoded form data in the body of the request. (This means that server functions can be called from HTML forms, which we’ll see in a future chapter.) But there are a few other methods supported. Optionally, we can provide another argument to the <code>#[server]</code> macro to specify an alternate encoding:</p>
<pre><code class="language-rust">#[server(AddTodo, &quot;/api&quot;, &quot;Url&quot;)]
#[server(AddTodo, &quot;/api&quot;, &quot;GetJson&quot;)]
#[server(AddTodo, &quot;/api&quot;, &quot;Cbor&quot;)]
#[server(AddTodo, &quot;/api&quot;, &quot;GetCbor&quot;)]</code></pre>
<p>The four options use different combinations of HTTP verbs and encoding methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Method</th><th>Request</th><th>Response</th></tr></thead><tbody>
<tr><td><strong>Url</strong> (default)</td><td>POST</td><td>URL encoded</td><td>JSON</td></tr>
<tr><td><strong>GetJson</strong></td><td>GET</td><td>URL encoded</td><td>JSON</td></tr>
<tr><td><strong>Cbor</strong></td><td>POST</td><td>CBOR</td><td>CBOR</td></tr>
<tr><td><strong>GetCbor</strong></td><td>GET</td><td>URL encoded</td><td>CBOR</td></tr>
</tbody></table>
</div>
<p>In other words, you have two choices:</p>
<ul>
<li><code>GET</code> or <code>POST</code>? This has implications for things like browser or CDN caching; while <code>POST</code> requests should not be cached, <code>GET</code> requests can be.</li>
<li>Plain text (arguments sent with URL/form encoding, results sent as JSON) or a binary format (CBOR, encoded as a base64 string)?</li>
</ul>
<p><strong>But remember</strong>: Leptos will handle all the details of this encoding and decoding for you. When you use a server function, it looks just like calling any other asynchronous function!</p>
<blockquote>
<p><strong>Why not <code>PUT</code> or <code>DELETE</code>? Why URL/form encoding, and not JSON?</strong></p>
<p>These are reasonable questions. Much of the web is built on REST API patterns that encourage the use of semantic HTTP methods like <code>DELETE</code> to delete an item from a database, and many devs are accustomed to sending data to APIs in the JSON format.</p>
<p>The reason we use <code>POST</code> or <code>GET</code> with URL-encoded data by default is the <code>&lt;form&gt;</code> support. For better or for worse, HTML forms don’t support <code>PUT</code> or <code>DELETE</code>, and they don’t support sending JSON. This means that if you use anything but a <code>GET</code> or <code>POST</code> request with URL-encoded data, it can only work once WASM has loaded. As we’ll see <a href="server/../progressive_enhancement">in a later chapter</a>, this isn’t always a great idea.</p>
<p>The CBOR encoding is suported for historical reasons; an earlier version of server functions used a URL encoding that didn’t support nested objects like structs or vectors as server function arguments, which CBOR did. But note that the CBOR forms encounter the same issue as <code>PUT</code>, <code>DELETE</code>, or JSON: they do not degrade gracefully if the WASM version of your app is not available.</p>
</blockquote>
<h2 id="server-functions-endpoint-paths"><a class="header" href="#server-functions-endpoint-paths">Server Functions Endpoint Paths</a></h2>
<p>By default, a unique path will be generated. You can optionally define a specific endpoint path to be used in the URL. This is done by providing an optional 4th argument to the <code>#[server]</code> macro. Leptos will generate the complete path by concatenating the URL prefix (2nd argument) and the endpoint path (4th argument).
For example,</p>
<pre><code class="language-rust">#[server(MyServerFnType, &quot;/api&quot;, &quot;Url&quot;, &quot;hello&quot;)]</code></pre>
<p>will generate a server function endpoint at <code>/api/hello</code> that accepts a POST request.</p>
<blockquote>
<p><strong>Can I use the same server function endpoint path with multiple encodings?</strong></p>
<p>No. Different server functions must have unique paths. The <code>#[server]</code> macro automatically generates unique paths, but you need to be careful if you choose to specify the complete path manually, as the server looks up server functions by their path.</p>
</blockquote>
<h2 id="an-important-note-on-security"><a class="header" href="#an-important-note-on-security">An Important Note on Security</a></h2>
<p>Server functions are a cool technology, but it’s very important to remember. <strong>Server functions are not magic; they’re syntax sugar for defining a public API.</strong> The <em>body</em> of a server function is never made public; it’s just part of your server binary. But the server function is a publicly accessible API endpoint, and it’s return value is just a JSON or similar blob. You should <em>never</em> return something sensitive from a server function.</p>
<h2 id="integrating-server-functions-with-leptos"><a class="header" href="#integrating-server-functions-with-leptos">Integrating Server Functions with Leptos</a></h2>
<p>So far, everything I’ve said is actually framework agnostic. (And in fact, the Leptos server function crate has been integrated into Dioxus as well!) Server functions are simply a way of defining a function-like RPC call that leans on Web standards like HTTP requests and URL encoding.</p>
<p>But in a way, they also provide the last missing primitive in our story so far. Because a server function is just a plain Rust async function, it integrates perfectly with the async Leptos primitives we discussed <a href="https://leptos-rs.github.io/leptos/async/index.html">earlier</a>. So you can easily integrate your server functions with the rest of your applications:</p>
<ul>
<li>Create <strong>resources</strong> that call the server function to load data from the server</li>
<li>Read these resources under <code>&lt;Suspense/&gt;</code> or <code>&lt;Transition/&gt;</code> to enable streaming SSR and fallback states while data loads.</li>
<li>Create <strong>actions</strong> that call the server function to mutate data on the server</li>
</ul>
<p>The final section of this book will make this a little more concrete by introducing patterns that use progressively-enhanced HTML forms to run these server actions.</p>
<p>But in the next few chapters, we’ll actually take a look at some of the details of what you might want to do with your server functions, including the best ways to integrate with the powerful extractors provided by the Actix and Axum server frameworks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extractors"><a class="header" href="#extractors">Extractors</a></h1>
<p>The server functions we looked at in the last chapter showed how to run code on the server, and integrate it with the user interface you’re rendering in the browser. But they didn’t show you much about how to actually use your server to its full potential.</p>
<h2 id="server-frameworks"><a class="header" href="#server-frameworks">Server Frameworks</a></h2>
<p>We call Leptos a “full-stack” framework, but “full-stack” is always a misnomer (after all, it never means everything from the browser to your power company.) For us, “full stack” means that your Leptos app can run in the browser, and can run on the server, and can integrate the two, drawing together the unique features available in each; as we’ve seen in the book so far, a button click on the browser can drive a database read on the server, both written in the same Rust module. But Leptos itself doesn’t provide the server (or the database, or the operating system, or the firmware, or the electrical cables...)</p>
<p>Instead, Leptos provides integrations for the two most popular Rust web server frameworks, Actix Web (<a href="https://docs.rs/leptos_actix/latest/leptos_actix/"><code>leptos_actix</code></a>) and Axum (<a href="https://docs.rs/leptos_axum/latest/leptos_axum/"><code>leptos_axum</code></a>). We’ve built integrations with each server’s router so that you can simply plug your Leptos app into an existing server with <code>.leptos_routes()</code>, and easily handle server function calls.</p>
<blockquote>
<p>If you haven’t seen our <a href="https://github.com/leptos-rs/start">Actix</a> and <a href="https://github.com/leptos-rs/start-axum">Axum</a> templates, now’s a good time to check them out.</p>
</blockquote>
<h2 id="using-extractors"><a class="header" href="#using-extractors">Using Extractors</a></h2>
<p>Both Actix and Axum handlers are built on the same powerful idea of <strong>extractors</strong>. Extractors “extract” typed data from an HTTP request, allowing you to access server-specific data easily.</p>
<p>Leptos provides <code>extract</code> helper functions to let you use these extractors directly in your server functions, with a convenient syntax very similar to handlers for each framework.</p>
<h3 id="actix-extractors"><a class="header" href="#actix-extractors">Actix Extractors</a></h3>
<p>The <a href="https://docs.rs/leptos_actix/latest/leptos_actix/fn.extract.html"><code>extract</code> function in <code>leptos_actix</code></a> takes a handler function as its argument. The handler follows similar rules to an Actix handler: it is an async function that receives arguments that will be extracted from the request and returns some value. The handler function receives that extracted data as its arguments, and can do further <code>async</code> work on them inside the body of the <code>async move</code> block. It returns whatever value you return back out into the server function.</p>
<pre><code class="language-rust">
#[server(ActixExtract, &quot;/api&quot;)]
pub async fn actix_extract() -&gt; Result&lt;String, ServerFnError&gt; {
	use leptos_actix::extract;
    use actix_web::dev::ConnectionInfo;
    use actix_web::web::{Data, Query};

    extract(
        |search: Query&lt;Search&gt;, connection: ConnectionInfo| async move {
            format!(
                &quot;search = {}\nconnection = {:?}&quot;,
                search.q,
                connection
            )
        },
    )
    .await
}</code></pre>
<h2 id="axum-extractors"><a class="header" href="#axum-extractors">Axum Extractors</a></h2>
<p>The syntax for the <a href="https://docs.rs/leptos_axum/latest/leptos_axum/fn.extract.html"><code>leptos_axum::extract</code></a> function is very similar. (<strong>Note</strong>: This is available on the git main branch, but has not been released as of writing.) Note that Axum extractors return a <code>Result</code>, so you’ll need to add something to handle the error case.</p>
<pre><code class="language-rust">#[server(AxumExtract, &quot;/api&quot;)]
pub async fn axum_extract() -&gt; Result&lt;String, ServerFnError&gt; {
    use axum::{extract::Query, http::Method};
    use leptos_axum::extract;

    extract(|method: Method, res: Query&lt;MyQuery&gt;| async move {
            format!(&quot;{method:?} and {}&quot;, res.q)
        },
    )
    .await
    .map_err(|e| ServerFnError::ServerError(&quot;Could not extract method and query...&quot;.to_string()))
}</code></pre>
<p>These are relatively simple examples accessing basic data from the server. But you can use extractors to access things like headers, cookies, database connection pools, and more, using the exact same <code>extract()</code> pattern.</p>
<p>The Axum <code>extract</code> function only supports extractors for which the state is <code>()</code>. If you need an extractor that uses <code>State</code>, you should use <a href="https://docs.rs/leptos_axum/latest/leptos_axum/fn.extract_with_state.html"><code>extract_with_state</code></a>. This requires you to provide the state. You can do this by extending the existing <code>LeptosOptions</code> state using the Axum <code>FromRef</code> pattern, which providing the state as context during render and server functions with custom handlers.</p>
<pre><code class="language-rust">use axum::extract::FromRef;

/// Derive FromRef to allow multiple items in state, using Axum’s
/// SubStates pattern.
#[derive(FromRef, Debug, Clone)]
pub struct AppState{
    pub leptos_options: LeptosOptions,
    pub pool: SqlitePool
}</code></pre>
<p><a href="https://github.com/leptos-rs/leptos/blob/19ea6fae6aec2a493d79cc86612622d219e6eebb/examples/session_auth_axum/src/main.rs#L24-L44">Click here for an example of providing context in custom handlers</a>.</p>
<h2 id="a-note-about-data-loading-patterns"><a class="header" href="#a-note-about-data-loading-patterns">A Note about Data-Loading Patterns</a></h2>
<p>Because Actix and (especially) Axum are built on the idea of a single round-trip HTTP request and response, you typically run extractors near the “top” of your application (i.e., before you start rendering) and use the extracted data to determine how that should be rendered. Before you render a <code>&lt;button&gt;</code>, you load all the data your app could need. And any given route handler needs to know all the data that will need to be extracted by that route.</p>
<p>But Leptos integrates both the client and the server, and it’s important to be able to refresh small pieces of your UI with new data from the server without forcing a full reload of all the data. So Leptos likes to push data loading “down” in your application, as far towards the leaves of your user interface as possible. When you click a <code>&lt;button&gt;</code>, it can refresh just the data it needs. This is exactly what server functions are for: they give you granular access to data to be loaded and reloaded.</p>
<p>The <code>extract()</code> functions let you combine both models by using extractors in your server functions. You get access to the full power of route extractors, while decentralizing knowledge of what needs to be extracted down to your individual components. This makes it easier to refactor and reorganize routes: you don’t need to specify all the data a route needs up front.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="responses-and-redirects"><a class="header" href="#responses-and-redirects">Responses and Redirects</a></h1>
<p>Extractors provide an easy way to access request data inside server functions. Leptos also provides a way to modify the HTTP response, using the <code>ResponseOptions</code> type (see docs for <a href="https://docs.rs/leptos_actix/latest/leptos_actix/struct.ResponseOptions.html">Actix</a> or <a href="https://docs.rs/leptos_axum/latest/leptos_axum/struct.ResponseOptions.html">Axum</a>) types and the <code>redirect</code> helper function (see docs for <a href="https://docs.rs/leptos_actix/latest/leptos_actix/fn.redirect.html">Actix</a> or <a href="https://docs.rs/leptos_axum/latest/leptos_axum/fn.redirect.html">Axum</a>).</p>
<h2 id="responseoptions"><a class="header" href="#responseoptions"><code>ResponseOptions</code></a></h2>
<p><code>ResponseOptions</code> is provided via context during the initial server rendering response and during any subsequent server function call. It allows you to easily set the status code for the HTTP response, or to add headers to the HTTP response, e.g., to set cookies.</p>
<pre><code class="language-rust">#[server(TeaAndCookies)]
pub async fn tea_and_cookies() -&gt; Result&lt;(), ServerFnError&gt; {
	use actix_web::{cookie::Cookie, http::header, http::header::HeaderValue};
	use leptos_actix::ResponseOptions;

	// pull ResponseOptions from context
	let response = expect_context::&lt;ResponseOptions&gt;();

	// set the HTTP status code
	response.set_status(StatusCode::IM_A_TEAPOT);

	// set a cookie in the HTTP response
	let mut cookie = Cookie::build(&quot;biscuits&quot;, &quot;yes&quot;).finish();
	if let Ok(cookie) = HeaderValue::from_str(&amp;cookie.to_string()) {
		response.insert_header(header::SET_COOKIE, cookie);
	}
}</code></pre>
<h2 id="redirect"><a class="header" href="#redirect"><code>redirect</code></a></h2>
<p>One common modification to an HTTP response is to redirect to another page. The Actix and Axum integrations provide a <code>redirect</code> function to make this easy to do. <code>redirect</code> simply sets an HTTP status code of <code>302 Found</code> and sets the <code>Location</code> header.</p>
<p>Here’s a simplified example from our <a href="https://github.com/leptos-rs/leptos/blob/a5f73b441c079f9138102b3a7d8d4828f045448c/examples/session_auth_axum/src/auth.rs#L154-L181"><code>session_auth_axum</code> example</a>.</p>
<pre><code class="language-rust">#[server(Login, &quot;/api&quot;)]
pub async fn login(
    username: String,
    password: String,
    remember: Option&lt;String&gt;,
) -&gt; Result&lt;(), ServerFnError&gt; {
	// pull the DB pool and auth provider from context
    let pool = pool()?;
    let auth = auth()?;

	// check whether the user exists
    let user: User = User::get_from_username(username, &amp;pool)
        .await
        .ok_or_else(|| {
            ServerFnError::ServerError(&quot;User does not exist.&quot;.into())
        })?;

	// check whether the user has provided the correct password
    match verify(password, &amp;user.password)? {
		// if the password is correct...
        true =&gt; {
			// log the user in
            auth.login_user(user.id);
            auth.remember_user(remember.is_some());

			// and redirect to the home page
            leptos_axum::redirect(&quot;/&quot;);
            Ok(())
        }
		// if not, return an error
        false =&gt; Err(ServerFnError::ServerError(
            &quot;Password does not match.&quot;.to_string(),
        )),
    }
}</code></pre>
<p>This server function can then be used from your application. This <code>redirect</code> works well with the progressively-enhanced <code>&lt;ActionForm/&gt;</code> component: without JS/WASM, the server response will redirect because of the status code and header. With JS/WASM, the <code>&lt;ActionForm/&gt;</code> will detect the redirect in the server function response, and use client-side navigation to redirect to the new page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progressive-enhancement-and-graceful-degradation"><a class="header" href="#progressive-enhancement-and-graceful-degradation">Progressive Enhancement (and Graceful Degradation)</a></h1>
<p>I’ve been driving around Boston for about fifteen years. If you don’t know Boston, let me tell you: Massachusetts has some of the most aggressive drivers(and pedestrians!) in the world. I’ve learned to practice what’s sometimes called “defensive driving”: assuming that someone’s about to swerve in front of you at an intersection when you have the right of way, preparing for a pedestrian to cross into the street at any moment, and driving accordingly.</p>
<p>“Progressive enhancement” is the “defensive driving” of web design. Or really, that’s “graceful degradation,” although they’re two sides of the same coin, or the same process, from two different directions.</p>
<p><strong>Progressive enhancement</strong>, in this context, means beginning with a simple HTML site or application that works for any user who arrives at your page, and gradually enhancing it with layers of additional features: CSS for styling, JavaScript for interactivity, WebAssembly for Rust-powered interactivity; using particular Web APIs for a richer experience if they’re available and as needed.</p>
<p><strong>Graceful degradation</strong> means handling failure gracefully when parts of that stack of enhancement <em>aren’t</em> available. Here are some sources of failure your users might encounter in your app:</p>
<ul>
<li>Their browser doesn’t support WebAssembly because it needs to be updated.</li>
<li>Their browser can’t support WebAssembly because browser updates are limited to newer OS versions, which can’t be installed on the device. (Looking at you, Apple.)</li>
<li>They have WASM turned off for security or privacy reasons.</li>
<li>They have JavaScript turned off for security or privacy reasons.</li>
<li>JavaScript isn’t supported on their device (for example, some accessibility devices only support HTML browsing)</li>
<li>The JavaScript (or WASM) never arrived at their device because they walked outside and lost WiFi.</li>
<li>They stepped onto a subway car after loading the initial page and subsequent navigations can’t load data.</li>
<li>... and so on.</li>
</ul>
<p>How much of your app still works if one of these holds true? Two of them? Three? </p>
<p>If the answer is something like “95%... okay, then 90%... okay, then 75%,” that’s graceful degradation. If the answer is “my app shows a blank screen unless everything works correctly,” that’s... rapid unscheduled disassembly.</p>
<p><strong>Graceful degradation is especially important for WASM apps,</strong> because WASM is the newest and least-likely-to-be-supported of the four languages that run in the browser (HTML, CSS, JS, WASM).</p>
<p>Luckily, we’ve got some tools to help.</p>
<h2 id="defensive-design"><a class="header" href="#defensive-design">Defensive Design</a></h2>
<p>There are a few practices that can help your apps degrade more gracefully:</p>
<ol>
<li><strong>Server-side rendering.</strong> Without SSR, your app simply doesn’t work without both JS and WASM loading. In some cases this may be appropriate (think internal apps gated behind a login) but in others it’s simply broken.</li>
<li><strong>Native HTML elements.</strong> Use HTML elements that do the things that you want, without additional code: <code>&lt;a&gt;</code> for navigation (including to hashes within the page), <code>&lt;details&gt;</code> for an accordion, <code>&lt;form&gt;</code> to persist information in the URL, etc.</li>
<li><strong>URL-driven state.</strong> The more of your global state is stored in the URL (as a route param or part of the query string), the more of the page can be generated during server rendering and updated by an <code>&lt;a&gt;</code> or a <code>&lt;form&gt;</code>, which means that not only navigations but state changes can work without JS/WASM.</li>
<li><strong><a href="https://docs.rs/leptos_router/latest/leptos_router/enum.SsrMode.html"><code>SsrMode::PartiallyBlocked</code> or <code>SsrMode::InOrder</code></a>.</strong> Out-of-order streaming requires a small amount of inline JS, but can fail if 1) the connection is broken halfway through the response or 2) the client’s device doesn’t support JS. Async streaming will give a complete HTML page, but only after all resources load. In-order streaming begins showing pieces of the page sooner, in top-down order. “Partially-blocked” SSR builds on out-of-order streaming by replacing <code>&lt;Suspense/&gt;</code> fragments that read from blocking resources on the server. This adds marginally to the initial response time (because of the <code>O(n)</code> string replacement work), in exchange for a more complete initial HTML response. This can be a good choice for situations in which there’s a clear distinction between “more important” and “less important” content, e.g., blog post vs. comments, or product info vs. reviews. If you choose to block on all the content, you’ve essentially recreated async rendering.</li>
<li><strong>Leaning on <code>&lt;form&gt;</code>s.</strong> There’s been a bit of a <code>&lt;form&gt;</code> renaissance recently, and it’s no surprise. The ability of a <code>&lt;form&gt;</code> to manage complicated <code>POST</code> or <code>GET</code> requests in an easily-enhanced way makes it a powerful tool for graceful degradation. The example in <a href="progressive_enhancement/../router/20_form.html">the <code>&lt;Form/&gt;</code> chapter</a>, for example, would work fine with no JS/WASM: because it uses a <code>&lt;form method=&quot;GET&quot;&gt;</code> to persist state in the URL, it works with pure HTML by making normal HTTP requests and then progressively enhances to use client-side navigations instead.</li>
</ol>
<p>There’s one final feature of the framework that we haven’t seen yet, and which builds on this characteristic of forms to build powerful applications: the <code>&lt;ActionForm/&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actionform"><a class="header" href="#actionform"><code>&lt;ActionForm/&gt;</code></a></h1>
<p><a href="https://docs.rs/leptos_router/latest/leptos_router/fn.ActionForm.html"><code>&lt;ActionForm/&gt;</code></a> is a specialized <code>&lt;Form/&gt;</code> that takes a server action, and automatically dispatches it on form submission. This allows you to call a server function directly from a <code>&lt;form&gt;</code>, even without JS/WASM.</p>
<p>The process is simple:</p>
<ol>
<li>Define a server function using the <a href="https://docs.rs/leptos/latest/leptos/attr.server.html"><code>#[server]</code> macro</a> (see <a href="progressive_enhancement/../server/25_server_functions.html">Server Functions</a>.)</li>
<li>Create an action using <a href="https://docs.rs/leptos/latest/leptos/fn.create_server_action.html"><code>create_server_action</code></a>, specifying the type of the server function you’ve defined.</li>
<li>Create an <code>&lt;ActionForm/&gt;</code>, providing the server action in the <code>action</code> prop.</li>
<li>Pass the named arguments to the server function as form fields with the same names.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> <code>&lt;ActionForm/&gt;</code> only works with the default URL-encoded <code>POST</code> encoding for server functions, to ensure graceful degradation/correct behavior as an HTML form.</p>
</blockquote>
<pre><code class="language-rust">#[server(AddTodo, &quot;/api&quot;)]
pub async fn add_todo(title: String) -&gt; Result&lt;(), ServerFnError&gt; {
    todo!()
}

#[component]
fn AddTodo() -&gt; impl IntoView {
	let add_todo = create_server_action::&lt;AddTodo&gt;();
	// holds the latest *returned* value from the server
	let value = add_todo.value();
	// check if the server has returned an error
	let has_error = move || value.with(|val| matches!(val, Some(Err(_))));

	view! {
		&lt;ActionForm action=add_todo&gt;
			&lt;label&gt;
				&quot;Add a Todo&quot;
				// `title` matches the `title` argument to `add_todo`
				&lt;input type=&quot;text&quot; name=&quot;title&quot;/&gt;
			&lt;/label&gt;
			&lt;input type=&quot;submit&quot; value=&quot;Add&quot;/&gt;
		&lt;/ActionForm&gt;
	}
}</code></pre>
<p>It’s really that easy. With JS/WASM, your form will submit without a page reload, storing its most recent submission in the <code>.input()</code> signal of the action, its pending status in <code>.pending()</code>, and so on. (See the <a href="https://docs.rs/leptos/latest/leptos/struct.Action.html"><code>Action</code></a> docs for a refresher, if you need.) Without JS/WASM, your form will submit with a page reload. If you call a <code>redirect</code> function (from <code>leptos_axum</code> or <code>leptos_actix</code>) it will redirect to the correct page. By default, it will redirect back to the page you’re currently on. The power of HTML, HTTP, and isomorphic rendering mean that your <code>&lt;ActionForm/&gt;</code> simply works, even with no JS/WASM.</p>
<h2 id="client-side-validation"><a class="header" href="#client-side-validation">Client-Side Validation</a></h2>
<p>Because the <code>&lt;ActionForm/&gt;</code> is just a <code>&lt;form&gt;</code>, it fires a <code>submit</code> event. You can use either HTML validation, or your own client-side validation logic in an <code>on:submit</code>. Just call <code>ev.prevent_default()</code> to prevent submission.</p>
<p>The <a href="https://docs.rs/leptos_router/latest/leptos_router/trait.FromFormData.html"><code>FromFormData</code></a> trait can be helpful here, for attempting to parse your server function’s data type from the submitted form.</p>
<pre><code class="language-rust">let on_submit = move |ev| {
	let data = AddTodo::from_event(&amp;ev);
	// silly example of validation: if the todo is &quot;nope!&quot;, nope it
	if data.is_err() || data.unwrap().title == &quot;nope!&quot; {
		// ev.prevent_default() will prevent form submission
		ev.prevent_default();
	}
}</code></pre>
<h2 id="complex-inputs"><a class="header" href="#complex-inputs">Complex Inputs</a></h2>
<p>Server function arguments that are structs with nested serializable fields should make use of indexing notation of <code>serde_qs</code>.</p>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
struct HeftyData {
    first_name: String,
    last_name: String,
}

#[component]
fn ComplexInput() -&gt; impl IntoView {
    let submit = Action::&lt;VeryImportantFn, _&gt;::server();

    view! {
      &lt;ActionForm action=submit&gt;
        &lt;input type=&quot;text&quot; name=&quot;hefty_arg[first_name]&quot; value=&quot;leptos&quot;/&gt;
        &lt;input
          type=&quot;text&quot;
          name=&quot;hefty_arg[last_name]&quot;
          value=&quot;closures-everywhere&quot;
        /&gt;
        &lt;input type=&quot;submit&quot;/&gt;
      &lt;/ActionForm&gt;
    }
}

#[server]
async fn very_important_fn(
    hefty_arg: HeftyData,
) -&gt; Result&lt;(), ServerFnError&gt; {
    assert_eq!(hefty_arg.first_name.as_str(), &quot;leptos&quot;);
    assert_eq!(hefty_arg.last_name.as_str(), &quot;closures-everywhere&quot;);
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>There are as many ways to deploy a web application as there are developers, let alone applications. But there are a couple useful tips to keep in mind when deploying an app.</p>
<h2 id="general-advice"><a class="header" href="#general-advice">General Advice</a></h2>
<ol>
<li>Remember: Always deploy Rust apps built in <code>--release</code> mode, not debug mode. This has a huge effect on both performance and binary size.</li>
<li>Test locally in release mode as well. The framework applies certain optimizations in release mode that it does not apply in debug mode, so it’s possible for bugs to surface at this point. (If your app behaves differently or you do encounter a bug, it’s likely a framework-level bug and you should open a GitHub issue with a reproduction.)</li>
<li>See the chapter on &quot;Optimizing WASM Binary Size&quot; for additional tips and tricks to further improve the time-to-interactive metric for your WASM app on first load.</li>
</ol>
<blockquote>
<p>We asked users to submit their deployment setups to help with this chapter. I’ll quote from them below, but you can read the full thread <a href="https://github.com/leptos-rs/leptos/issues/1152">here</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-a-client-side-rendered-app"><a class="header" href="#deploying-a-client-side-rendered-app">Deploying a Client-Side-Rendered App</a></h1>
<p>If you’ve been building an app that only uses client-side rendering, working with Trunk as a dev server and build tool, the process is quite easy.</p>
<pre><code class="language-bash">trunk build --release
</code></pre>
<p><code>trunk build</code> will create a number of build artifacts in a <code>dist/</code> directory. Publishing <code>dist</code> somewhere online should be all you need to deploy your app. This should work very similarly to deploying any JavaScript application.</p>
<p>We've created several example repositories which show how to set up and deploy a Leptos CSR app to various hosting services.</p>
<p><em>Note: Leptos does not endorse the use of any particular hosting service - feel free to use any service that supports static site deploys.</em></p>
<p>Examples:</p>
<ul>
<li><a href="deployment/csr.html#github-pages">Github Pages</a></li>
<li><a href="deployment/csr.html#vercel">Vercel</a></li>
<li><a href="deployment/csr.html#spin---serverless-webassembly">Spin (serverless WebAssembly)</a></li>
</ul>
<h2 id="github-pages"><a class="header" href="#github-pages">Github Pages</a></h2>
<p>Deploying a Leptos CSR app to Github pages is a simple affair. First, go to your Github repo's settings and click on &quot;Pages&quot; in the left side menu. In the &quot;Build and deployment&quot; section of the page, change the &quot;source&quot; to &quot;Github Actions&quot;. Then copy the following into a file such as <code>.github/workflows/gh-pages-deploy.yml</code></p>
<details id="admonition-example" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/csr.html#admonition-example"></a></p>
</summary>
<div>
<pre><code>name: Release to Github Pages

on:
push:
	branches: [main]
workflow_dispatch:

permissions:
contents: write # for committing to gh-pages branch.
pages: write
id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
group: &quot;pages&quot;
cancel-in-progress: false

jobs:
Github-Pages-Release:

	timeout-minutes: 10

	environment:
	name: github-pages
	url: ${{ steps.deployment.outputs.page_url }}

	runs-on: ubuntu-latest

	steps:
	- uses: actions/checkout@v4 # repo checkout

	# Install Rust Nightly Toolchain, with Clippy &amp; Rustfmt
	- name: Install nightly Rust
		uses: dtolnay/rust-toolchain@nightly
		with:
		components: clippy, rustfmt

	- name: Add WASM target
		run: rustup target add wasm32-unknown-unknown

	- name: lint
		run: cargo clippy &amp; cargo fmt


	# If using tailwind...
	# - name: Download and install tailwindcss binary
	#   run: npm install -D tailwindcss &amp;&amp; npx tailwindcss -i &lt;INPUT/PATH.css&gt; -o &lt;OUTPUT/PATH.css&gt;  # run tailwind


	- name: Download and install Trunk binary
		run: wget -qO- https://github.com/trunk-rs/trunk/releases/download/v0.18.2/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-

	- name: Build with Trunk
		# &quot;${GITHUB_REPOSITORY#*/}&quot; evaluates into the name of the repository
		# using --public-url something will allow trunk to modify all the href paths like from favicon.ico to repo_name/favicon.ico .
		# this is necessary for github pages where the site is deployed to username.github.io/repo_name and all files must be requested
		# relatively as favicon.ico. if we skip public-url option, the href paths will instead request username.github.io/favicon.ico which
		# will obviously return error 404 not found.
		run: ./trunk build --release --public-url &quot;${GITHUB_REPOSITORY#*/}&quot;


	# Deploy to gh-pages branch
	# - name: Deploy 🚀
	#   uses: JamesIves/github-pages-deploy-action@v4
	#   with:
	#     folder: dist


	# Deploy with Github Static Pages

	- name: Setup Pages
		uses: actions/configure-pages@v4
		with:
		enablement: true
		# token:

	- name: Upload artifact
		uses: actions/upload-pages-artifact@v2
		with:
		# Upload dist dir
		path: './dist'

	- name: Deploy to GitHub Pages 🚀
		id: deployment
		uses: actions/deploy-pages@v3
</code></pre>
</div>
</details>
<p>For more on deploying to Github Pages <a href="https://github.com/diversable/deploy_leptos_csr_to_gh_pages">see the example repo here</a></p>
<h2 id="vercel"><a class="header" href="#vercel">Vercel</a></h2>
<h3 id="step-1-set-up-vercel"><a class="header" href="#step-1-set-up-vercel">Step 1: Set Up Vercel</a></h3>
<p>In the Vercel Web UI...</p>
<ol>
<li>Create a new project</li>
<li>Ensure
<ul>
<li>The &quot;Build Command&quot; is left empty with Override on</li>
<li>The &quot;Output Directory&quot; is changed to dist (which is the default output directory for Trunk builds) and the Override is on</li>
</ul>
</li>
</ol>
<img src="deployment/./image.png" />
<h3 id="step-2-add-vercel-credentials-for-github-actions"><a class="header" href="#step-2-add-vercel-credentials-for-github-actions">Step 2: Add Vercel Credentials for GitHub Actions</a></h3>
<p>Note: Both the preview and deploy actions will need your Vercel credentials setup in GitHub secrets</p>
<ol>
<li>
<p>Retrieve your <a href="https://vercel.com/guides/how-do-i-use-a-vercel-api-access-token">Vercel Access Token</a> by going to &quot;Account Settings&quot; &gt; &quot;Tokens&quot; and creating a new token - save the token to use in sub-step 5, below.</p>
</li>
<li>
<p>Install the <a href="https://vercel.com/cli">Vercel CLI</a> using the <code>npm i -g vercel</code> command, then run <code>vercel login</code> to login to your acccount.</p>
</li>
<li>
<p>Inside your folder, run <code>vercel link</code> to create a new Vercel project; in the CLI, you will be asked to 'Link to an existing project?' - answer yes, then enter the name you created in step 1. A new <code>.vercel</code> folder will be created for you.</p>
</li>
<li>
<p>Inside the generated <code>.vercel</code> folder, open the the <code>project.json</code> file and save the &quot;projectId&quot; and &quot;orgId&quot; for the next step.</p>
</li>
<li>
<p>Inside GitHub, go the repo's &quot;Settings&quot; &gt; &quot;Secrets and Variables&quot; &gt; &quot;Actions&quot; and add the following as <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">Repository secrets</a>:</p>
<ul>
<li>save your Vercel Access Token (from sub-step 1) as the <code>VERCEL_TOKEN</code> secret</li>
<li>from the <code>.vercel/project.json</code> add &quot;projectID&quot; as <code>VERCEL_PROJECT_ID</code></li>
<li>from the <code>.vercel/project.json</code> add &quot;orgId&quot; as <code>VERCEL_ORG_ID</code></li>
</ul>
</li>
</ol>
<p><i>For full instructions see <a href="https://vercel.com/guides/how-can-i-use-github-actions-with-vercel">&quot;How can I use Github Actions with Vercel&quot;</a></i></p>
<h3 id="step-3-add-github-action-scripts"><a class="header" href="#step-3-add-github-action-scripts">Step 3: Add Github Action Scripts</a></h3>
<p>Finally, you're ready to simply copy and paste the two files - one for deployment, one for PR previews - from below or from <a href="https://github.com/diversable/vercel-leptos-CSR-deployment/tree/main/.github/workflows">the example repo's <code>.github/workflows/</code> folder</a> into your own github workflows folder - then, on your next commit or PR deploys will occur automatically.</p>
<p><i>Production deployment script: <code>vercel_deploy.yml</code></i></p>
<details id="admonition-example-1" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/csr.html#admonition-example-1"></a></p>
</summary>
<div>
<pre><code>name: Release to Vercel

on:
push:
	branches:
	- main
env:
CARGO_TERM_COLOR: always
VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
Vercel-Production-Deployment:
	runs-on: ubuntu-latest
	environment: production
	steps:
	- name: git-checkout
		uses: actions/checkout@v3

	- uses: dtolnay/rust-toolchain@nightly
		with:
		components: clippy, rustfmt
	- uses: Swatinem/rust-cache@v2
	- name: Setup Rust
		run: |
		rustup target add wasm32-unknown-unknown
		cargo clippy
		cargo fmt --check

	- name: Download and install Trunk binary
		run: wget -qO- https://github.com/trunk-rs/trunk/releases/download/v0.18.2/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-


	- name: Build with Trunk
		run: ./trunk build --release

	- name: Install Vercel CLI
		run: npm install --global vercel@latest

	- name: Pull Vercel Environment Information
		run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

	- name: Deploy to Vercel &amp; Display URL
		id: deployment
		working-directory: ./dist
		run: |
		vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} &gt;&gt; $GITHUB_STEP_SUMMARY
		echo $GITHUB_STEP_SUMMARY
</code></pre>
</div>
</details>
<p><i>Preview deployments script: <code>vercel_preview.yml</code></i></p>
<details id="admonition-example-2" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/csr.html#admonition-example-2"></a></p>
</summary>
<div>
<pre><code># For more info re: vercel action see:
# https://github.com/amondnet/vercel-action

name: Leptos CSR Vercel Preview

on:
pull_request:
	branches: [ &quot;main&quot; ]

workflow_dispatch:

env:
CARGO_TERM_COLOR: always
VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
fmt:
	name: Rustfmt
	runs-on: ubuntu-latest
	steps:
	- uses: actions/checkout@v4
	- uses: dtolnay/rust-toolchain@nightly
		with:
		components: rustfmt
	- name: Enforce formatting
		run: cargo fmt --check

clippy:
	name: Clippy
	runs-on: ubuntu-latest
	steps:
	- uses: actions/checkout@v4
	- uses: dtolnay/rust-toolchain@nightly
		with:
		components: clippy
	- uses: Swatinem/rust-cache@v2
	- name: Linting
		run: cargo clippy -- -D warnings

test:
	name: Test
	runs-on: ubuntu-latest
	needs: [fmt, clippy]
	steps:
	- uses: actions/checkout@v4
	- uses: dtolnay/rust-toolchain@nightly
	- uses: Swatinem/rust-cache@v2
	- name: Run tests
		run: cargo test

build-and-preview-deploy:
	runs-on: ubuntu-latest
	name: Build and Preview

	needs: [test, clippy, fmt]

	permissions:
	pull-requests: write

	environment:
	name: preview
	url: ${{ steps.preview.outputs.preview-url }}

	steps:
	- name: git-checkout
		uses: actions/checkout@v4

	- uses: dtolnay/rust-toolchain@nightly
	- uses: Swatinem/rust-cache@v2
	- name: Build
		run: rustup target add wasm32-unknown-unknown

	- name: Download and install Trunk binary
		run: wget -qO- https://github.com/trunk-rs/trunk/releases/download/v0.18.2/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-


	- name: Build with Trunk
		run: ./trunk build --release

	- name: Preview Deploy
		id: preview
		uses: amondnet/vercel-action@v25.1.1
		with:
		vercel-token: ${{ secrets.VERCEL_TOKEN }}
		github-token: ${{ secrets.GITHUB_TOKEN }}
		vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
		vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
		github-comment: true
		working-directory: ./dist

	- name: Display Deployed URL
		run: |
		echo &quot;Deployed app URL: ${{ steps.preview.outputs.preview-url }}&quot; &gt;&gt; $GITHUB_STEP_SUMMARY
</code></pre>
</div>
</details>
<p>See <a href="https://github.com/diversable/vercel-leptos-CSR-deployment">the example repo here</a> for more.</p>
<h2 id="spin---serverless-webassembly"><a class="header" href="#spin---serverless-webassembly">Spin - Serverless WebAssembly</a></h2>
<p>Another option is using a serverless platform such as Spin. Although <a href="https://github.com/fermyon/spin">Spin</a> is open source and you can run it on your own infrastructure (eg. inside Kubernetes), the easiest way to get started with Spin in production is to use the Fermyon Cloud.</p>
<p>Start by installing the <a href="https://developer.fermyon.com/spin/v2/install">Spin CLI using the instructions, here</a>, and creating a Github repo for your Leptos CSR project, if you haven't done so already.</p>
<ol>
<li>
<p>Open &quot;Fermyon Cloud&quot; &gt; &quot;User Settings&quot;. If you’re not logged in, choose the Login With GitHub button.</p>
</li>
<li>
<p>In the “Personal Access Tokens”, choose “Add a Token”. Enter the name “gh_actions” and click “Create Token”.</p>
</li>
<li>
<p>Fermyon Cloud displays the token; click the copy button to copy it to your clipboard.</p>
</li>
<li>
<p>Go into your Github repo and open &quot;Settings&quot; &gt; &quot;Secrets and Variables&quot; &gt; &quot;Actions&quot; and add the Fermyon cloud token to &quot;Repository secrets&quot; using the variable name &quot;FERMYON_CLOUD_TOKEN&quot;</p>
</li>
<li>
<p>Copy and paste the following Github Actions scripts (below) into your <code>.github/workflows/&lt;SCRIPT_NAME&gt;.yml</code> files</p>
</li>
<li>
<p>With the 'preview' and 'deploy' scripts active, Github Actions will now generate previews on pull requests &amp; deploy automatically on updates to your 'main' branch.</p>
</li>
</ol>
<p><i>Production deployment script: <code>spin_deploy.yml</code></i></p>
<details id="admonition-example-3" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/csr.html#admonition-example-3"></a></p>
</summary>
<div>
<pre><code># For setup instructions needed for Fermyon Cloud, see:
# https://developer.fermyon.com/cloud/github-actions

# For reference, see:
# https://developer.fermyon.com/cloud/changelog/gh-actions-spin-deploy

# For the Fermyon gh actions themselves, see:
# https://github.com/fermyon/actions

name: Release to Spin Cloud

on:
push:
	branches: [main]
workflow_dispatch:

permissions:
contents: read
id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
group: &quot;spin&quot;
cancel-in-progress: false

jobs:
Spin-Release:

	timeout-minutes: 10

	environment:
	name: production
	url: ${{ steps.deployment.outputs.app-url }}

	runs-on: ubuntu-latest

	steps:
	- uses: actions/checkout@v4 # repo checkout

	# Install Rust Nightly Toolchain, with Clippy &amp; Rustfmt
	- name: Install nightly Rust
		uses: dtolnay/rust-toolchain@nightly
		with:
		components: clippy, rustfmt

	- name: Add WASM &amp; WASI targets
		run: rustup target add wasm32-unknown-unknown &amp;&amp; rustup target add wasm32-wasi

	- name: lint
		run: cargo clippy &amp; cargo fmt


	# If using tailwind...
	# - name: Download and install tailwindcss binary
	#   run: npm install -D tailwindcss &amp;&amp; npx tailwindcss -i &lt;INPUT/PATH.css&gt; -o &lt;OUTPUT/PATH.css&gt;  # run tailwind


	- name: Download and install Trunk binary
		run: wget -qO- https://github.com/trunk-rs/trunk/releases/download/v0.18.2/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-


	- name: Build with Trunk
		run: ./trunk build --release


	# Install Spin CLI &amp; Deploy

	- name: Setup Spin
		uses: fermyon/actions/spin/setup@v1
		# with:
		# plugins:


	- name: Build and deploy
		id: deployment
		uses: fermyon/actions/spin/deploy@v1
		with:
		fermyon_token: ${{ secrets.FERMYON_CLOUD_TOKEN }}
		# key_values: |-
			# abc=xyz
			# foo=bar
		# variables: |-
			# password=${{ secrets.SECURE_PASSWORD }}
			# apikey=${{ secrets.API_KEY }}

	# Create an explicit message to display the URL of the deployed app, as well as in the job graph
	- name: Deployed URL
		run: |
		echo &quot;Deployed app URL: ${{ steps.deployment.outputs.app-url }}&quot; &gt;&gt; $GITHUB_STEP_SUMMARY
</code></pre>
</div>
</details>
<p><i>Preview deployment script: <code>spin_preview.yml</code></i></p>
<details id="admonition-example-4" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/csr.html#admonition-example-4"></a></p>
</summary>
<div>
<pre><code># For setup instructions needed for Fermyon Cloud, see:
# https://developer.fermyon.com/cloud/github-actions


# For the Fermyon gh actions themselves, see:
# https://github.com/fermyon/actions

# Specifically:
# https://github.com/fermyon/actions?tab=readme-ov-file#deploy-preview-of-spin-app-to-fermyon-cloud---fermyonactionsspinpreviewv1

name: Preview on Spin Cloud

on:
pull_request:
	branches: [&quot;main&quot;, &quot;v*&quot;]
	types: ['opened', 'synchronize', 'reopened', 'closed']
workflow_dispatch:

permissions:
contents: read
pull-requests: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
group: &quot;spin&quot;
cancel-in-progress: false

jobs:
Spin-Preview:

	timeout-minutes: 10

	environment:
	name: preview
	url: ${{ steps.preview.outputs.app-url }}

	runs-on: ubuntu-latest

	steps:
	- uses: actions/checkout@v4 # repo checkout

	# Install Rust Nightly Toolchain, with Clippy &amp; Rustfmt
	- name: Install nightly Rust
		uses: dtolnay/rust-toolchain@nightly
		with:
		components: clippy, rustfmt

	- name: Add WASM &amp; WASI targets
		run: rustup target add wasm32-unknown-unknown &amp;&amp; rustup target add wasm32-wasi

	- name: lint
		run: cargo clippy &amp; cargo fmt


	# If using tailwind...
	# - name: Download and install tailwindcss binary
	#   run: npm install -D tailwindcss &amp;&amp; npx tailwindcss -i &lt;INPUT/PATH.css&gt; -o &lt;OUTPUT/PATH.css&gt;  # run tailwind


	- name: Download and install Trunk binary
		run: wget -qO- https://github.com/trunk-rs/trunk/releases/download/v0.18.2/trunk-x86_64-unknown-linux-gnu.tar.gz | tar -xzf-


	- name: Build with Trunk
		run: ./trunk build --release


	# Install Spin CLI &amp; Deploy

	- name: Setup Spin
		uses: fermyon/actions/spin/setup@v1
		# with:
		# plugins:


	- name: Build and preview
		id: preview
		uses: fermyon/actions/spin/preview@v1
		with:
		fermyon_token: ${{ secrets.FERMYON_CLOUD_TOKEN }}
		github_token: ${{ secrets.GITHUB_TOKEN }}
		undeploy: ${{ github.event.pull_request &amp;&amp; github.event.action == 'closed' }}
		# key_values: |-
			# abc=xyz
			# foo=bar
		# variables: |-
			# password=${{ secrets.SECURE_PASSWORD }}
			# apikey=${{ secrets.API_KEY }}


	- name: Display Deployed URL
		run: |
		echo &quot;Deployed app URL: ${{ steps.preview.outputs.app-url }}&quot; &gt;&gt; $GITHUB_STEP_SUMMARY
</code></pre>
</div>
</details>
<p>See <a href="https://github.com/diversable/leptos-spin-CSR">the example repo here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-a-full-stack-ssr-app"><a class="header" href="#deploying-a-full-stack-ssr-app">Deploying a Full-Stack SSR App</a></h1>
<p>It's possible to deploy Leptos fullstack, SSR apps to any number of server or container hosting services. The most simple way to get a Leptos SSR app into production might be to use a VPS service and either run Leptos natively in a VM (<a href="https://github.com/leptos-rs/start-axum?tab=readme-ov-file#executing-a-server-on-a-remote-machine-without-the-toolchain">see here for more details</a>). Alternatively, you could containerize your Leptos app and run it in <a href="https://podman.io/">Podman</a> or <a href="https://www.docker.com/">Docker</a> on any colocated or cloud server.</p>
<p>There are a multitude of different deployment setups and hosting services, and in general, Leptos itself is agnostic to the deployment setup you use. With this diversity of deployment targets in mind, on this page we will go over:</p>
<ul>
<li><a href="deployment/ssr.html#creating-a-containerfile">creating a <code>Containerfile</code> (or <code>Dockerfile</code>) for use with Leptos SSR apps</a></li>
<li>Using a <code>Dockerfile</code> to <a href="deployment/ssr.html#cloud-deployments">deploy to a cloud service</a> - <a href="deployment/ssr.html#deploy-to-flyio">for example, Fly.io</a></li>
<li>Deploying Leptos to <a href="deployment/ssr.html#deploy-to-serverless-runtimes">serverless runtimes</a> - for example, <a href="deployment/ssr.html#aws-lambda">AWS Lambda</a> and <a href="deployment/ssr.html#deno--cloudflare-workers">JS-hosted WASM runtimes like Deno &amp; Cloudflare</a></li>
<li><a href="deployment/ssr.html#currently-unsupported-platforms">Platforms that have not yet gained Leptos SSR support</a></li>
</ul>
<p><em>Note: Leptos does not endorse the use of any particular method of deployment or hosting service.</em></p>
<h2 id="creating-a-containerfile"><a class="header" href="#creating-a-containerfile">Creating a Containerfile</a></h2>
<p>The most popular way for people to deploy full-stack apps built with <code>cargo-leptos</code> is to use a cloud hosting service that supports deployment via a Podman or Docker build. Here’s a sample <code>Containerfile</code> / <code>Dockerfile</code>, which is based on the one we use to deploy the Leptos website.</p>
<pre><code class="language-dockerfile"># Get started with a build env with Rust nightly
FROM rustlang/rust:nightly-bullseye as builder

# If you’re using stable, use this instead
# FROM rust:1.74-bullseye as builder

# Install cargo-binstall, which makes it easier to install other
# cargo extensions like cargo-leptos
RUN wget https://github.com/cargo-bins/cargo-binstall/releases/latest/download/cargo-binstall-x86_64-unknown-linux-musl.tgz
RUN tar -xvf cargo-binstall-x86_64-unknown-linux-musl.tgz
RUN cp cargo-binstall /usr/local/cargo/bin

# Install cargo-leptos
RUN cargo binstall cargo-leptos -y

# Add the WASM target
RUN rustup target add wasm32-unknown-unknown

# Make an /app dir, which everything will eventually live in
RUN mkdir -p /app
WORKDIR /app
COPY . .

# Build the app
RUN cargo leptos build --release -vv

FROM rustlang/rust:nightly-bullseye as runner

# -- NB: update binary name from &quot;leptos_start&quot; to match your app name in Cargo.toml --
# Copy the server binary to the /app directory
COPY --from=builder /app/target/release/leptos_start /app/

# /target/site contains our JS/WASM/CSS, etc.
COPY --from=builder /app/target/site /app/site
# Copy Cargo.toml if it’s needed at runtime
COPY --from=builder /app/Cargo.toml /app/
WORKDIR /app

# Set any required env variables and
ENV RUST_LOG=&quot;info&quot;
ENV LEPTOS_SITE_ADDR=&quot;0.0.0.0:8080&quot;
ENV LEPTOS_SITE_ROOT=&quot;site&quot;
EXPOSE 8080

# -- NB: update binary name from &quot;leptos_start&quot; to match your app name in Cargo.toml --
# Run the server
CMD [&quot;/app/leptos_start&quot;]
</code></pre>
<blockquote>
<p>Read more: <a href="https://github.com/leptos-rs/leptos/issues/1152#issuecomment-1634916088"><code>gnu</code> and <code>musl</code> build files for Leptos apps</a>.</p>
</blockquote>
<h2 id="cloud-deployments"><a class="header" href="#cloud-deployments">Cloud Deployments</a></h2>
<h3 id="deploy-to-flyio"><a class="header" href="#deploy-to-flyio">Deploy to Fly.io</a></h3>
<p>One option for deploying your Leptos SSR app is to use a service like <a href="https://fly.io/">Fly.io</a>, which takes a Dockerfile definition of your Leptos app and runs it in a quick-starting micro-VM; Fly also offers a variety of storage options and managed DBs to use with your projects. The following example will show how to deploy a simple Leptos starter app, just to get you up and going; <a href="https://fly.io/docs/database-storage-guides/">see here for more about working with storage options on Fly.io</a> if and when required.</p>
<p>First, create a <code>Dockerfile</code> in the root of your application and fill it in with the suggested contents (above); make sure to update the binary names in the Dockerfile example
to the name of your own application, and make other adjustments as necessary.</p>
<p>Also, ensure you have the <code>flyctl</code> CLI tool installed, and have an account set up at <a href="https://fly.io/">Fly.io</a>. To install <code>flyctl</code> on MacOS, Linux, or Windows WSL, run:</p>
<pre><code class="language-sh">curl -L https://fly.io/install.sh | sh
</code></pre>
<p>If you have issues, or for installing to other platforms <a href="https://fly.io/docs/hands-on/install-flyctl/">see the full instructions here</a></p>
<p>Then login to Fly.io</p>
<pre><code class="language-sh">fly auth login
</code></pre>
<p>and manually launch your app using the command</p>
<pre><code class="language-sh">fly launch
</code></pre>
<p>The <code>flyctl</code> CLI tool will walk you through the process of deploying your app to Fly.io.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="deployment/ssr.html#admonition-note"></a></p>
</div>
<div>
<p>By default, Fly.io will auto-stop machines that don't have traffic coming to them after a certain period of time. Although Fly.io's lightweight VM's start up quickly, if you want to minimize the latency of your Leptos app and ensure it's always swift to respond, go into the generated <code>fly.toml</code> file and change the <code>min_machines_running</code> to 1 from the default of 0.</p>
<p><a href="https://fly.io/docs/apps/autostart-stop/">See this page in the Fly.io docs for more details</a>.</p>
</div>
</div>
<p>If you would prefer to use Github Actions to manage your deployments, you will need to create a new access token via the <a href="https://fly.io/">Fly.io</a> web UI.</p>
<p>Go to &quot;Account&quot; &gt; &quot;Access Tokens&quot; and create a token named something like &quot;github_actions&quot;, then add the token to your Github repo's secrets by going into your project's Github repo, then clicking
&quot;Settings&quot; &gt; &quot;Secrets and Variables&quot; &gt; &quot;Actions&quot; and creating a &quot;New repository secret&quot; with the name &quot;FLY_API_TOKEN&quot;.</p>
<p>To generate a <code>fly.toml</code> config file for deployment to Fly.io, you must first run the following from within the project source directory</p>
<pre><code class="language-sh">fly launch --no-deploy
</code></pre>
<p>to create a new Fly app and register it with the service. Git commit your new <code>fly.toml</code> file.</p>
<p>To set up the Github Actions deployment workflow, copy the following into a <code>.github/workflows/fly_deploy.yml</code> file:</p>
<details id="admonition-example" class="admonition admonish-example">
<summary class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="deployment/ssr.html#admonition-example"></a></p>
</summary>
<div>
<pre><code># For more details, see: https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/

name: Deploy to Fly.io
on:
push:
	branches:
	- main
jobs:
deploy:
	name: Deploy app
	runs-on: ubuntu-latest
	steps:
	- uses: actions/checkout@v4
	- uses: superfly/flyctl-actions/setup-flyctl@master
	- name: Deploy to fly
		id: deployment
		run: |
		  flyctl deploy --remote-only | tail -n 1 &gt;&gt; $GITHUB_STEP_SUMMARY
		env:
		  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
</code></pre>
</div>
</details>
<p>On the next commit to your Github <code>main</code> branch, your project will automatically deploy to Fly.io.</p>
<p>See <a href="https://github.com/diversable/fly-io-leptos-ssr-test-deploy">the example repo here</a>.</p>
<h2 id="deploy-to-serverless-runtimes"><a class="header" href="#deploy-to-serverless-runtimes">Deploy to Serverless Runtimes</a></h2>
<p>Leptos supports deploying to FaaS (Function as a Service) or 'serverless' runtimes such as AWS Lambda as well as <a href="https://wintercg.org/">WinterCG</a>-compatible JS runtimes such as <a href="https://deno.com/deploy">Deno</a> and Cloudflare. Just be aware that serverless environments do place some restrictions on the functionality available to your SSR app when compared with VM or container type deployments (see notes, below).</p>
<h3 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h3>
<p>With a little help from the <a href="https://www.cargo-lambda.info/">Cargo Lambda</a> tool, Leptos SSR apps can be deployed to AWS Lambda. A starter template repo using Axum as the server is available at <a href="https://github.com/leptos-rs/start-aws">leptos-rs/start-aws</a>; the instructions there can be adapted for you to use a Leptos+Actix-web server as well. The starter repo includes a Github Actions script for CI/CD, as well as instructions for setting up your Lambda functions and getting the necessary credentials for cloud deployment.</p>
<p>However, please keep in mind that some native server functionality does not work with FaaS services like Lambda because the environment is not necessarily consistent from one request to the next. In particular, the <a href="https://github.com/leptos-rs/start-aws#state">'start-aws' docs</a> state that &quot;since AWS Lambda is a serverless platform, you'll need to be more careful about how you manage long-lived state. Writing to disk or using a state extractor will not work reliably across requests. Instead, you'll need a database or other microservices that you can query from the Lambda function.&quot;</p>
<p>The other factor to bear in mind is the 'cold-start' time for functions as a service - depending on your use case and the FaaS platform you use, this may or may not meet your latency requirements; you may need to keep one function running at all times to optimize the speed of your requests.</p>
<h3 id="deno--cloudflare-workers"><a class="header" href="#deno--cloudflare-workers">Deno &amp; Cloudflare Workers</a></h3>
<p>Currently, Leptos-Axum supports running in Javascript-hosted WebAssembly runtimes such as Deno, Cloudflare Workers, etc. This option requires some changes to the setup of your source code (for example, in <code>Cargo.toml</code> you must define your app using <code>crate-type = [&quot;cdylib&quot;]</code> and the &quot;wasm&quot; feature must be enabled for <code>leptos_axum</code>). <a href="https://github.com/leptos-rs/leptos/tree/main/examples/hackernews_js_fetch">The Leptos HackerNews JS-fetch example</a> demonstrates the required modifications and shows how to run an app in the Deno runtime. Additionally, the <a href="https://docs.rs/leptos_axum/latest/leptos_axum/#js-fetch-integration"><code>leptos_axum</code> crate docs</a> are a helpful reference when setting up your own <code>Cargo.toml</code> file for JS-hosted WASM runtimes.</p>
<p>While the initial setup for JS-hosted WASM runtimes is not onerous, the more important restriction to keep in mind is that since your app will be compiled to WebAssembly (<code>wasm32-unknown-unknown</code>) on the server as well as the client, you must ensure that the crates you use in your app are all WASM-compatible; this may or may not be a deal-breaker depending on your app's requirements, as not all crates in the Rust ecosystem have WASM support.</p>
<p>If you're willing to live with the limitations of WASM server-side, the best place to get started right now is by checking out the <a href="https://github.com/leptos-rs/leptos/tree/main/examples/hackernews_js_fetch">example of running Leptos with Deno</a> in the official Leptos Github repo.</p>
<h2 id="platforms-working-on-leptos-support"><a class="header" href="#platforms-working-on-leptos-support">Platforms Working on Leptos Support</a></h2>
<h3 id="deploy-to-spin-serverless-wasi-with-leptos-ssr"><a class="header" href="#deploy-to-spin-serverless-wasi-with-leptos-ssr">Deploy to Spin Serverless WASI (with Leptos SSR)</a></h3>
<p>WebAssembly on the server has been gaining steam lately, and the developers of the open source serverless WebAssembly framework Spin are working on natively supporting Leptos. While the Leptos-Spin SSR integration is still in its early stages, there is a working example you may wish to try out.</p>
<p>The full set of instructions to get Leptos SSR &amp; Spin working together are available as <a href="https://www.fermyon.com/blog/leptos-spin-get-started">a post on the Fermyon blog</a>, or if you want to skip the article and just start playing around with a working starter repo, <a href="https://github.com/diversable/leptos-spin-ssr-test">see here</a>.</p>
<h3 id="deploy-to-shuttlers"><a class="header" href="#deploy-to-shuttlers">Deploy to Shuttle.rs</a></h3>
<p>Several Leptos users have asked about the possibility of using the Rust-friendly <a href="https://www.shuttle.rs/">Shuttle.rs</a> service to deploy Leptos apps. Unfortunately, Leptos is not officially supported by the Shuttle.rs service at the moment.</p>
<p>However, the folks at Shuttle.rs are committed to getting Leptos support in the future; if you would like to keep up-to-date on the status of that work, keep an eye on <a href="https://github.com/shuttle-hq/shuttle/issues/1002#issuecomment-1853661643">this Github issue</a>.</p>
<p>Additionally, some effort has been made to get Shuttle working with Leptos, but to date, deploys to the Shuttle cloud are still not working as expected. That work is available here, if you would like to investigate for yourself or contribute fixes: <a href="https://github.com/Rust-WASI-WASM/shuttle-leptos-axum">Leptos Axum Starter Template for Shuttle.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-wasm-binary-size"><a class="header" href="#optimizing-wasm-binary-size">Optimizing WASM Binary Size</a></h1>
<p>One of the primary downsides of deploying a Rust/WebAssembly frontend app is that splitting a WASM file into smaller chunks to be dynamically loaded is significantly more difficult than splitting a JavaScript bundle. There have been experiments like <a href="https://emscripten.org/docs/optimizing/Module-Splitting.html"><code>wasm-split</code></a> in the Emscripten ecosystem but at present there’s no way to split and dynamically load a Rust/<code>wasm-bindgen</code> binary. This means that the whole WASM binary needs to be loaded before your app becomes interactive. Because the WASM format is designed for streaming compilation, WASM files are much faster to compile per kilobyte than JavaScript files. (For a deeper look, you can <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">read this great article from the Mozilla team</a> on streaming WASM compilation.)</p>
<p>Still, it’s important to ship the smallest WASM binary to users that you can, as it will reduce their network usage and make your app interactive as quickly as possible.</p>
<p>So what are some practical steps?</p>
<h2 id="things-to-do"><a class="header" href="#things-to-do">Things to Do</a></h2>
<ol>
<li>Make sure you’re looking at a release build. (Debug builds are much, much larger.)</li>
<li>Add a release profile for WASM that optimizes for size, not speed.</li>
</ol>
<p>For a <code>cargo-leptos</code> project, for example, you can add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.wasm-release]
inherits = &quot;release&quot;
opt-level = 'z'
lto = true
codegen-units = 1

# ....

[package.metadata.leptos]
# ....
lib-profile-release = &quot;wasm-release&quot;
</code></pre>
<p>This will hyper-optimize the WASM for your release build for size, while keeping your server build optimized for speed. (For a pure client-rendered app without server considerations, just use the <code>[profile.wasm-release]</code> block as your <code>[profile.release]</code>.)</p>
<ol start="3">
<li>
<p>Always serve compressed WASM in production. WASM tends to compress very well, typically shrinking to less than 50% its uncompressed size, and it’s trivial to enable compression for static files being served from Actix or Axum.</p>
</li>
<li>
<p>If you’re using nightly Rust, you can rebuild the standard library with this same profile rather than the prebuilt standard library that’s distributed with the <code>wasm32-unknown-unknown</code> target.</p>
</li>
</ol>
<p>To do this, create a file in your project at <code>.cargo/config.toml</code></p>
<pre><code class="language-toml">[unstable]
build-std = [&quot;std&quot;, &quot;panic_abort&quot;, &quot;core&quot;, &quot;alloc&quot;]
build-std-features = [&quot;panic_immediate_abort&quot;]
</code></pre>
<p>Note that if you're using this with SSR too, the same Cargo profile will be applied. You'll need to explicitly specify your target:</p>
<pre><code class="language-toml">[build]
target = &quot;x86_64-unknown-linux-gnu&quot; # or whatever
</code></pre>
<p>Also note that in some cases, the cfg feature <code>has_std</code> will not be set, which may cause build errors with some dependencies which check for <code>has_std</code>. You may fix any build errors due to this by adding:</p>
<pre><code class="language-toml">[build]
rustflags = [&quot;--cfg=has_std&quot;]
</code></pre>
<p>And you'll need to add <code>panic = &quot;abort&quot;</code> to <code>[profile.release]</code> in <code>Cargo.toml</code>. Note that this applies the same <code>build-std</code> and panic settings to your server binary, which may not be desirable. Some further exploration is probably needed here.</p>
<ol start="5">
<li>One of the sources of binary size in WASM binaries can be <code>serde</code> serialization/deserialization code. Leptos uses <code>serde</code> by default to serialize and deserialize resources created with <code>create_resource</code>. You might try experimenting with the <code>miniserde</code> and <code>serde-lite</code> features, which allow you to use those crates for serialization and deserialization instead; each only implements a subset of <code>serde</code>’s functionality, but typically optimizes for size over speed.</li>
</ol>
<h2 id="things-to-avoid"><a class="header" href="#things-to-avoid">Things to Avoid</a></h2>
<p>There are certain crates that tend to inflate binary sizes. For example, the <code>regex</code> crate with its default features adds about 500kb to a WASM binary (largely because it has to pull in Unicode table data!). In a size-conscious setting, you might consider avoiding regexes in general, or even dropping down and calling browser APIs to use the built-in regex engine instead. (This is what <code>leptos_router</code> does on the few occasions it needs a regular expression.)</p>
<p>In general, Rust’s commitment to runtime performance is sometimes at odds with a commitment to a small binary. For example, Rust monomorphizes generic functions, meaning it creates a distinct copy of the function for each generic type it’s called with. This is significantly faster than dynamic dispatch, but increases binary size. Leptos tries to balance runtime performance with binary size considerations pretty carefully; but you might find that writing code that uses many generics tends to increase binary size. For example, if you have a generic component with a lot of code in its body and call it with four different types, remember that the compiler could include four copies of that same code. Refactoring to use a concrete inner function or helper can often maintain performance and ergonomics while reducing binary size.</p>
<h2 id="a-final-thought"><a class="header" href="#a-final-thought">A Final Thought</a></h2>
<p>Remember that in a server-rendered app, JS bundle size/WASM binary size affects only <em>one</em> thing: time to interactivity on the first load. This is very important to a good user experience: nobody wants to click a button three times and have it do nothing because the interactive code is still loading — but it's not the only important measure.</p>
<p>It’s especially worth remembering that streaming in a single WASM binary means all subsequent navigations are nearly instantaneous, depending only on any additional data loading. Precisely because your WASM binary is <em>not</em> bundle split, navigating to a new route does not require loading additional JS/WASM, as it does in nearly every JavaScript framework. Is this copium? Maybe. Or maybe it’s just an honest trade-off between the two approaches!</p>
<p>Always take the opportunity to optimize the low-hanging fruit in your application. And always test your app under real circumstances with real user network speeds and devices before making any heroic efforts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-islands"><a class="header" href="#guide-islands">Guide: Islands</a></h1>
<p>Leptos 0.5 introduces the new <code>experimental-islands</code> feature. This guide will walk through the islands feature and core concepts, while implementing a demo app using the islands architecture.</p>
<h2 id="the-islands-architecture"><a class="header" href="#the-islands-architecture">The Islands Architecture</a></h2>
<p>The dominant JavaScript frontend frameworks (React, Vue, Svelte, Solid, Angular) all originated as frameworks for building client-rendered single-page apps (SPAs). The initial page load is rendered to HTML, then hydrated, and subsequent navigations are handled directly in the client. (Hence “single page”: everything happens from a single page load from the server, even if there is client-side routing later.) Each of these frameworks later added server-side rendering to improve initial load times, SEO, and user experience.</p>
<p>This means that by default, the entire app is interactive. It also means that the entire app has to be shipped to the client as JavaScript in order to be hydrated. Leptos has followed this same pattern.</p>
<blockquote>
<p>You can read more in the chapters on <a href="./ssr/22_life_cycle.html">server-side rendering</a>.</p>
</blockquote>
<p>But it’s also possible to work in the opposite direction. Rather than taking an entirely-interactive app, rendering it to HTML on the server, and then hydrating it in the browser, you can begin with a plain HTML page and add small areas of interactivity. This is the traditional format for any website or app before the 2010s: your browser makes a series of requests to the server and returns the HTML for each new page in response. After the rise of “single-page apps” (SPA), this approach has sometimes become known as a “multi-page app” (MPA) by comparison.</p>
<p>The phrase “islands architecture” has emerged recently to describe the approach of beginning with a “sea” of server-rendered HTML pages, and adding “islands” of interactivity throughout the page.</p>
<blockquote>
<h3 id="additional-reading"><a class="header" href="#additional-reading">Additional Reading</a></h3>
<p>The rest of this guide will look at how to use islands with Leptos. For more background on the approach in general, check out some of the articles below:</p>
<ul>
<li>Jason Miller, <a href="https://jasonformat.com/islands-architecture/">“Islands Architecture”</a>, Jason Miller</li>
<li>Ryan Carniato, <a href="https://dev.to/this-is-learning/islands-server-components-resumability-oh-my-319d">“Islands &amp; Server Components &amp; Resumability, Oh My!”</a></li>
<li><a href="https://www.patterns.dev/posts/islands-architecture">“Islands Architectures”</a> on patterns.dev</li>
<li><a href="https://docs.astro.build/en/concepts/islands/">Astro Islands</a></li>
</ul>
</blockquote>
<h2 id="activating-islands-mode"><a class="header" href="#activating-islands-mode">Activating Islands Mode</a></h2>
<p>Let’s start with a fresh <code>cargo-leptos</code> app:</p>
<pre><code class="language-bash">cargo leptos new --git leptos-rs/start
</code></pre>
<blockquote>
<p>I’m using Actix because I like it. Feel free to use Axum; there should be approximately no server-specific differences in this guide.</p>
</blockquote>
<p>I’m just going to run</p>
<pre><code class="language-bash">cargo leptos build
</code></pre>
<p>in the background while I fire up my editor and keep writing.</p>
<p>The first thing I’ll do is to add the <code>experimental-islands</code> feature in my <code>Cargo.toml</code>. I need to add this to both <code>leptos</code> and <code>leptos_actix</code>:</p>
<pre><code class="language-toml">leptos = { version = &quot;0.5&quot;, features = [&quot;nightly&quot;, &quot;experimental-islands&quot;] }
leptos_actix = { version = &quot;0.5&quot;, optional = true, features = [
  &quot;experimental-islands&quot;,
] }
</code></pre>
<p>Next I’m going to modify the <code>hydrate</code> function exported from <code>src/lib.rs</code>. I’m going to remove the line that calls <code>leptos::mount_to_body(App)</code> and replace it with</p>
<pre><code class="language-rust">leptos::leptos_dom::HydrationCtx::stop_hydrating();</code></pre>
<p>Each “island” we create will actually act as its own entrypoint, so our <code>hydrate()</code> function just says “okay, hydration’s done now.”</p>
<p>Okay, now fire up your <code>cargo leptos watch</code> and go to <a href="http://localhost:3000"><code>http://localhost:3000</code></a> (or wherever).</p>
<p>Click the button, and...</p>
<p>Nothing happens!</p>
<p>Perfect.</p>
<h2 id="using-islands"><a class="header" href="#using-islands">Using Islands</a></h2>
<p>Nothing happens because we’ve just totally inverted the mental model of our app. Rather than being interactive by default and hydrating everything, the app is now plain HTML by default, and we need to opt into interactivity.</p>
<p>This has a big effect on WASM binary sizes: if I compile in release mode, this app is a measly 24kb of WASM (uncompressed), compared to 355kb in non-islands mode. (355kb is quite large for a “Hello, world!” It’s really just all the code related to client-side routing, which isn’t being used in the demo.)</p>
<p>When we click the button, nothing happens, because our whole page is static.</p>
<p>So how do we make something happen?</p>
<p>Let’s turn the <code>HomePage</code> component into an island!</p>
<p>Here was the non-interactive version:</p>
<pre><code class="language-rust">#[component]
fn HomePage() -&gt; impl IntoView {
    // Creates a reactive value to update the button
    let (count, set_count) = create_signal(0);
    let on_click = move |_| set_count.update(|count| *count += 1);

    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;button on:click=on_click&gt;&quot;Click Me: &quot; {count}&lt;/button&gt;
    }
}</code></pre>
<p>Here’s the interactive version:</p>
<pre><code class="language-rust">#[island]
fn HomePage() -&gt; impl IntoView {
    // Creates a reactive value to update the button
    let (count, set_count) = create_signal(0);
    let on_click = move |_| set_count.update(|count| *count += 1);

    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;button on:click=on_click&gt;&quot;Click Me: &quot; {count}&lt;/button&gt;
    }
}</code></pre>
<p>Now when I click the button, it works!</p>
<p>The <code>#[island]</code> macro works exactly like the <code>#[component]</code> macro, except that in islands mode, it designates this as an interactive island. If we check the binary size again, this is 166kb uncompressed in release mode; much larger than the 24kb totally static version, but much smaller than the 355kb fully-hydrated version.</p>
<p>If you open up the source for the page now, you’ll see that your <code>HomePage</code> island has been rendered as a special <code>&lt;leptos-island&gt;</code> HTML element which specifies which component should be used to hydrate it:</p>
<pre><code class="language-html">&lt;leptos-island data-component=&quot;HomePage&quot; data-hkc=&quot;0-0-0&quot;&gt;
  &lt;h1 data-hk=&quot;0-0-2&quot;&gt;Welcome to Leptos!&lt;/h1&gt;
  &lt;button data-hk=&quot;0-0-3&quot;&gt;
    Click Me:
    &lt;!-- &lt;DynChild&gt; --&gt;11&lt;!-- &lt;/DynChild&gt; --&gt;
  &lt;/button&gt;
&lt;/leptos-island&gt;
</code></pre>
<p>The typical Leptos hydration keys and markers are only present inside the island, only the island is hydrated.</p>
<h2 id="using-islands-effectively"><a class="header" href="#using-islands-effectively">Using Islands Effectively</a></h2>
<p>Remember that <em>only</em> code within an <code>#[island]</code> needs to be compiled to WASM and shipped to the browser. This means that islands should be as small and specific as possible. My <code>HomePage</code>, for example, would be better broken apart into a regular component and an island:</p>
<pre><code class="language-rust">#[component]
fn HomePage() -&gt; impl IntoView {
    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;Counter/&gt;
    }
}

#[island]
fn Counter() -&gt; impl IntoView {
    // Creates a reactive value to update the button
    let (count, set_count) = create_signal(0);
    let on_click = move |_| set_count.update(|count| *count += 1);

    view! {
        &lt;button on:click=on_click&gt;&quot;Click Me: &quot; {count}&lt;/button&gt;
    }
}</code></pre>
<p>Now the <code>&lt;h1&gt;</code> doesn’t need to be included in the client bundle, or hydrated. This seems like a silly distinction now; but note that you can now add as much inert HTML content as you want to the <code>HomePage</code> itself, and the WASM binary size will remain exactly the same.</p>
<p>In regular hydration mode, your WASM binary size grows as a function of the size/complexity of your app. In islands mode, your WASM binary grows as a function of the amount of interactivity in your app. You can add as much non-interactive content as you want, outside islands, and it will not increase that binary size.</p>
<h2 id="unlocking-superpowers"><a class="header" href="#unlocking-superpowers">Unlocking Superpowers</a></h2>
<p>So, this 50% reduction in WASM binary size is nice. But really, what’s the point?</p>
<p>The point comes when you combine two key facts:</p>
<ol>
<li>Code inside <code>#[component]</code> functions now <em>only</em> runs on the server.</li>
<li>Children and props can be passed from the server to islands, without being included in the WASM binary.</li>
</ol>
<p>This means you can run server-only code directly in the body of a component, and pass it directly into the children. Certain tasks that take a complex blend of server functions and Suspense in fully-hydrated apps can be done inline in islands.</p>
<p>We’re going to rely on a third fact in the rest of this demo:</p>
<ol start="3">
<li>Context can be passed between otherwise-independent islands.</li>
</ol>
<p>So, instead of our counter demo, let’s make something a little more fun: a tabbed interface that reads data from files on the server.</p>
<h2 id="passing-server-children-to-islands"><a class="header" href="#passing-server-children-to-islands">Passing Server Children to Islands</a></h2>
<p>One of the most powerful things about islands is that you can pass server-rendered children into an island, without the island needing to know anything about them. Islands hydrate their own content, but not children that are passed to them.</p>
<p>As Dan Abramov of React put it (in the very similar context of RSCs), islands aren’t really islands: they’re donuts. You can pass server-only content directly into the “donut hole,” as it were, allowing you to create tiny atolls of interactivity, surrounded on <em>both</em> sides by the sea of inert server HTML.</p>
<blockquote>
<p>In the demo code included below, I added some styles to show all server content as a light-blue “sea,” and all islands as light-green “land.” Hopefully that will help picture what I’m talking about!</p>
</blockquote>
<p>To continue with the demo: I’m going to create a <code>Tabs</code> component. Switching between tabs will require some interactivity, so of course this will be an island. Let’s start simple for now:</p>
<pre><code class="language-rust">#[island]
fn Tabs(labels: Vec&lt;String&gt;) -&gt; impl IntoView {
    let buttons = labels
        .into_iter()
        .map(|label| view! { &lt;button&gt;{label}&lt;/button&gt; })
        .collect_view();
    view! {
        &lt;div style=&quot;display: flex; width: 100%; justify-content: space-between;&quot;&gt;
            {buttons}
        &lt;/div&gt;
    }
}</code></pre>
<p>Oops. This gives me an error</p>
<pre><code>error[E0463]: can't find crate for `serde`
  --&gt; src/app.rs:43:1
   |
43 | #[island]
   | ^^^^^^^^^ can't find crate
</code></pre>
<p>Easy fix: let’s <code>cargo add serde --features=derive</code>. The <code>#[island]</code> macro wants to pull in <code>serde</code> here because it needs to serialize and deserialize the <code>labels</code> prop.</p>
<p>Now let’s update the <code>HomePage</code> to use <code>Tabs</code>.</p>
<pre><code class="language-rust">#[component]
fn HomePage() -&gt; impl IntoView {
	// these are the files we’re going to read
    let files = [&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;];
	// the tab labels will just be the file names
	let labels = files.iter().copied().map(Into::into).collect();
    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;p&gt;&quot;Click any of the tabs below to read a recipe.&quot;&lt;/p&gt;
        &lt;Tabs labels/&gt;
    }
}</code></pre>
<p>If you take a look in the DOM inspector, you’ll see the island is now something like</p>
<pre><code class="language-html">&lt;leptos-island
  data-component=&quot;Tabs&quot;
  data-hkc=&quot;0-0-0&quot;
  data-props='{&quot;labels&quot;:[&quot;a.txt&quot;,&quot;b.txt&quot;,&quot;c.txt&quot;]}'
&gt;&lt;/leptos-island&gt;
</code></pre>
<p>Our <code>labels</code> prop is getting serialized to JSON and stored in an HTML attribute so it can be used to hydrate the island.</p>
<p>Now let’s add some tabs. For the moment, a <code>Tab</code> island will be really simple:</p>
<pre><code class="language-rust">#[island]
fn Tab(index: usize, children: Children) -&gt; impl IntoView {
    view! {
        &lt;div&gt;{children()}&lt;/div&gt;
    }
}</code></pre>
<p>Each tab, for now will just be a <code>&lt;div&gt;</code> wrapping its children.</p>
<p>Our <code>Tabs</code> component will also get some children: for now, let’s just show them all.</p>
<pre><code class="language-rust">#[island]
fn Tabs(labels: Vec&lt;String&gt;, children: Children) -&gt; impl IntoView {
    let buttons = labels
        .into_iter()
        .map(|label| view! { &lt;button&gt;{label}&lt;/button&gt; })
        .collect_view();
    view! {
        &lt;div style=&quot;display: flex; width: 100%; justify-content: space-around;&quot;&gt;
            {buttons}
        &lt;/div&gt;
        {children()}
    }
}</code></pre>
<p>Okay, now let’s go back into the <code>HomePage</code>. We’re going to create the list of tabs to put into our tab box.</p>
<pre><code class="language-rust">#[component]
fn HomePage() -&gt; impl IntoView {
    let files = [&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;];
    let labels = files.iter().copied().map(Into::into).collect();
	let tabs = move || {
        files
            .into_iter()
            .enumerate()
            .map(|(index, filename)| {
                let content = std::fs::read_to_string(filename).unwrap();
                view! {
                    &lt;Tab index&gt;
                        &lt;h2&gt;{filename.to_string()}&lt;/h2&gt;
                        &lt;p&gt;{content}&lt;/p&gt;
                    &lt;/Tab&gt;
                }
            })
            .collect_view()
    };

    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;p&gt;&quot;Click any of the tabs below to read a recipe.&quot;&lt;/p&gt;
        &lt;Tabs labels&gt;
            &lt;div&gt;{tabs()}&lt;/div&gt;
        &lt;/Tabs&gt;
    }
}</code></pre>
<p>Uh... What?</p>
<p>If you’re used to using Leptos, you know that you just can’t do this. All code in the body of components has to run on the server (to be rendered to HTML) and in the browser (to hydrate), so you can’t just call <code>std::fs</code>; it will panic, because there’s no access to the local filesystem (and certainly not to the server filesystem!) in the browser. This would be a security nightmare!</p>
<p>Except... wait. We’re in islands mode. This <code>HomePage</code> component <em>really does</em> only run on the server. So we can, in fact, just use ordinary server code like this.</p>
<blockquote>
<p><strong>Is this a dumb example?</strong> Yes! Synchronously reading from three different local files in a <code>.map()</code> is not a good choice in real life. The point here is just to demonstrate that this is, definitely, server-only content.</p>
</blockquote>
<p>Go ahead and create three files in the root of the project called <code>a.txt</code>, <code>b.txt</code>, and <code>c.txt</code>, and fill them in with whatever content you’d like.</p>
<p>Refresh the page and you should see the content in the browser. Edit the files and refresh again; it will be updated.</p>
<p>You can pass server-only content from a <code>#[component]</code> into the children of an <code>#[island]</code>, without the island needing to know anything about how to access that data or render that content.</p>
<p><strong>This is really important.</strong> Passing server <code>children</code> to islands means that you can keep islands small. Ideally, you don’t want to slap and <code>#[island]</code> around a whole chunk of your page. You want to break that chunk out into an interactive piece, which can be an <code>#[island]</code>, and a bunch of additional server content that can be passed to that island as <code>children</code>, so that the non-interactive subsections of an interactive part of the page can be kept out of the WASM binary.</p>
<h2 id="passing-context-between-islands"><a class="header" href="#passing-context-between-islands">Passing Context Between Islands</a></h2>
<p>These aren’t really “tabs” yet: they just show every tab, all the time. So let’s add some simple logic to our <code>Tabs</code> and <code>Tab</code> components.</p>
<p>We’ll modify <code>Tabs</code> to create a simple <code>selected</code> signal. We provide the read half via context, and set the value of the signal whenever someone clicks one of our buttons.</p>
<pre><code class="language-rust">#[island]
fn Tabs(labels: Vec&lt;String&gt;, children: Children) -&gt; impl IntoView {
    let (selected, set_selected) = create_signal(0);
    provide_context(selected);

    let buttons = labels
        .into_iter()
        .enumerate()
        .map(|(index, label)| view! {
            &lt;button on:click=move |_| set_selected(index)&gt;
                {label}
            &lt;/button&gt;
        })
        .collect_view();
// ...</code></pre>
<p>And let’s modify the <code>Tab</code> island to use that context to show or hide itself:</p>
<pre><code class="language-rust">#[island]
fn Tab(children: Children) -&gt; impl IntoView {
    let selected = expect_context::&lt;ReadSignal&lt;usize&gt;&gt;();
    view! {
        &lt;div style:display=move || if selected() {
            &quot;block&quot;
        } else {
            &quot;none&quot;
        }&gt;
// ...</code></pre>
<p>Now the tabs behave exactly as I’d expect. <code>Tabs</code> passes the signal via context to each <code>Tab</code>, which uses it to determine whether it should be open or not.</p>
<blockquote>
<p>That’s why in <code>HomePage</code>, I made <code>let tabs = move ||</code> a function, and called it like <code>{tabs()}</code>: creating the tabs lazily this way meant that the <code>Tabs</code> island would already have provided the <code>selected</code> context by the time each <code>Tab</code> went looking for it.</p>
</blockquote>
<p>Our complete tabs demo is about 220kb uncompressed: not the smallest demo in the world, but still about a third smaller than the counter button! Just for kicks, I built the same demo without islands mode, using <code>#[server]</code> functions and <code>Suspense</code>. and it was 429kb. So again, this was about a 50% savings in binary size. And this app includes quite minimal server-only content: remember that as we add additional server-only components and pages, this 220 will not grow.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This demo may seem pretty basic. It is. But there are a number of immediate takeaways:</p>
<ul>
<li><strong>50% WASM binary size reduction</strong>, which means measurable improvements in time to interactivity and initial load times for clients.</li>
<li><strong>Reduced HTML page size.</strong> This one is less obvious, but it’s true and important: HTML generated from <code>#[component]</code>s doesn’t need all the hydration IDs and other boilerplate added.</li>
<li><strong>Reduced data serialization costs.</strong> Creating a resource and reading it on the client means you need to serialize the data, so it can be used for hydration. If you’ve also read that data to create HTML in a <code>Suspense</code>, you end up with “double data,” i.e., the same exact data is both rendered to HTML and serialized as JSON, increasing the size of responses, and therefore slowing them down.</li>
<li><strong>Easily use server-only APIs</strong> inside a <code>#[component]</code> as if it were a normal, native Rust function running on the server—which, in islands mode, it is!</li>
<li><strong>Reduced <code>#[server]</code>/<code>create_resource</code>/<code>Suspense</code> boilerplate</strong> for loading server data.</li>
</ul>
<h2 id="future-exploration"><a class="header" href="#future-exploration">Future Exploration</a></h2>
<p>The <code>experimental-islands</code> feature included in 0.5 reflects work at the cutting edge of what frontend web frameworks are exploring right now. As it stands, our islands approach is very similar to Astro (before its recent View Transitions support): it allows you to build a traditional server-rendered, multi-page app and pretty seamlessly integrate islands of interactivity.</p>
<p>There are some small improvements that will be easy to add. For example, we can do something very much like Astro's View Transitions approach:</p>
<ul>
<li>add client-side routing for islands apps by fetching subsequent navigations from the server and replacing the HTML document with the new one</li>
<li>add animated transitions between the old and new document using the View Transitions API</li>
<li>support explicit persistent islands, i.e., islands that you can mark with unique IDs (something like <code>persist:searchbar</code> on the component in the view), which can be copied over from the old to the new document without losing their current state</li>
</ul>
<p>There are other, larger architectural changes that I’m <a href="https://github.com/leptos-rs/leptos/issues/1830">not sold on yet</a>.</p>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<p>Check out the <a href="https://github.com/leptos-rs/leptos/pull/1660">islands PR</a>, <a href="https://github.com/leptos-rs/leptos/issues/1830">roadmap</a>, and <a href="https://github.com/leptos-rs/leptos/tree/main/examples/hackernews_islands_axum">Hackernews demo</a> for additional discussion.</p>
<h2 id="demo-code"><a class="header" href="#demo-code">Demo Code</a></h2>
<pre><code class="language-rust">use leptos::*;
use leptos_router::*;

#[component]
pub fn App() -&gt; impl IntoView {
    view! {
        &lt;Router&gt;
            &lt;main style=&quot;background-color: lightblue; padding: 10px&quot;&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;&quot; view=HomePage/&gt;
                &lt;/Routes&gt;
            &lt;/main&gt;
        &lt;/Router&gt;
    }
}

/// Renders the home page of your application.
#[component]
fn HomePage() -&gt; impl IntoView {
    let files = [&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;];
    let labels = files.iter().copied().map(Into::into).collect();
    let tabs = move || {
        files
            .into_iter()
            .enumerate()
            .map(|(index, filename)| {
                let content = std::fs::read_to_string(filename).unwrap();
                view! {
                    &lt;Tab index&gt;
                        &lt;div style=&quot;background-color: lightblue; padding: 10px&quot;&gt;
                            &lt;h2&gt;{filename.to_string()}&lt;/h2&gt;
                            &lt;p&gt;{content}&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/Tab&gt;
                }
            })
            .collect_view()
    };

    view! {
        &lt;h1&gt;&quot;Welcome to Leptos!&quot;&lt;/h1&gt;
        &lt;p&gt;&quot;Click any of the tabs below to read a recipe.&quot;&lt;/p&gt;
        &lt;Tabs labels&gt;
            &lt;div&gt;{tabs()}&lt;/div&gt;
        &lt;/Tabs&gt;
    }
}

#[island]
fn Tabs(labels: Vec&lt;String&gt;, children: Children) -&gt; impl IntoView {
    let (selected, set_selected) = create_signal(0);
    provide_context(selected);

    let buttons = labels
        .into_iter()
        .enumerate()
        .map(|(index, label)| {
            view! {
                &lt;button on:click=move |_| set_selected(index)&gt;
                    {label}
                &lt;/button&gt;
            }
        })
        .collect_view();
    view! {
        &lt;div
            style=&quot;display: flex; width: 100%; justify-content: space-around;\
            background-color: lightgreen; padding: 10px;&quot;
        &gt;
            {buttons}
        &lt;/div&gt;
        {children()}
    }
}

#[island]
fn Tab(index: usize, children: Children) -&gt; impl IntoView {
    let selected = expect_context::&lt;ReadSignal&lt;usize&gt;&gt;();
    view! {
        &lt;div
            style:background-color=&quot;lightgreen&quot;
            style:padding=&quot;10px&quot;
            style:display=move || if selected() == index {
                &quot;block&quot;
            } else {
                &quot;none&quot;
            }
        &gt;
            {children()}
        &lt;/div&gt;
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-how-does-the-reactive-system-work"><a class="header" href="#appendix-how-does-the-reactive-system-work">Appendix: How does the Reactive System Work?</a></h1>
<p>You don’t need to know very much about how the reactive system actually works in order to use the library successfully. But it’s always useful to understand what’s going on behind the scenes once you start working with the framework at an advanced level.</p>
<p>The reactive primitives you use are divided into three sets:</p>
<ul>
<li><strong>Signals</strong> (<code>ReadSignal</code>/<code>WriteSignal</code>, <code>RwSignal</code>, <code>Resource</code>, <code>Trigger</code>) Values you can actively change to trigger reactive updates.</li>
<li><strong>Computations</strong> (<code>Memo</code>s) Values that depend on signals (or other computations) and derive a new reactive value through some pure computation.</li>
<li><strong>Effects</strong> Observers that listen to changes in some signals or computations and run a function, causing some side effect.</li>
</ul>
<p>Derived signals are a kind of non-primitve computation: as plain closures, they simply allow you to refactor some repeated signal-based computation into a reusable function that can be called in multiple places, but they are not represented in the reactive system itself.</p>
<p>All the other primitives actually exist in the reactive system as nodes in a reactive graph.</p>
<p>Most of the work of the reactive system consists of propagating changes from signals to effects, possibly through some intervening memos.</p>
<p>The assumption of the reactive system is that effects (like rendering to the DOM or making a network request) are orders of magnitude more expensive than things like updating a Rust data structure inside your app.</p>
<p>So the <strong>primary goal</strong> of the reactive system is to <strong>run effects as infrequently as possible</strong>.</p>
<p>Leptos does this through the construction of a reactive graph.</p>
<blockquote>
<p>Leptos’s current reactive system is based heavily on the <a href="https://github.com/modderme123/reactively">Reactively</a> library for JavaScript. You can read Milo’s article “<a href="https://dev.to/modderme123/super-charging-fine-grained-reactive-performance-47ph">Super-Charging Fine-Grained Reactivity</a>” for an excellent account of its algorithm, as well as fine-grained reactivity in general—including some beautiful diagrams!</p>
</blockquote>
<h2 id="the-reactive-graph"><a class="header" href="#the-reactive-graph">The Reactive Graph</a></h2>
<p>Signals, memos, and effects all share three characteristics:</p>
<ul>
<li><strong>Value</strong> They have a current value: either the signal’s value, or (for memos and effects) the value returned by the previous run, if any.</li>
<li><strong>Sources</strong> Any other reactive primitives they depend on. (For signals, this is an empty set.)</li>
<li><strong>Subscribers</strong> Any other reactive primitives that depend on them. (For effects, this is an empty set.)</li>
</ul>
<p>In reality then, signals, memos, and effects are just conventional names for one generic concept of a “node” in a reactive graph. Signals are always “root nodes,” with no sources/parents. Effects are always “leaf nodes,” with no subscribers. Memos typically have both sources and subscribers.</p>
<h3 id="simple-dependencies"><a class="header" href="#simple-dependencies">Simple Dependencies</a></h3>
<p>So imagine the following code:</p>
<pre><code class="language-rust">// A
let (name, set_name) = create_signal(&quot;Alice&quot;);

// B
let name_upper = create_memo(move |_| name.with(|n| n.to_uppercase()));

// C
create_effect(move |_| {
	log!(&quot;{}&quot;, name_upper());
});

set_name(&quot;Bob&quot;);</code></pre>
<p>You can easily imagine the reactive graph here: <code>name</code> is the only signal/origin node, the <code>create_effect</code> is the only effect/terminal node, and there’s one intervening memo.</p>
<pre><code>A   (name)
|
B   (name_upper)
|
C   (the effect)
</code></pre>
<h3 id="splitting-branches"><a class="header" href="#splitting-branches">Splitting Branches</a></h3>
<p>Let’s make it a little more complex.</p>
<pre><code class="language-rust">// A
let (name, set_name) = create_signal(&quot;Alice&quot;);

// B
let name_upper = create_memo(move |_| name.with(|n| n.to_uppercase()));

// C
let name_len = create_memo(move |_| name.len());

// D
create_effect(move |_| {
	log!(&quot;len = {}&quot;, name_len());
});

// E
create_effect(move |_| {
	log!(&quot;name = {}&quot;, name_upper());
});</code></pre>
<p>This is also pretty straightforward: a signal source signal (<code>name</code>/<code>A</code>) divides into two parallel tracks: <code>name_upper</code>/<code>B</code> and <code>name_len</code>/<code>C</code>, each of which has an effect that depends on it.</p>
<pre><code> __A__
|     |
B     C
|     |
D     E
</code></pre>
<p>Now let’s update the signal.</p>
<pre><code class="language-rust">set_name(&quot;Bob&quot;);</code></pre>
<p>We immediately log</p>
<pre><code>len = 3
name = BOB
</code></pre>
<p>Let’s do it again.</p>
<pre><code class="language-rust">set_name(&quot;Tim&quot;);</code></pre>
<p>The log should shows</p>
<pre><code>name = TIM
</code></pre>
<p><code>len = 3</code> does not log again.</p>
<p>Remember: the goal of the reactive system is to run effects as infrequently as possible. Changing <code>name</code> from <code>&quot;Bob&quot;</code> to <code>&quot;Tim&quot;</code> will cause each of the memos to re-run. But they will only notify their subscribers if their value has actually changed. <code>&quot;BOB&quot;</code> and <code>&quot;TIM&quot;</code> are different, so that effect runs again. But both names have the length <code>3</code>, so they do not run again.</p>
<h3 id="reuniting-branches"><a class="header" href="#reuniting-branches">Reuniting Branches</a></h3>
<p>One more example, of what’s sometimes called <strong>the diamond problem</strong>.</p>
<pre><code class="language-rust">// A
let (name, set_name) = create_signal(&quot;Alice&quot;);

// B
let name_upper = create_memo(move |_| name.with(|n| n.to_uppercase()));

// C
let name_len = create_memo(move |_| name.len());

// D
create_effect(move |_| {
	log!(&quot;{} is {} characters long&quot;, name_upper(), name_len());
});</code></pre>
<p>What does the graph look like for this?</p>
<pre><code> __A__
|     |
B     C
|     |
|__D__|
</code></pre>
<p>You can see why it's called the “diamond problem.” If I’d connected the nodes with straight lines instead of bad ASCII art, it would form a diamond: two memos, each of which depend on a signal, which feed into the same effect.</p>
<p>A naive, push-based reactive implementation would cause this effect to run twice, which would be bad. (Remember, our goal is to run effects as infrequently as we can.) For example, you could implement a reactive system such that signals and memos immediately propagate their changes all the way down the graph, through each dependency, essentially traversing the graph depth-first. In other words, updating <code>A</code> would notify <code>B</code>, which would notify <code>D</code>; then <code>A</code> would notify <code>C</code>, which would notify <code>D</code> again. This is both inefficient (<code>D</code> runs twice) and glitchy (<code>D</code> actually runs with the incorrect value for the second memo during its first run.)</p>
<h2 id="solving-the-diamond-problem"><a class="header" href="#solving-the-diamond-problem">Solving the Diamond Problem</a></h2>
<p>Any reactive implementation worth its salt is dedicated to solving this issue. There are a number of different approaches (again, <a href="https://dev.to/modderme123/super-charging-fine-grained-reactive-performance-47ph">see Milo’s article</a> for an excellent overview).</p>
<p>Here’s how ours works, in brief.</p>
<p>A reactive node is always in one of three states:</p>
<ul>
<li><code>Clean</code>: it is known not to have changed</li>
<li><code>Check</code>: it is possible it has changed</li>
<li><code>Dirty</code>: it has definitely changed</li>
</ul>
<p>Updating a signal <code>Dirty</code> marks that signal <code>Dirty</code>, and marks all its descendants <code>Check</code>, recursively. Any of its descendants that are effects are added to a queue to be re-run.</p>
<pre><code>    ____A (DIRTY)___
   |               |
B (CHECK)    C (CHECK)
   |               |
   |____D (CHECK)__|
</code></pre>
<p>Now those effects are run. (All of the effects will be marked <code>Check</code> at this point.) Before re-running its computation, the effect checks its parents to see if they are dirty. So</p>
<ul>
<li>So <code>D</code> goes to <code>B</code> and checks if it is <code>Dirty</code>.</li>
<li>But <code>B</code> is also marked <code>Check</code>. So <code>B</code> does the same thing:
<ul>
<li><code>B</code> goes to <code>A</code>, and finds that it is <code>Dirty</code>.</li>
<li>This means <code>B</code> needs to re-run, because one of its sources has changed.</li>
<li><code>B</code> re-runs, generating a new value, and marks itself <code>Clean</code></li>
<li>Because <code>B</code> is a memo, it then checks its prior value against the new value.</li>
<li>If they are the same, <code>B</code> returns &quot;no change.&quot; Otherwise, it returns &quot;yes, I changed.&quot;</li>
</ul>
</li>
<li>If <code>B</code> returned “yes, I changed,” <code>D</code> knows that it definitely needs to run and re-runs immediately before checking any other sources.</li>
<li>If <code>B</code> returned “no, I didn’t change,” <code>D</code> continues on to check <code>C</code> (see process above for <code>B</code>.)</li>
<li>If neither <code>B</code> nor <code>C</code> has changed, the effect does not need to re-run.</li>
<li>If either <code>B</code> or <code>C</code> did change, the effect now re-runs.</li>
</ul>
<p>Because the effect is only marked <code>Check</code> once and only queued once, it only runs once.</p>
<p>If the naive version was a “push-based” reactive system, simply pushing reactive changes all the way down the graph and therefore running the effect twice, this version could be called “push-pull.” It pushes the <code>Check</code> status all the way down the graph, but then “pulls” its way back up. In fact, for large graphs it may end up bouncing back up and down and left and right on the graph as it tries to determine exactly which nodes need to re-run.</p>
<p><strong>Note this important trade-off</strong>: Push-based reactivity propagates signal changes more quickly, at the expense of over-re-running memos and effects. Remember: the reactive system is designed to minimize how often you re-run effects, on the (accurate) assumption that side effects are orders of magnitude more expensive than this kind of cache-friendly graph traversal happening entirely inside the library’s Rust code. The measurement of a good reactive system is not how quickly it propagates changes, but how quickly it propagates changes <em>without over-notifying</em>.</p>
<h2 id="memos-vs-signals"><a class="header" href="#memos-vs-signals">Memos vs. Signals</a></h2>
<p>Note that signals always notify their children; i.e., a signal is always marked <code>Dirty</code> when it updates, even if its new value is the same as the old value. Otherwise, we’d have to require <code>PartialEq</code> on signals, and this is actually quite an expensive check on some types. (For example, add an unnecessary equality check to something like <code>some_vec_signal.update(|n| n.pop())</code> when it’s clear that it has in fact changed.)</p>
<p>Memos, on the other hand, check whether they change before notifying their children. They only run their calculation once, no matter how many times you <code>.get()</code> the result, but they run whenever their signal sources change. This means that if the memo’s computation is <em>very</em> expensive, you may actually want to memoize its inputs as well, so that the memo only re-calculates when it is sure its inputs have changed.</p>
<h2 id="memos-vs-derived-signals"><a class="header" href="#memos-vs-derived-signals">Memos vs. Derived Signals</a></h2>
<p>All of this is cool, and memos are pretty great. But most actual applications have reactive graphs that are quite shallow and quite wide: you might have 100 source signals and 500 effects, but no memos or, in rare case, three or four memos between the signal and the effect. Memos are extremely good at what they do: limiting how often they notify their subscribers that they have changed. But as this description of the reactive system should show, they come with overhead in two forms:</p>
<ol>
<li>A <code>PartialEq</code> check, which may or may not be expensive.</li>
<li>Added memory cost of storing another node in the reactive system.</li>
<li>Added computational cost of reactive graph traversal.</li>
</ol>
<p>In cases in which the computation itself is cheaper than this reactive work, you should avoid “over-wrapping” with memos and simply use derived signals. Here’s a great example in which you should never use a memo:</p>
<pre><code class="language-rust">let (a, set_a) = create_signal(1);
// none of these make sense as memos
let b = move || a() + 2;
let c = move || b() % 2 == 0;
let d = move || if c() { &quot;even&quot; } else { &quot;odd&quot; };

set_a(2);
set_a(3);
set_a(5);</code></pre>
<p>Even though memoizing would technically save an extra calculation of <code>d</code> between setting <code>a</code> to <code>3</code> and <code>5</code>, these calculations are themselves cheaper than the reactive algorithm.</p>
<p>At the very most, you might consider memoizing the final node before running some expensive side effect:</p>
<pre><code class="language-rust">let text = create_memo(move |_| {
    d()
});
create_effect(move |_| {
    engrave_text_into_bar_of_gold(&amp;text());
});</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
