<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Forms and Inputs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started/leptos_dx.html"><strong aria-hidden="true">2.1.</strong> Leptos DX</a></li><li class="chapter-item expanded "><a href="../getting_started/community_crates.html"><strong aria-hidden="true">2.2.</strong> The Leptos Community and leptos-* Crates</a></li></ol></li><li class="chapter-item expanded "><a href="../view/index.html"><strong aria-hidden="true">3.</strong> Part 1: Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="../view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="../view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="../view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../view/04b_iteration.html"><strong aria-hidden="true">3.5.</strong> Iterating over More Complex Data</a></li><li class="chapter-item expanded "><a href="../view/05_forms.html" class="active"><strong aria-hidden="true">3.6.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="../view/06_control_flow.html"><strong aria-hidden="true">3.7.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../view/07_errors.html"><strong aria-hidden="true">3.8.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../view/08_parent_child.html"><strong aria-hidden="true">3.9.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="../view/09_component_children.html"><strong aria-hidden="true">3.10.</strong> Passing Children to Components</a></li><li class="chapter-item expanded "><a href="../view/builder.html"><strong aria-hidden="true">3.11.</strong> No Macros: The View Builder Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="../reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="../reactivity/14_create_effect.html"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="../reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="../async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="../async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="../async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="../15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="../router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="../router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="../router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="../router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="../router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="../metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="../csr_wrapping_up.html"><strong aria-hidden="true">12.</strong> Client-Side Rendering: Wrapping Up</a></li><li class="chapter-item expanded "><a href="../ssr/index.html"><strong aria-hidden="true">13.</strong> Part 2: Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ssr/21_cargo_leptos.html"><strong aria-hidden="true">13.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="../ssr/22_life_cycle.html"><strong aria-hidden="true">13.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="../ssr/23_ssr_modes.html"><strong aria-hidden="true">13.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="../ssr/24_hydration_bugs.html"><strong aria-hidden="true">13.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="../server/index.html"><strong aria-hidden="true">14.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/25_server_functions.html"><strong aria-hidden="true">14.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../server/26_extractors.html"><strong aria-hidden="true">14.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="../server/27_response.html"><strong aria-hidden="true">14.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="../progressive_enhancement/index.html"><strong aria-hidden="true">15.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../progressive_enhancement/action_form.html"><strong aria-hidden="true">15.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="../deployment/index.html"><strong aria-hidden="true">16.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../deployment/csr.html"><strong aria-hidden="true">16.1.</strong> Deploying CSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/ssr.html"><strong aria-hidden="true">16.2.</strong> Deploying SSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/binary_size.html"><strong aria-hidden="true">16.3.</strong> Optimizing WASM Binary Size</a></li></ol></li><li class="chapter-item expanded "><a href="../islands.html"><strong aria-hidden="true">17.</strong> Guide: Islands</a></li><li class="chapter-item expanded "><a href="../appendix_reactive_graph.html"><strong aria-hidden="true">18.</strong> Appendix: How Does the Reactive System Work?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="forms-and-inputs"><a class="header" href="#forms-and-inputs">Forms and Inputs</a></h1>
<p>Forms and form inputs are an important part of interactive apps. There are two
basic patterns for interacting with inputs in Leptos, which you may recognize
if you’re familiar with React, SolidJS, or a similar framework: using <strong>controlled</strong>
or <strong>uncontrolled</strong> inputs.</p>
<h2 id="controlled-inputs"><a class="header" href="#controlled-inputs">Controlled Inputs</a></h2>
<p>In a &quot;controlled input,&quot; the framework controls the state of the input
element. On every <code>input</code> event, it updates a local signal that holds the current
state, which in turn updates the <code>value</code> prop of the input.</p>
<p>There are two important things to remember:</p>
<ol>
<li>The <code>input</code> event fires on (almost) every change to the element, while the
<code>change</code> event fires (more or less) when you unfocus the input. You probably
want <code>on:input</code>, but we give you the freedom to choose.</li>
<li>The <code>value</code> <em>attribute</em> only sets the initial value of the input, i.e., it
only updates the input up to the point that you begin typing. The <code>value</code>
<em>property</em> continues updating the input after that. You usually want to set
<code>prop:value</code> for this reason. (The same is true for <code>checked</code> and <code>prop:checked</code>
on an <code>&lt;input type=&quot;checkbox&quot;&gt;</code>.)</li>
</ol>
<pre><code class="language-rust">let (name, set_name) = create_signal(&quot;Controlled&quot;.to_string());

view! {
    &lt;input type=&quot;text&quot;
        on:input=move |ev| {
            // event_target_value is a Leptos helper function
            // it functions the same way as event.target.value
            // in JavaScript, but smooths out some of the typecasting
            // necessary to make this work in Rust
            set_name(event_target_value(&amp;ev));
        }

        // the `prop:` syntax lets you update a DOM property,
        // rather than an attribute.
        prop:value=name
    /&gt;
    &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
}</code></pre>
<blockquote>
<h4 id="why-do-you-need-propvalue"><a class="header" href="#why-do-you-need-propvalue">Why do you need <code>prop:value</code>?</a></h4>
<p>Web browsers are the most ubiquitous and stable platform for rendering graphical user interfaces in existence. They have also maintained an incredible backwards compatibility over their three decades of existence. Inevitably, this means there are some quirks.</p>
<p>One odd quirk is that there is a distinction between HTML attributes and DOM element properties, i.e., between something called an “attribute” which is parsed from HTML and can be set on a DOM element with <code>.setAttribute()</code>, and something called a “property” which is a field of the JavaScript class representation of that parsed HTML element.</p>
<p>In the case of an <code>&lt;input value=...&gt;</code>, setting the <code>value</code> <em>attribute</em> is defined as setting the initial value for the input, and setting <code>value</code> <em>property</em> sets its current value. It maybe easiest to understand this by opening <code>about:blank</code> and running the following JavaScript in the browser console, line by line:</p>
<pre><code class="language-js">// create an input and append it to the DOM
const el = document.createElement(&quot;input&quot;);
document.body.appendChild(el);

el.setAttribute(&quot;value&quot;, &quot;test&quot;); // updates the input
el.setAttribute(&quot;value&quot;, &quot;another test&quot;); // updates the input again

// now go and type into the input: delete some characters, etc.

el.setAttribute(&quot;value&quot;, &quot;one more time?&quot;);
// nothing should have changed. setting the &quot;initial value&quot; does nothing now

// however...
el.value = &quot;But this works&quot;;
</code></pre>
<p>Many other frontend frameworks conflate attributes and properties, or create a special case for inputs that sets the value correctly. Maybe Leptos should do this too; but for now, I prefer giving users the maximum amount of control over whether they’re setting an attribute or a property, and doing my best to educate people about the actual underlying browser behavior rather than obscuring it.</p>
</blockquote>
<h2 id="uncontrolled-inputs"><a class="header" href="#uncontrolled-inputs">Uncontrolled Inputs</a></h2>
<p>In an &quot;uncontrolled input,&quot; the browser controls the state of the input element.
Rather than continuously updating a signal to hold its value, we use a
<a href="https://docs.rs/leptos/latest/leptos/struct.NodeRef.html"><code>NodeRef</code></a> to access
the input once when we want to get its value.</p>
<p>In this example, we only notify the framework when the <code>&lt;form&gt;</code> fires a <code>submit</code>
event.</p>
<pre><code class="language-rust">let (name, set_name) = create_signal(&quot;Uncontrolled&quot;.to_string());

let input_element: NodeRef&lt;Input&gt; = create_node_ref();</code></pre>
<p><code>NodeRef</code> is a kind of reactive smart pointer: we can use it to access the
underlying DOM node. Its value will be set when the element is rendered.</p>
<pre><code class="language-rust">let on_submit = move |ev: SubmitEvent| {
    // stop the page from reloading!
    ev.prevent_default();

    // here, we'll extract the value from the input
    let value = input_element()
        // event handlers can only fire after the view
        // is mounted to the DOM, so the `NodeRef` will be `Some`
        .expect(&quot;&lt;input&gt; to exist&quot;)
        // `NodeRef` implements `Deref` for the DOM element type
        // this means we can call`HtmlInputElement::value()`
        // to get the current value of the input
        .value();
    set_name(value);
};</code></pre>
<p>Our <code>on_submit</code> handler will access the input’s value and use it to call <code>set_name</code>.
To access the DOM node stored in the <code>NodeRef</code>, we can simply call it as a function
(or using <code>.get()</code>). This will return <code>Option&lt;web_sys::HtmlInputElement&gt;</code>, but we
know it will already have been filled when we rendered the view, so it’s safe to
unwrap here.</p>
<p>We can then call <code>.value()</code> to get the value out of the input, because <code>NodeRef</code>
gives us access to a correctly-typed HTML element.</p>
<pre><code class="language-rust">view! {
    &lt;form on:submit=on_submit&gt;
        &lt;input type=&quot;text&quot;
            value=name
            node_ref=input_element
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
    &lt;/form&gt;
    &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
}</code></pre>
<p>The view should be pretty self-explanatory by now. Note two things:</p>
<ol>
<li>Unlike in the controlled input example, we use <code>value</code> (not <code>prop:value</code>).
This is because we’re just setting the initial value of the input, and letting
the browser control its state. (We could use <code>prop:value</code> instead.)</li>
<li>We use <code>node_ref</code> to fill the <code>NodeRef</code>. (Older examples sometimes use <code>_ref</code>.
They are the same thing, but <code>node_ref</code> has better rust-analyzer support.)</li>
</ol>
<h2 id="special-cases-textarea-and-select"><a class="header" href="#special-cases-textarea-and-select">Special Cases: <code>&lt;textarea&gt;</code> and <code>&lt;select&gt;</code></a></h2>
<p>Two form elements tend to cause some confusion, in different ways.</p>
<h3 id="textarea"><a class="header" href="#textarea"><code>&lt;textarea&gt;</code></a></h3>
<p>Unlike <code>&lt;input&gt;</code>, the <code>&lt;textarea&gt;</code> element does not support a <code>value</code> attribute.
Instead, it receives its value as a plain text node in its HTML children,</p>
<p>In the current version of Leptos (in fact in Leptos 0.1-0.5), creating a dynamic child
inserts a comment marker node. This can cause incorrect <code>&lt;textarea&gt;</code> rendering (and issues
during hydration) if you try to use it to show dynamic content.</p>
<p>Instead, you can pass a non-reactive initial value as a child, and use <code>prop:value</code> to
set its current value. (<code>&lt;textarea&gt;</code> doesn’t support the <code>value</code> attribut, but <em>does</em>
support the <code>value</code> property...)</p>
<pre><code class="language-rust">view! {
    &lt;textarea
        prop:value=move || some_value.get()
        on:input=/* etc */
    &gt;
        /* untracked, plain-text initial value */
        {untrack(move || some_value.get())}
    &lt;/textarea&gt;
}</code></pre>
<h3 id="select"><a class="header" href="#select"><code>&lt;select&gt;</code></a></h3>
<p>The <code>&lt;select&gt;</code> element also does not have a <code>value</code> attribute, <em>or</em> a <code>value</code> property.
Instead, its value is determined by the <code>selected</code> attribute of its <code>&lt;option&gt;</code>
fields. Some frameworks obscure this with a <code>value</code> field on <code>&lt;select&gt;</code>; if you try this
in Leptos (or vanilla JavaScript) it won’t work.</p>
<p>Instead, use the <code>selected</code> field:</p>
<pre><code class="language-rust">view! {
    &lt;select&gt;
        &lt;option selected=move || count.get() == 0&gt;&quot;0&quot;&lt;/option&gt;
        &lt;option selected=move || count.get() == 1&gt;&quot;1&quot;&lt;/option&gt;
        &lt;option selected=move || count.get() == 2&gt;&quot;2&quot;&lt;/option&gt;
    &lt;/select&gt;
}</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/5-forms-0-5-rf2t7c?file=%2Fsrc%2Fmain.rs%3A1%2C1">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/5-forms-0-5-rf2t7c?file=%2Fsrc%2Fmain.rs%3A1%2C1" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::{ev::SubmitEvent, *};

#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;h2&gt;&quot;Controlled Component&quot;&lt;/h2&gt;
        &lt;ControlledComponent/&gt;
        &lt;h2&gt;&quot;Uncontrolled Component&quot;&lt;/h2&gt;
        &lt;UncontrolledComponent/&gt;
    }
}

#[component]
fn ControlledComponent() -&gt; impl IntoView {
    // create a signal to hold the value
    let (name, set_name) = create_signal(&quot;Controlled&quot;.to_string());

    view! {
        &lt;input type=&quot;text&quot;
            // fire an event whenever the input changes
            on:input=move |ev| {
                // event_target_value is a Leptos helper function
                // it functions the same way as event.target.value
                // in JavaScript, but smooths out some of the typecasting
                // necessary to make this work in Rust
                set_name(event_target_value(&amp;ev));
            }

            // the `prop:` syntax lets you update a DOM property,
            // rather than an attribute.
            //
            // IMPORTANT: the `value` *attribute* only sets the
            // initial value, until you have made a change.
            // The `value` *property* sets the current value.
            // This is a quirk of the DOM; I didn't invent it.
            // Other frameworks gloss this over; I think it's
            // more important to give you access to the browser
            // as it really works.
            //
            // tl;dr: use prop:value for form inputs
            prop:value=name
        /&gt;
        &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
    }
}

#[component]
fn UncontrolledComponent() -&gt; impl IntoView {
    // import the type for &lt;input&gt;
    use leptos::html::Input;

    let (name, set_name) = create_signal(&quot;Uncontrolled&quot;.to_string());

    // we'll use a NodeRef to store a reference to the input element
    // this will be filled when the element is created
    let input_element: NodeRef&lt;Input&gt; = create_node_ref();

    // fires when the form `submit` event happens
    // this will store the value of the &lt;input&gt; in our signal
    let on_submit = move |ev: SubmitEvent| {
        // stop the page from reloading!
        ev.prevent_default();

        // here, we'll extract the value from the input
        let value = input_element()
            // event handlers can only fire after the view
            // is mounted to the DOM, so the `NodeRef` will be `Some`
            .expect(&quot;&lt;input&gt; to exist&quot;)
            // `NodeRef` implements `Deref` for the DOM element type
            // this means we can call`HtmlInputElement::value()`
            // to get the current value of the input
            .value();
        set_name(value);
    };

    view! {
        &lt;form on:submit=on_submit&gt;
            &lt;input type=&quot;text&quot;
                // here, we use the `value` *attribute* to set only
                // the initial value, letting the browser maintain
                // the state after that
                value=name

                // store a reference to this input in `input_element`
                node_ref=input_element
            /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
        &lt;/form&gt;
        &lt;p&gt;&quot;Name is: &quot; {name}&lt;/p&gt;
    }
}

// This `main` function is the entry point into the app
// It just mounts our component to the &lt;body&gt;
// Because we defined it as `fn App`, we can now use it in a
// template as &lt;App/&gt;
fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../view/04b_iteration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../view/06_control_flow.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../view/04b_iteration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../view/06_control_flow.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
