<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parent-Child Communication</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting_started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started/leptos_dx.html"><strong aria-hidden="true">2.1.</strong> Leptos DX</a></li><li class="chapter-item expanded "><a href="../getting_started/community_crates.html"><strong aria-hidden="true">2.2.</strong> The Leptos Community and leptos-* Crates</a></li></ol></li><li class="chapter-item expanded "><a href="../view/index.html"><strong aria-hidden="true">3.</strong> Part 1: Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="../view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="../view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="../view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../view/04b_iteration.html"><strong aria-hidden="true">3.5.</strong> Iterating over More Complex Data</a></li><li class="chapter-item expanded "><a href="../view/05_forms.html"><strong aria-hidden="true">3.6.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="../view/06_control_flow.html"><strong aria-hidden="true">3.7.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../view/07_errors.html"><strong aria-hidden="true">3.8.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../view/08_parent_child.html" class="active"><strong aria-hidden="true">3.9.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="../view/09_component_children.html"><strong aria-hidden="true">3.10.</strong> Passing Children to Components</a></li><li class="chapter-item expanded "><a href="../view/builder.html"><strong aria-hidden="true">3.11.</strong> No Macros: The View Builder Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="../reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="../reactivity/14_create_effect.html"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="../reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="../async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="../async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="../async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="../15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="../router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="../router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="../router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="../router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="../router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="../metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="../csr_wrapping_up.html"><strong aria-hidden="true">12.</strong> Client-Side Rendering: Wrapping Up</a></li><li class="chapter-item expanded "><a href="../ssr/index.html"><strong aria-hidden="true">13.</strong> Part 2: Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ssr/21_cargo_leptos.html"><strong aria-hidden="true">13.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="../ssr/22_life_cycle.html"><strong aria-hidden="true">13.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="../ssr/23_ssr_modes.html"><strong aria-hidden="true">13.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="../ssr/24_hydration_bugs.html"><strong aria-hidden="true">13.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="../server/index.html"><strong aria-hidden="true">14.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/25_server_functions.html"><strong aria-hidden="true">14.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../server/26_extractors.html"><strong aria-hidden="true">14.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="../server/27_response.html"><strong aria-hidden="true">14.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="../progressive_enhancement/index.html"><strong aria-hidden="true">15.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../progressive_enhancement/action_form.html"><strong aria-hidden="true">15.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="../deployment/index.html"><strong aria-hidden="true">16.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../deployment/csr.html"><strong aria-hidden="true">16.1.</strong> Deploying CSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/ssr.html"><strong aria-hidden="true">16.2.</strong> Deploying SSR Apps</a></li><li class="chapter-item expanded "><a href="../deployment/binary_size.html"><strong aria-hidden="true">16.3.</strong> Optimizing WASM Binary Size</a></li></ol></li><li class="chapter-item expanded "><a href="../islands.html"><strong aria-hidden="true">17.</strong> Guide: Islands</a></li><li class="chapter-item expanded "><a href="../appendix_reactive_graph.html"><strong aria-hidden="true">18.</strong> Appendix: How Does the Reactive System Work?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parent-child-communication"><a class="header" href="#parent-child-communication">Parent-Child Communication</a></h1>
<p>You can think of your application as a nested tree of components. Each component
handles its own local state and manages a section of the user interface, so
components tend to be relatively self-contained.</p>
<p>Sometimes, though, you’ll want to communicate between a parent component and its
child. For example, imagine you’ve defined a <code>&lt;FancyButton/&gt;</code> component that adds
some styling, logging, or something else to a <code>&lt;button/&gt;</code>. You want to use a
<code>&lt;FancyButton/&gt;</code> in your <code>&lt;App/&gt;</code> component. But how can you communicate between
the two?</p>
<p>It’s easy to communicate state from a parent component to a child component. We
covered some of this in the material on <a href="./03_components.html">components and props</a>.
Basically if you want the parent to communicate to the child, you can pass a
<a href="https://docs.rs/leptos/latest/leptos/struct.ReadSignal.html"><code>ReadSignal</code></a>, a
<a href="https://docs.rs/leptos/latest/leptos/struct.Signal.html"><code>Signal</code></a>, or even a
<a href="https://docs.rs/leptos/latest/leptos/enum.MaybeSignal.html"><code>MaybeSignal</code></a> as a prop.</p>
<p>But what about the other direction? How can a child send notifications about events
or state changes back up to the parent?</p>
<p>There are four basic patterns of parent-child communication in Leptos.</p>
<h2 id="1-pass-a-writesignal"><a class="header" href="#1-pass-a-writesignal">1. Pass a <a href="https://docs.rs/leptos/latest/leptos/struct.WriteSignal.html"><code>WriteSignal</code></a></a></h2>
<p>One approach is simply to pass a <code>WriteSignal</code> from the parent down to the child, and update
it in the child. This lets you manipulate the state of the parent from the child.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonA setter=set_toggled/&gt;
    }
}

#[component]
pub fn ButtonA(setter: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>This pattern is simple, but you should be careful with it: passing around a <code>WriteSignal</code>
can make it hard to reason about your code. In this example, it’s pretty clear when you
read <code>&lt;App/&gt;</code> that you are handing off the ability to mutate <code>toggled</code>, but it’s not at
all clear when or how it will change. In this small, local example it’s easy to understand,
but if you find yourself passing around <code>WriteSignal</code>s like this throughout your code,
you should really consider whether this is making it too easy to write spaghetti code.</p>
<h2 id="2-use-a-callback"><a class="header" href="#2-use-a-callback">2. Use a Callback</a></h2>
<p>Another approach would be to pass a callback to the child: say, <code>on_click</code>.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonB on_click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonB(#[prop(into)] on_click: Callback&lt;MouseEvent&gt;) -&gt; impl IntoView
{
    view! {
        &lt;button on:click=on_click&gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>You’ll notice that whereas <code>&lt;ButtonA/&gt;</code> was given a <code>WriteSignal</code> and decided how to mutate it,
<code>&lt;ButtonB/&gt;</code> simply fires an event: the mutation happens back in <code>&lt;App/&gt;</code>. This has the advantage
of keeping local state local, preventing the problem of spaghetti mutation. But it also means
the logic to mutate that signal needs to exist up in <code>&lt;App/&gt;</code>, not down in <code>&lt;ButtonB/&gt;</code>. These
are real trade-offs, not a simple right-or-wrong choice.</p>
<blockquote>
<p>Note the way we use the <code>Callback&lt;In, Out&gt;</code> type. This is basically a
wrapper around a closure <code>Fn(In) -&gt; Out</code> that is also <code>Copy</code> and makes it
easy to pass around.</p>
<p>We also used the <code>#[prop(into)]</code> attribute so we can pass a normal closure into
<code>on_click</code>. Please see the <a href="./03_components.html#into-props">chapter &quot;<code>into</code> Props&quot;</a> for more details.</p>
</blockquote>
<h3 id="21-use-closure-instead-of-callback"><a class="header" href="#21-use-closure-instead-of-callback">2.1 Use Closure instead of <code>Callback</code></a></h3>
<p>You can use a Rust closure <code>Fn(MouseEvent)</code> directly instead of <code>Callback</code>:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;ButtonB on_click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonB&lt;F&gt;(on_click: F) -&gt; impl IntoView
where
    F: Fn(MouseEvent) + 'static
{
    view! {
        &lt;button on:click=on_click&gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>The code is very similar in this case. On more advanced use-cases using a
closure might require some cloning compared to using a <code>Callback</code>.</p>
<blockquote>
<p>Note the way we declare the generic type <code>F</code> here for the callback. If you’re
confused, look back at the <a href="./03_components.html#generic-props">generic props</a> section
of the chapter on components.</p>
</blockquote>
<h2 id="3-use-an-event-listener"><a class="header" href="#3-use-an-event-listener">3. Use an Event Listener</a></h2>
<p>You can actually write Option 2 in a slightly different way. If the callback maps directly onto
a native DOM event, you can add an <code>on:</code> listener directly to the place you use the component
in your <code>view</code> macro in <code>&lt;App/&gt;</code>.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        // note the on:click instead of on_click
        // this is the same syntax as an HTML element event listener
        &lt;ButtonC on:click=move |_| set_toggled.update(|value| *value = !*value)/&gt;
    }
}


#[component]
pub fn ButtonC() -&gt; impl IntoView {
    view! {
        &lt;button&gt;&quot;Toggle&quot;&lt;/button&gt;
    }
}</code></pre>
<p>This lets you write way less code in <code>&lt;ButtonC/&gt;</code> than you did for <code>&lt;ButtonB/&gt;</code>,
and still gives a correctly-typed event to the listener. This works by adding an
<code>on:</code> event listener to each element that <code>&lt;ButtonC/&gt;</code> returns: in this case, just
the one <code>&lt;button&gt;</code>.</p>
<p>Of course, this only works for actual DOM events that you’re passing directly through
to the elements you’re rendering in the component. For more complex logic that
doesn’t map directly onto an element (say you create <code>&lt;ValidatedForm/&gt;</code> and want an
<code>on_valid_form_submit</code> callback) you should use Option 2.</p>
<h2 id="4-providing-a-context"><a class="header" href="#4-providing-a-context">4. Providing a Context</a></h2>
<p>This version is actually a variant on Option 1. Say you have a deeply-nested component
tree:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout/&gt;
    }
}

#[component]
pub fn Layout() -&gt; impl IntoView {
    view! {
        &lt;header&gt;
            &lt;h1&gt;&quot;My Page&quot;&lt;/h1&gt;
        &lt;/header&gt;
        &lt;main&gt;
            &lt;Content/&gt;
        &lt;/main&gt;
    }
}

#[component]
pub fn Content() -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;content&quot;&gt;
            &lt;ButtonD/&gt;
        &lt;/div&gt;
    }
}

#[component]
pub fn ButtonD&lt;F&gt;() -&gt; impl IntoView {
    todo!()
}</code></pre>
<p>Now <code>&lt;ButtonD/&gt;</code> is no longer a direct child of <code>&lt;App/&gt;</code>, so you can’t simply
pass your <code>WriteSignal</code> to its props. You could do what’s sometimes called
“prop drilling,” adding a prop to each layer between the two:</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);
    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout set_toggled/&gt;
    }
}

#[component]
pub fn Layout(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;header&gt;
            &lt;h1&gt;&quot;My Page&quot;&lt;/h1&gt;
        &lt;/header&gt;
        &lt;main&gt;
            &lt;Content set_toggled/&gt;
        &lt;/main&gt;
    }
}

#[component]
pub fn Content(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    view! {
        &lt;div class=&quot;content&quot;&gt;
            &lt;ButtonD set_toggled/&gt;
        &lt;/div&gt;
    }
}

#[component]
pub fn ButtonD&lt;F&gt;(set_toggled: WriteSignal&lt;bool&gt;) -&gt; impl IntoView {
    todo!()
}</code></pre>
<p>This is a mess. <code>&lt;Layout/&gt;</code> and <code>&lt;Content/&gt;</code> don’t need <code>set_toggled</code>; they just
pass it through to <code>&lt;ButtonD/&gt;</code>. But I need to declare the prop in triplicate.
This is not only annoying but hard to maintain: imagine we add a “half-toggled”
option and the type of <code>set_toggled</code> needs to change to an <code>enum</code>. We have to change
it in three places!</p>
<p>Isn’t there some way to skip levels?</p>
<p>There is!</p>
<h3 id="41-the-context-api"><a class="header" href="#41-the-context-api">4.1 The Context API</a></h3>
<p>You can provide data that skips levels by using <a href="https://docs.rs/leptos/latest/leptos/fn.provide_context.html"><code>provide_context</code></a>
and <a href="https://docs.rs/leptos/latest/leptos/fn.use_context.html"><code>use_context</code></a>. Contexts are identified
by the type of the data you provide (in this example, <code>WriteSignal&lt;bool&gt;</code>), and they exist in a top-down
tree that follows the contours of your UI tree. In this example, we can use context to skip the
unnecessary prop drilling.</p>
<pre><code class="language-rust">#[component]
pub fn App() -&gt; impl IntoView {
    let (toggled, set_toggled) = create_signal(false);

    // share `set_toggled` with all children of this component
    provide_context(set_toggled);

    view! {
        &lt;p&gt;&quot;Toggled? &quot; {toggled}&lt;/p&gt;
        &lt;Layout/&gt;
    }
}

// &lt;Layout/&gt; and &lt;Content/&gt; omitted
// To work in this version, drop their references to set_toggled

#[component]
pub fn ButtonD() -&gt; impl IntoView {
    // use_context searches up the context tree, hoping to
    // find a `WriteSignal&lt;bool&gt;`
    // in this case, I .expect() because I know I provided it
    let setter = use_context::&lt;WriteSignal&lt;bool&gt;&gt;()
        .expect(&quot;to have found the setter provided&quot;);

    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle&quot;
        &lt;/button&gt;
    }
}</code></pre>
<p>The same caveats apply to this as to <code>&lt;ButtonA/&gt;</code>: passing a <code>WriteSignal</code>
around should be done with caution, as it allows you to mutate state from
arbitrary parts of your code. But when done carefully, this can be one of
the most effective techniques for global state management in Leptos: simply
provide the state at the highest level you’ll need it, and use it wherever
you need it lower down.</p>
<p>Note that there are no performance downsides to this approach. Because you
are passing a fine-grained reactive signal, <em>nothing happens</em> in the intervening
components (<code>&lt;Layout/&gt;</code> and <code>&lt;Content/&gt;</code>) when you update it. You are communicating
directly between <code>&lt;ButtonD/&gt;</code> and <code>&lt;App/&gt;</code>. In fact—and this is the power of
fine-grained reactivity—you are communicating directly between a button click
in <code>&lt;ButtonD/&gt;</code> and a single text node in <code>&lt;App/&gt;</code>. It’s as if the components
themselves don’t exist at all. And, well... at runtime, they don’t. It’s just
signals and effects, all the way down.</p>
<p><a href="https://codesandbox.io/p/sandbox/8-parent-child-0-5-7rz7qd?file=%2Fsrc%2Fmain.rs%3A1%2C2">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/8-parent-child-0-5-7rz7qd?file=%2Fsrc%2Fmain.rs%3A1%2C2" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::{ev::MouseEvent, *};

// This highlights four different ways that child components can communicate
// with their parent:
// 1) &lt;ButtonA/&gt;: passing a WriteSignal as one of the child component props,
//    for the child component to write into and the parent to read
// 2) &lt;ButtonB/&gt;: passing a closure as one of the child component props, for
//    the child component to call
// 3) &lt;ButtonC/&gt;: adding an `on:` event listener to a component
// 4) &lt;ButtonD/&gt;: providing a context that is used in the component (rather than prop drilling)

#[derive(Copy, Clone)]
struct SmallcapsContext(WriteSignal&lt;bool&gt;);

#[component]
pub fn App() -&gt; impl IntoView {
    // just some signals to toggle three classes on our &lt;p&gt;
    let (red, set_red) = create_signal(false);
    let (right, set_right) = create_signal(false);
    let (italics, set_italics) = create_signal(false);
    let (smallcaps, set_smallcaps) = create_signal(false);

    // the newtype pattern isn't *necessary* here but is a good practice
    // it avoids confusion with other possible future `WriteSignal&lt;bool&gt;` contexts
    // and makes it easier to refer to it in ButtonC
    provide_context(SmallcapsContext(set_smallcaps));

    view! {
        &lt;main&gt;
            &lt;p
                // class: attributes take F: Fn() =&gt; bool, and these signals all implement Fn()
                class:red=red
                class:right=right
                class:italics=italics
                class:smallcaps=smallcaps
            &gt;
                &quot;Lorem ipsum sit dolor amet.&quot;
            &lt;/p&gt;

            // Button A: pass the signal setter
            &lt;ButtonA setter=set_red/&gt;

            // Button B: pass a closure
            &lt;ButtonB on_click=move |_| set_right.update(|value| *value = !*value)/&gt;

            // Button B: use a regular event listener
            // setting an event listener on a component like this applies it
            // to each of the top-level elements the component returns
            &lt;ButtonC on:click=move |_| set_italics.update(|value| *value = !*value)/&gt;

            // Button D gets its setter from context rather than props
            &lt;ButtonD/&gt;
        &lt;/main&gt;
    }
}

/// Button A receives a signal setter and updates the signal itself
#[component]
pub fn ButtonA(
    /// Signal that will be toggled when the button is clicked.
    setter: WriteSignal&lt;bool&gt;,
) -&gt; impl IntoView {
    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle Red&quot;
        &lt;/button&gt;
    }
}

/// Button B receives a closure
#[component]
pub fn ButtonB&lt;F&gt;(
    /// Callback that will be invoked when the button is clicked.
    on_click: F,
) -&gt; impl IntoView
where
    F: Fn(MouseEvent) + 'static,
{
    view! {
        &lt;button
            on:click=on_click
        &gt;
            &quot;Toggle Right&quot;
        &lt;/button&gt;
    }

    // just a note: in an ordinary function ButtonB could take on_click: impl Fn(MouseEvent) + 'static
    // and save you from typing out the generic
    // the component macro actually expands to define a
    //
    // struct ButtonBProps&lt;F&gt; where F: Fn(MouseEvent) + 'static {
    //   on_click: F
    // }
    //
    // this is what allows us to have named props in our component invocation,
    // instead of an ordered list of function arguments
    // if Rust ever had named function arguments we could drop this requirement
}

/// Button C is a dummy: it renders a button but doesn't handle
/// its click. Instead, the parent component adds an event listener.
#[component]
pub fn ButtonC() -&gt; impl IntoView {
    view! {
        &lt;button&gt;
            &quot;Toggle Italics&quot;
        &lt;/button&gt;
    }
}

/// Button D is very similar to Button A, but instead of passing the setter as a prop
/// we get it from the context
#[component]
pub fn ButtonD() -&gt; impl IntoView {
    let setter = use_context::&lt;SmallcapsContext&gt;().unwrap().0;

    view! {
        &lt;button
            on:click=move |_| setter.update(|value| *value = !*value)
        &gt;
            &quot;Toggle Small Caps&quot;
        &lt;/button&gt;
    }
}

fn main() {
    leptos::mount_to_body(App)
}</code></pre>
</details>
</preview>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../view/07_errors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../view/09_component_children.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../view/07_errors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../view/09_component_children.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
